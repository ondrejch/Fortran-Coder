fpm.f90_stripped module fpm use fpm_strings, only: string_t, operator(.in.), glob, join, string_cat, &                       lower, str_ends_with, is_fortran_name, str_begins_with_str, &                       is_valid_module_name, len_trim use fpm_backend, only: build_package use fpm_command_line, only: fpm_build_settings, fpm_new_settings, &                       fpm_run_settings, fpm_install_settings, fpm_test_settings, &                       fpm_clean_settings use fpm_dependency, only : new_dependency_tree use fpm_filesystem, only: is_dir, join_path, list_files, exists, &                    basename, filewrite, mkdir, run, os_delete_dir use fpm_model, only: fpm_model_t, srcfile_t, show_model, fortran_features_t, &                     FPM_SCOPE_UNKNOWN, FPM_SCOPE_LIB, FPM_SCOPE_DEP, &                     FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST use fpm_compiler, only: new_compiler, new_archiver, set_cpp_preprocessor_flags   use fpm_sources, only: add_executable_sources, add_sources_from_dir use fpm_targets, only: targets_from_sources, build_target_t, build_target_ptr, &                         FPM_TARGET_EXECUTABLE, FPM_TARGET_ARCHIVE use fpm_manifest, only : get_package_data, package_config_t use fpm_meta, only : resolve_metapackages use fpm_error, only : error_t, fatal_error, fpm_stop use, intrinsic :: iso_fortran_env, only : stdin => input_unit, &                                         & stdout => output_unit, &                                         & stderr => error_unit use iso_c_binding, only: c_char, c_ptr, c_int, c_null_char, c_associated, c_f_pointer use fpm_environment, only: os_is_unix  implicit none private public :: cmd_build, cmd_run, cmd_clean public :: build_model, check_modules_for_duplicates  contains   subroutine build_model(model, settings, package, error)     type(fpm_model_t), intent(out) :: model     class(fpm_build_settings), intent(inout) :: settings     type(package_config_t), intent(inout) :: package     type(error_t), allocatable, intent(out) :: error      integer :: i, j     type(package_config_t) :: dependency     character(len=:), allocatable :: manifest, lib_dir     logical :: has_cpp     logical :: duplicates_found     type(string_t) :: include_dir      model%package_name = package%name      allocate(model%include_dirs(0))     allocate(model%link_libraries(0))     allocate(model%external_modules(0))      call new_compiler(model%compiler, settings%compiler, settings%c_compiler, &         & settings%cxx_compiler, echo=settings%verbose, verbose=settings%verbose)     call new_archiver(model%archiver, settings%archiver, &         & echo=settings%verbose, verbose=settings%verbose)      if (model%compiler%is_unknown()) then         write(*, '(*(a:,1x))') &             "<WARN>", "Unknown compiler", model%compiler%fc, "requested             "     end if      call new_compiler_flags(model,settings)     model%build_prefix = join_path("build", basename(model%compiler%fc))     model%include_tests = settings%build_tests     model%enforce_module_names = package%build%module_naming     model%module_prefix = package%build%module_prefix           call resolve_metapackages(model,package,settings,error)     if (allocated(error)) return           call new_dependency_tree(model%deps, cache=join_path("build", "cache.toml"))           call model%deps%add(package, error)     if (allocated(error)) return           call model%deps%update(error)     if (allocated(error)) return           if (.not.exists("build/.gitignore")) then       call filewrite(join_path("build", ".gitignore"),["*"])     end if      allocate(model%packages(model%deps%ndep))      has_cpp = .false.     do i = 1, model%deps%ndep         associate(dep => model%deps%dep(i))             manifest = join_path(dep%proj_dir, "fpm.toml")              call get_package_data(dependency, manifest, error, apply_defaults=.true.)             if (allocated(error)) exit              model%packages(i)%name = dependency%name             associate(features => model%packages(i)%features)                 features%implicit_typing = dependency%fortran%implicit_typing                 features%implicit_external = dependency%fortran%implicit_external                 features%source_form = dependency%fortran%source_form             end associate             model%packages(i)%version = package%version%s()                           call model%packages(i)%preprocess%destroy()              if (allocated(dependency%preprocess)) then                 do j = 1, size(dependency%preprocess)                     call model%packages(i)%preprocess%add_config(dependency%preprocess(j))                 end do             end if                           if (allocated(dep%preprocess)) then                 do j = 1, size(dep%preprocess)                     call model%packages(i)%preprocess%add_config(dep%preprocess(j))                 end do             end if              if (model%packages(i)%preprocess%is_cpp()) has_cpp = .true.              if (.not.allocated(model%packages(i)%sources)) allocate(model%packages(i)%sources(0))              if (allocated(dependency%library)) then                  if (allocated(dependency%library%source_dir)) then                     lib_dir = join_path(dep%proj_dir, dependency%library%source_dir)                     if (is_dir(lib_dir)) then                         call add_sources_from_dir(model%packages(i)%sources, lib_dir, FPM_SCOPE_LIB, &                             with_f_ext=model%packages(i)%preprocess%suffixes, error=error)                         if (allocated(error)) exit                     end if                 end if                  if (allocated(dependency%library%include_dir)) then                     do j=1,size(dependency%library%include_dir)                         include_dir%s = join_path(dep%proj_dir, dependency%library%include_dir(j)%s)                         if (is_dir(include_dir%s)) then                             model%include_dirs = [model%include_dirs, include_dir]                         end if                     end do                 end if              end if              if (allocated(dependency%build%link)) then                 model%link_libraries = [model%link_libraries, dependency%build%link]             end if              if (allocated(dependency%build%external_modules)) then                 model%external_modules = [model%external_modules, dependency%build%external_modules]             end if                           model%packages(i)%enforce_module_names = dependency%build%module_naming             model%packages(i)%module_prefix        = dependency%build%module_prefix          end associate     end do     if (allocated(error)) return           if (has_cpp) call set_cpp_preprocessor_flags(model%compiler%id, model%fortran_compile_flags)           if (is_dir('app') .and. package%build%auto_executables) then         call add_sources_from_dir(model%packages(1)%sources,'app', FPM_SCOPE_APP, &                                    with_executables=.true., with_f_ext=model%packages(1)%preprocess%suffixes,&                                    error=error)          if (allocated(error)) then             return         end if      end if     if (is_dir('example') .and. package%build%auto_examples) then         call add_sources_from_dir(model%packages(1)%sources,'example', FPM_SCOPE_EXAMPLE, &                                   with_executables=.true., &                                   with_f_ext=model%packages(1)%preprocess%suffixes,error=error)          if (allocated(error)) then             return         end if      end if     if (is_dir('test') .and. package%build%auto_tests) then         call add_sources_from_dir(model%packages(1)%sources,'test', FPM_SCOPE_TEST, &                                   with_executables=.true., &                                   with_f_ext=model%packages(1)%preprocess%suffixes,error=error)          if (allocated(error)) then             return         endif      end if     if (allocated(package%executable)) then         call add_executable_sources(model%packages(1)%sources, package%executable, FPM_SCOPE_APP, &                                      auto_discover=package%build%auto_executables, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         end if      end if     if (allocated(package%example)) then         call add_executable_sources(model%packages(1)%sources, package%example, FPM_SCOPE_EXAMPLE, &                                      auto_discover=package%build%auto_examples, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         end if      end if     if (allocated(package%test)) then         call add_executable_sources(model%packages(1)%sources, package%test, FPM_SCOPE_TEST, &                                      auto_discover=package%build%auto_tests, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         endif      endif      if (settings%verbose) then         write(*,*)'<INFO> BUILD_NAME: ',model%build_prefix         write(*,*)'<INFO>          write(*,*)'<INFO>          write(*,*)'<INFO>          write(*,*)'<INFO>          write(*,*)'<INFO>          write(*,*)'<INFO>          write(*,*)'<INFO> LINKER OPTIONS:  ', model%link_flags         write(*,*)'<INFO> INCLUDE      end if           call check_module_names(model, error)     if (allocated(error)) return           duplicates_found = .false.     call check_modules_for_duplicates(model, duplicates_found)     if (duplicates_found) then         call fpm_stop(1,'*build_model*:Error: One or more duplicate module names found.')     end if end subroutine build_model   subroutine new_compiler_flags(model,settings)     type(fpm_model_t), intent(inout) :: model     type(fpm_build_settings), intent(in) :: settings      character(len=:), allocatable :: flags, cflags, cxxflags, ldflags      if (settings%flag == '') then         flags = model%compiler%get_default_flags(settings%profile == "release")     else         flags = settings%flag         select case(settings%profile)         case("release", "debug")             flags = flags // model%compiler%get_default_flags(settings%profile == "release")         end select     end if      cflags   = trim(settings%cflag)     cxxflags = trim(settings%cxxflag)     ldflags  = trim(settings%ldflag)      model%fortran_compile_flags = flags     model%c_compile_flags       = cflags     model%cxx_compile_flags     = cxxflags     model%link_flags            = ldflags  end subroutine new_compiler_flags   subroutine check_modules_for_duplicates(model, duplicates_found)     type(fpm_model_t), intent(in) :: model     integer :: maxsize     integer :: i,j,k,l,m,modi     type(string_t), allocatable :: modules(:)     logical :: duplicates_found          maxsize = 0          do i=1,size(model%packages)       do j=1,size(model%packages(i)%sources)         if (allocated(model%packages(i)%sources(j)%modules_provided)) then           maxsize = maxsize + size(model%packages(i)%sources(j)%modules_provided)         end if       end do     end do          allocate(modules(maxsize))           modi = 1                     do k=1,size(model%packages)       do l=1,size(model%packages(k)%sources)         if (allocated(model%packages(k)%sources(l)%modules_provided)) then           do m=1,size(model%packages(k)%sources(l)%modules_provided)             if (model%packages(k)%sources(l)%modules_provided(m)%s.in.modules(:modi-1)) then               write(stderr, *) "Warning: Module ",model%packages(k)%sources(l)%modules_provided(m)%s, &                 " in ",model%packages(k)%sources(l)%file_name," is a duplicate"               duplicates_found = .true.             else               modules(modi) = model%packages(k)%sources(l)%modules_provided(m)               modi = modi + 1             end if           end do         end if       end do     end do end subroutine check_modules_for_duplicates   subroutine check_module_names(model, error)     type(fpm_model_t), intent(in) :: model     type(error_t), allocatable, intent(out) :: error     integer :: k,l,m     logical :: valid,errors_found,enforce_this_file     type(string_t) :: package_name,module_name,package_prefix      errors_found = .false.                     do k=1,size(model%packages)          package_name = string_t(model%packages(k)%name)                   if (model%packages(k)%enforce_module_names) then             package_prefix = model%packages(k)%module_prefix         else             package_prefix = string_t("")         end if                   if (model%enforce_module_names .and. .not.model%packages(k)%enforce_module_names) then            write(stderr, *) "Warning:                              " does not enforce module naming, but project does. "         end if          do l=1,size(model%packages(k)%sources)                           enforce_this_file =  model%enforce_module_names .and. &                                  model%packages(k)%sources(l)%unit_scope/=FPM_SCOPE_TEST              if (allocated(model%packages(k)%sources(l)%modules_provided)) then                  do m=1,size(model%packages(k)%sources(l)%modules_provided)                      module_name = model%packages(k)%sources(l)%modules_provided(m)                      valid = is_valid_module_name(module_name, &                                                  package_name, &                                                  package_prefix, &                                                  enforce_this_file)                      if (.not.valid) then                          if (enforce_this_file) then                              if (len_trim(package_prefix)>0) then                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " does not match its package name ("//package_name%s// &                                              ") or custom prefix ("//package_prefix%s//")."                             else                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " does not match its package name ("//package_name%s//")."                              endif                          else                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " has an invalid Fortran name. "                          end if                          errors_found = .true.                      end if                 end do             end if         end do     end do      if (errors_found) then          if (model%enforce_module_names) &             write(stderr, *) "       Hint: Try disabling module naming in the manifest: [build] module-naming=false . "          call fatal_error(error,"The package contains invalid module names. "// &                                "Naming conventions "//merge('are','not',model%enforce_module_names)// &                                " being requested.")     end if  end subroutine check_module_names  subroutine cmd_build(settings) type(fpm_build_settings), intent(inout) :: settings  type(package_config_t) :: package type(fpm_model_t) :: model type(build_target_ptr), allocatable :: targets(:) type(error_t), allocatable :: error  integer :: i  call get_package_data(package, "fpm.toml", error, apply_defaults=.true.) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Package error: '//error%message) end if  call build_model(model, settings, package, error) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Model error: '//error%message) end if  call targets_from_sources(targets, model, settings%prune, error) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Target error: '//error%message) end if  if(settings%list)then     do i=1,size(targets)         write(stderr,*) targets(i)%ptr%output_file     enddo else if (settings%show_model) then     call show_model(model) else     call build_package(targets,model,verbose=settings%verbose) endif  end subroutine cmd_build  subroutine cmd_run(settings,test)     class(fpm_run_settings), intent(inout) :: settings     logical, intent(in) :: test      integer :: i, j, col_width     logical :: found(size(settings%name))     type(error_t), allocatable :: error     type(package_config_t) :: package     type(fpm_model_t) :: model     type(build_target_ptr), allocatable :: targets(:)     type(string_t) :: exe_cmd     type(string_t), allocatable :: executables(:)     type(build_target_t), pointer :: exe_target     type(srcfile_t), pointer :: exe_source     integer :: run_scope,firsterror     integer, allocatable :: stat(:)     character(len=:),allocatable :: line     logical :: toomany      call get_package_data(package, "fpm.toml", error, apply_defaults=.true.)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Package error: '//error%message)     end if      call build_model(model, settings, package, error)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Model error: '//error%message)     end if      call targets_from_sources(targets, model, settings%prune, error)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Targets error: '//error%message)     end if      if (test) then        run_scope = FPM_SCOPE_TEST     else        run_scope = merge(FPM_SCOPE_EXAMPLE, FPM_SCOPE_APP, settings%example)     end if           col_width = -1     found(:) = .false.     allocate(executables(0))     do i=1,size(targets)          exe_target => targets(i)%ptr          if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &              allocated(exe_target%dependencies)) then              exe_source => exe_target%dependencies(1)%ptr%source              if (exe_source%unit_scope == run_scope) then                  col_width = max(col_width,len(basename(exe_target%output_file))+2)                  if (size(settings%name) == 0) then                      exe_cmd%s = exe_target%output_file                     executables = [executables, exe_cmd]                  else                      do j=1,size(settings%name)                          if (glob(trim(exe_source%exe_name),trim(settings%name(j)))) then                              found(j) = .true.                             exe_cmd%s = exe_target%output_file                             executables = [executables, exe_cmd]                          end if                      end do                  end if              end if          end if      end do           if (col_width < 0) then         if (test) then             call fpm_stop(0,'No tests to run')         else             call fpm_stop(0,'No executables to run')         end if     end if                  toomany= size(settings%name)==0 .and. size(executables)>1     if ( any(.not.found) &     & .or. &     & ( (toomany .and. .not.test) .or.  (toomany .and. settings%runner /= '') ) &     & .and. &     & .not.settings%list) then         line=join(settings%name)         if(line/='.')then             if(any(.not.found))then               write(stderr,'(A)',advance="no")'<ERROR>*cmd_run*:specified names '               do j=1,size(settings%name)                   if (.not.found(j)) write(stderr,'(A)',advance="no") '"'//trim(settings%name(j))//'" '               end do               write(stderr,'(A)') 'not found.'               write(stderr,*)            else if(settings%verbose)then               write(stderr,'(A)',advance="yes")'<INFO>when more than one executable is available'               write(stderr,'(A)',advance="yes")'      program names must be specified.'            endif         endif          call compact_list_all()          if(line=='.' .or. line==' ')then             call fpm_stop(0,'')         else            call fpm_stop(1,'')         endif      end if      call build_package(targets,model,verbose=settings%verbose)      if (settings%list) then          call compact_list()     else          allocate(stat(size(executables)))         do i=1,size(executables)             if (exists(executables(i)%s)) then                 if(settings%runner /= ' ')then                     if(.not.allocated(settings%args))then                        call run(settings%runner_command()//' '//executables(i)%s, &                              echo=settings%verbose, exitstat=stat(i))                     else                        call run(settings%runner_command()//' '//executables(i)%s//" "//settings%args, &                              echo=settings%verbose, exitstat=stat(i))                     endif                 else                     if(.not.allocated(settings%args))then                        call run(executables(i)%s,echo=settings%verbose, exitstat=stat(i))                     else                        call run(executables(i)%s//" "//settings%args,echo=settings%verbose, &                              exitstat=stat(i))                     endif                 endif             else                 call fpm_stop(1,'*cmd_run*:'//executables(i)%s//' not found')             end if         end do          if (any(stat /= 0)) then             do i=1,size(stat)                 if (stat(i) /= 0) then                     write(stderr,'(*(g0:,1x))') '<ERROR> Execution for object "',basename(executables(i)%s),&                                                 '" returned exit code ',stat(i)                 end if             end do             firsterror = findloc(stat/=0,value=.true.,dim=1)             call fpm_stop(stat(firsterror),'*cmd_run*:stopping due to failed executions')         end if      end if      contains      subroutine compact_list_all()     integer, parameter :: LINE_WIDTH = 80     integer :: ii, jj, nCol         jj = 1         nCol = LINE_WIDTH/col_width         write(stderr,*) 'Available names:'         do ii=1,size(targets)              exe_target => targets(ii)%ptr              if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &                 allocated(exe_target%dependencies)) then                  exe_source => exe_target%dependencies(1)%ptr%source                  if (exe_source%unit_scope == run_scope) then                     write(stderr,'(A)',advance=(merge("yes","no ",modulo(jj,nCol)==0))) &                         & [character(len=col_width) :: basename(exe_target%output_file, suffix=.false.)]                     jj = jj + 1                 end if             end if         end do         write(stderr,*)     end subroutine compact_list_all      subroutine compact_list()     integer, parameter :: LINE_WIDTH = 80     integer :: ii, jj, nCol         jj = 1         nCol = LINE_WIDTH/col_width         write(stderr,*) 'Matched names:'         do ii=1,size(executables)             write(stderr,'(A)',advance=(merge("yes","no ",modulo(jj,nCol)==0))) &                 & [character(len=col_width) :: basename(executables(ii)%s, suffix=.false.)]             jj = jj + 1         end do         write(stderr,*)     end subroutine compact_list  end subroutine cmd_run  subroutine delete_skip(is_unix)          logical, intent(in) :: is_unix     character(len=:), allocatable :: dir     type(string_t), allocatable :: files(:)     integer :: i     call list_files('build', files, .false.)     do i = 1, size(files)         if (is_dir(files(i)%s)) then             dir = files(i)%s             if (.not.str_ends_with(dir,'dependencies')) call os_delete_dir(is_unix, dir)         end if     end do end subroutine delete_skip   subroutine cmd_clean(settings)          class(fpm_clean_settings), intent(in) :: settings      character :: user_response      if (is_dir('build')) then                  if (settings%clean_call) then             call os_delete_dir(os_is_unix(), 'build'); return         end if                   if (settings%clean_skip) then             call delete_skip(os_is_unix()); return         end if                   write(stdout, '(A)', advance='no') "         read(stdin, '(A1)') user_response         if (lower(user_response) == 'y') call delete_skip(os_is_unix())     else         write (stdout, '(A)') "fpm: No build directory found."     end if end subroutine cmd_clean  end module fpm 
fpm.f90_comments module fpm use fpm_strings, only: string_t, operator(.in.), glob, join, string_cat, &                       lower, str_ends_with, is_fortran_name, str_begins_with_str, &                       is_valid_module_name, len_trim use fpm_backend, only: build_package use fpm_command_line, only: fpm_build_settings, fpm_new_settings, &                       fpm_run_settings, fpm_install_settings, fpm_test_settings, &                       fpm_clean_settings use fpm_dependency, only : new_dependency_tree use fpm_filesystem, only: is_dir, join_path, list_files, exists, &                    basename, filewrite, mkdir, run, os_delete_dir use fpm_model, only: fpm_model_t, srcfile_t, show_model, fortran_features_t, &                     FPM_SCOPE_UNKNOWN, FPM_SCOPE_LIB, FPM_SCOPE_DEP, &                     FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST use fpm_compiler, only: new_compiler, new_archiver, set_cpp_preprocessor_flags   use fpm_sources, only: add_executable_sources, add_sources_from_dir use fpm_targets, only: targets_from_sources, build_target_t, build_target_ptr, &                         FPM_TARGET_EXECUTABLE, FPM_TARGET_ARCHIVE use fpm_manifest, only : get_package_data, package_config_t use fpm_meta, only : resolve_metapackages use fpm_error, only : error_t, fatal_error, fpm_stop use, intrinsic :: iso_fortran_env, only : stdin => input_unit, &                                         & stdout => output_unit, &                                         & stderr => error_unit use iso_c_binding, only: c_char, c_ptr, c_int, c_null_char, c_associated, c_f_pointer use fpm_environment, only: os_is_unix  implicit none private public :: cmd_build, cmd_run, cmd_clean public :: build_model, check_modules_for_duplicates  contains  !> Constructs a valid fpm model from command line settings and the toml manifest. subroutine build_model(model, settings, package, error)     type(fpm_model_t), intent(out) :: model     class(fpm_build_settings), intent(inout) :: settings     type(package_config_t), intent(inout) :: package     type(error_t), allocatable, intent(out) :: error      integer :: i, j     type(package_config_t) :: dependency     character(len=:), allocatable :: manifest, lib_dir     logical :: has_cpp     logical :: duplicates_found     type(string_t) :: include_dir      model%package_name = package%name      allocate(model%include_dirs(0))     allocate(model%link_libraries(0))     allocate(model%external_modules(0))      call new_compiler(model%compiler, settings%compiler, settings%c_compiler, &         & settings%cxx_compiler, echo=settings%verbose, verbose=settings%verbose)     call new_archiver(model%archiver, settings%archiver, &         & echo=settings%verbose, verbose=settings%verbose)      if (model%compiler%is_unknown()) then         write(*, '(*(a:,1x))') &             "<WARN>", "Unknown compiler", model%compiler%fc, "requested!", &             "Defaults for this compiler might be incorrect"     end if      call new_compiler_flags(model,settings)     model%build_prefix = join_path("build", basename(model%compiler%fc))     model%include_tests = settings%build_tests     model%enforce_module_names = package%build%module_naming     model%module_prefix = package%build%module_prefix      ! Resolve meta-dependencies into the package and the model     call resolve_metapackages(model,package,settings,error)     if (allocated(error)) return      ! Create dependencies     call new_dependency_tree(model%deps, cache=join_path("build", "cache.toml"))      ! Build and resolve model dependencies     call model%deps%add(package, error)     if (allocated(error)) return      ! Update dependencies where needed     call model%deps%update(error)     if (allocated(error)) return      ! build/ directory should now exist     if (.not.exists("build/.gitignore")) then       call filewrite(join_path("build", ".gitignore"),["*"])     end if      allocate(model%packages(model%deps%ndep))      has_cpp = .false.     do i = 1, model%deps%ndep         associate(dep => model%deps%dep(i))             manifest = join_path(dep%proj_dir, "fpm.toml")              call get_package_data(dependency, manifest, error, apply_defaults=.true.)             if (allocated(error)) exit              model%packages(i)%name = dependency%name             associate(features => model%packages(i)%features)                 features%implicit_typing = dependency%fortran%implicit_typing                 features%implicit_external = dependency%fortran%implicit_external                 features%source_form = dependency%fortran%source_form             end associate             model%packages(i)%version = package%version%s()              !> Add this dependency's manifest macros             call model%packages(i)%preprocess%destroy()              if (allocated(dependency%preprocess)) then                 do j = 1, size(dependency%preprocess)                     call model%packages(i)%preprocess%add_config(dependency%preprocess(j))                 end do             end if              !> Add this dependency's package-level macros             if (allocated(dep%preprocess)) then                 do j = 1, size(dep%preprocess)                     call model%packages(i)%preprocess%add_config(dep%preprocess(j))                 end do             end if              if (model%packages(i)%preprocess%is_cpp()) has_cpp = .true.              if (.not.allocated(model%packages(i)%sources)) allocate(model%packages(i)%sources(0))              if (allocated(dependency%library)) then                  if (allocated(dependency%library%source_dir)) then                     lib_dir = join_path(dep%proj_dir, dependency%library%source_dir)                     if (is_dir(lib_dir)) then                         call add_sources_from_dir(model%packages(i)%sources, lib_dir, FPM_SCOPE_LIB, &                             with_f_ext=model%packages(i)%preprocess%suffixes, error=error)                         if (allocated(error)) exit                     end if                 end if                  if (allocated(dependency%library%include_dir)) then                     do j=1,size(dependency%library%include_dir)                         include_dir%s = join_path(dep%proj_dir, dependency%library%include_dir(j)%s)                         if (is_dir(include_dir%s)) then                             model%include_dirs = [model%include_dirs, include_dir]                         end if                     end do                 end if              end if              if (allocated(dependency%build%link)) then                 model%link_libraries = [model%link_libraries, dependency%build%link]             end if              if (allocated(dependency%build%external_modules)) then                 model%external_modules = [model%external_modules, dependency%build%external_modules]             end if              ! Copy naming conventions from this dependency's manifest             model%packages(i)%enforce_module_names = dependency%build%module_naming             model%packages(i)%module_prefix        = dependency%build%module_prefix          end associate     end do     if (allocated(error)) return      ! Add optional flags     if (has_cpp) call set_cpp_preprocessor_flags(model%compiler%id, model%fortran_compile_flags)      ! Add sources from executable directories     if (is_dir('app') .and. package%build%auto_executables) then         call add_sources_from_dir(model%packages(1)%sources,'app', FPM_SCOPE_APP, &                                    with_executables=.true., with_f_ext=model%packages(1)%preprocess%suffixes,&                                    error=error)          if (allocated(error)) then             return         end if      end if     if (is_dir('example') .and. package%build%auto_examples) then         call add_sources_from_dir(model%packages(1)%sources,'example', FPM_SCOPE_EXAMPLE, &                                   with_executables=.true., &                                   with_f_ext=model%packages(1)%preprocess%suffixes,error=error)          if (allocated(error)) then             return         end if      end if     if (is_dir('test') .and. package%build%auto_tests) then         call add_sources_from_dir(model%packages(1)%sources,'test', FPM_SCOPE_TEST, &                                   with_executables=.true., &                                   with_f_ext=model%packages(1)%preprocess%suffixes,error=error)          if (allocated(error)) then             return         endif      end if     if (allocated(package%executable)) then         call add_executable_sources(model%packages(1)%sources, package%executable, FPM_SCOPE_APP, &                                      auto_discover=package%build%auto_executables, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         end if      end if     if (allocated(package%example)) then         call add_executable_sources(model%packages(1)%sources, package%example, FPM_SCOPE_EXAMPLE, &                                      auto_discover=package%build%auto_examples, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         end if      end if     if (allocated(package%test)) then         call add_executable_sources(model%packages(1)%sources, package%test, FPM_SCOPE_TEST, &                                      auto_discover=package%build%auto_tests, &                                      with_f_ext=model%packages(1)%preprocess%suffixes, &                                      error=error)          if (allocated(error)) then             return         endif      endif      if (settings%verbose) then         write(*,*)'<INFO> BUILD_NAME: ',model%build_prefix         write(*,*)'<INFO> COMPILER:  ',model%compiler%fc         write(*,*)'<INFO> C COMPILER:  ',model%compiler%cc         write(*,*)'<INFO> CXX COMPILER: ',model%compiler%cxx         write(*,*)'<INFO> COMPILER OPTIONS:  ', model%fortran_compile_flags         write(*,*)'<INFO> C COMPILER OPTIONS:  ', model%c_compile_flags         write(*,*)'<INFO> CXX COMPILER OPTIONS: ', model%cxx_compile_flags         write(*,*)'<INFO> LINKER OPTIONS:  ', model%link_flags         write(*,*)'<INFO> INCLUDE DIRECTORIES:  [', string_cat(model%include_dirs,','),']'     end if      ! Check for invalid module names     call check_module_names(model, error)     if (allocated(error)) return      ! Check for duplicate modules     duplicates_found = .false.     call check_modules_for_duplicates(model, duplicates_found)     if (duplicates_found) then         call fpm_stop(1,'*build_model*:Error: One or more duplicate module names found.')     end if end subroutine build_model  !> Initialize model compiler flags subroutine new_compiler_flags(model,settings)     type(fpm_model_t), intent(inout) :: model     type(fpm_build_settings), intent(in) :: settings      character(len=:), allocatable :: flags, cflags, cxxflags, ldflags      if (settings%flag == '') then         flags = model%compiler%get_default_flags(settings%profile == "release")     else         flags = settings%flag         select case(settings%profile)         case("release", "debug")             flags = flags // model%compiler%get_default_flags(settings%profile == "release")         end select     end if      cflags   = trim(settings%cflag)     cxxflags = trim(settings%cxxflag)     ldflags  = trim(settings%ldflag)      model%fortran_compile_flags = flags     model%c_compile_flags       = cflags     model%cxx_compile_flags     = cxxflags     model%link_flags            = ldflags  end subroutine new_compiler_flags  ! Check for duplicate modules subroutine check_modules_for_duplicates(model, duplicates_found)     type(fpm_model_t), intent(in) :: model     integer :: maxsize     integer :: i,j,k,l,m,modi     type(string_t), allocatable :: modules(:)     logical :: duplicates_found     ! Initialise the size of array     maxsize = 0     ! Get number of modules provided by each source file of every package     do i=1,size(model%packages)       do j=1,size(model%packages(i)%sources)         if (allocated(model%packages(i)%sources(j)%modules_provided)) then           maxsize = maxsize + size(model%packages(i)%sources(j)%modules_provided)         end if       end do     end do     ! Allocate array to contain distinct names of modules     allocate(modules(maxsize))      ! Initialise index to point at start of the newly allocated array     modi = 1      ! Loop through modules provided by each source file of every package     ! Add it to the array if it is not already there     ! Otherwise print out warning about duplicates     do k=1,size(model%packages)       do l=1,size(model%packages(k)%sources)         if (allocated(model%packages(k)%sources(l)%modules_provided)) then           do m=1,size(model%packages(k)%sources(l)%modules_provided)             if (model%packages(k)%sources(l)%modules_provided(m)%s.in.modules(:modi-1)) then               write(stderr, *) "Warning: Module ",model%packages(k)%sources(l)%modules_provided(m)%s, &                 " in ",model%packages(k)%sources(l)%file_name," is a duplicate"               duplicates_found = .true.             else               modules(modi) = model%packages(k)%sources(l)%modules_provided(m)               modi = modi + 1             end if           end do         end if       end do     end do end subroutine check_modules_for_duplicates  ! Check names of all modules in this package and its dependencies subroutine check_module_names(model, error)     type(fpm_model_t), intent(in) :: model     type(error_t), allocatable, intent(out) :: error     integer :: k,l,m     logical :: valid,errors_found,enforce_this_file     type(string_t) :: package_name,module_name,package_prefix      errors_found = .false.      ! Loop through modules provided by each source file of every package     ! Add it to the array if it is not already there     ! Otherwise print out warning about duplicates     do k=1,size(model%packages)          package_name = string_t(model%packages(k)%name)          ! Custom prefix is taken from each dependency's manifest         if (model%packages(k)%enforce_module_names) then             package_prefix = model%packages(k)%module_prefix         else             package_prefix = string_t("")         end if          ! Warn the user if some of the dependencies have loose naming         if (model%enforce_module_names .and. .not.model%packages(k)%enforce_module_names) then            write(stderr, *) "Warning: Dependency ",package_name%s // &                             " does not enforce module naming, but project does. "         end if          do l=1,size(model%packages(k)%sources)              ! Module naming is not enforced in test modules             enforce_this_file =  model%enforce_module_names .and. &                                  model%packages(k)%sources(l)%unit_scope/=FPM_SCOPE_TEST              if (allocated(model%packages(k)%sources(l)%modules_provided)) then                  do m=1,size(model%packages(k)%sources(l)%modules_provided)                      module_name = model%packages(k)%sources(l)%modules_provided(m)                      valid = is_valid_module_name(module_name, &                                                  package_name, &                                                  package_prefix, &                                                  enforce_this_file)                      if (.not.valid) then                          if (enforce_this_file) then                              if (len_trim(package_prefix)>0) then                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " does not match its package name ("//package_name%s// &                                              ") or custom prefix ("//package_prefix%s//")."                             else                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " does not match its package name ("//package_name%s//")."                              endif                          else                              write(stderr, *) "ERROR: Module ",module_name%s, &                                              " in ",model%packages(k)%sources(l)%file_name, &                                              " has an invalid Fortran name. "                          end if                          errors_found = .true.                      end if                 end do             end if         end do     end do      if (errors_found) then          if (model%enforce_module_names) &             write(stderr, *) "       Hint: Try disabling module naming in the manifest: [build] module-naming=false . "          call fatal_error(error,"The package contains invalid module names. "// &                                "Naming conventions "//merge('are','not',model%enforce_module_names)// &                                " being requested.")     end if  end subroutine check_module_names  subroutine cmd_build(settings) type(fpm_build_settings), intent(inout) :: settings  type(package_config_t) :: package type(fpm_model_t) :: model type(build_target_ptr), allocatable :: targets(:) type(error_t), allocatable :: error  integer :: i  call get_package_data(package, "fpm.toml", error, apply_defaults=.true.) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Package error: '//error%message) end if  call build_model(model, settings, package, error) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Model error: '//error%message) end if  call targets_from_sources(targets, model, settings%prune, error) if (allocated(error)) then     call fpm_stop(1,'*cmd_build* Target error: '//error%message) end if  if(settings%list)then     do i=1,size(targets)         write(stderr,*) targets(i)%ptr%output_file     enddo else if (settings%show_model) then     call show_model(model) else     call build_package(targets,model,verbose=settings%verbose) endif  end subroutine cmd_build  subroutine cmd_run(settings,test)     class(fpm_run_settings), intent(inout) :: settings     logical, intent(in) :: test      integer :: i, j, col_width     logical :: found(size(settings%name))     type(error_t), allocatable :: error     type(package_config_t) :: package     type(fpm_model_t) :: model     type(build_target_ptr), allocatable :: targets(:)     type(string_t) :: exe_cmd     type(string_t), allocatable :: executables(:)     type(build_target_t), pointer :: exe_target     type(srcfile_t), pointer :: exe_source     integer :: run_scope,firsterror     integer, allocatable :: stat(:)     character(len=:),allocatable :: line     logical :: toomany      call get_package_data(package, "fpm.toml", error, apply_defaults=.true.)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Package error: '//error%message)     end if      call build_model(model, settings, package, error)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Model error: '//error%message)     end if      call targets_from_sources(targets, model, settings%prune, error)     if (allocated(error)) then         call fpm_stop(1, '*cmd_run* Targets error: '//error%message)     end if      if (test) then        run_scope = FPM_SCOPE_TEST     else        run_scope = merge(FPM_SCOPE_EXAMPLE, FPM_SCOPE_APP, settings%example)     end if      ! Enumerate executable targets to run     col_width = -1     found(:) = .false.     allocate(executables(0))     do i=1,size(targets)          exe_target => targets(i)%ptr          if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &              allocated(exe_target%dependencies)) then              exe_source => exe_target%dependencies(1)%ptr%source              if (exe_source%unit_scope == run_scope) then                  col_width = max(col_width,len(basename(exe_target%output_file))+2)                  if (size(settings%name) == 0) then                      exe_cmd%s = exe_target%output_file                     executables = [executables, exe_cmd]                  else                      do j=1,size(settings%name)                          if (glob(trim(exe_source%exe_name),trim(settings%name(j)))) then                              found(j) = .true.                             exe_cmd%s = exe_target%output_file                             executables = [executables, exe_cmd]                          end if                      end do                  end if              end if          end if      end do      ! Check if any apps/tests were found     if (col_width < 0) then         if (test) then             call fpm_stop(0,'No tests to run')         else             call fpm_stop(0,'No executables to run')         end if     end if        ! Check all names are valid     ! or no name and found more than one file     toomany= size(settings%name)==0 .and. size(executables)>1     if ( any(.not.found) &     & .or. &     & ( (toomany .and. .not.test) .or.  (toomany .and. settings%runner /= '') ) &     & .and. &     & .not.settings%list) then         line=join(settings%name)         if(line/='.')then ! do not report these special strings            if(any(.not.found))then               write(stderr,'(A)',advance="no")'<ERROR>*cmd_run*:specified names '               do j=1,size(settings%name)                   if (.not.found(j)) write(stderr,'(A)',advance="no") '"'//trim(settings%name(j))//'" '               end do               write(stderr,'(A)') 'not found.'               write(stderr,*)            else if(settings%verbose)then               write(stderr,'(A)',advance="yes")'<INFO>when more than one executable is available'               write(stderr,'(A)',advance="yes")'      program names must be specified.'            endif         endif          call compact_list_all()          if(line=='.' .or. line==' ')then ! do not report these special strings            call fpm_stop(0,'')         else            call fpm_stop(1,'')         endif      end if      call build_package(targets,model,verbose=settings%verbose)      if (settings%list) then          call compact_list()     else          allocate(stat(size(executables)))         do i=1,size(executables)             if (exists(executables(i)%s)) then                 if(settings%runner /= ' ')then                     if(.not.allocated(settings%args))then                        call run(settings%runner_command()//' '//executables(i)%s, &                              echo=settings%verbose, exitstat=stat(i))                     else                        call run(settings%runner_command()//' '//executables(i)%s//" "//settings%args, &                              echo=settings%verbose, exitstat=stat(i))                     endif                 else                     if(.not.allocated(settings%args))then                        call run(executables(i)%s,echo=settings%verbose, exitstat=stat(i))                     else                        call run(executables(i)%s//" "//settings%args,echo=settings%verbose, &                              exitstat=stat(i))                     endif                 endif             else                 call fpm_stop(1,'*cmd_run*:'//executables(i)%s//' not found')             end if         end do          if (any(stat /= 0)) then             do i=1,size(stat)                 if (stat(i) /= 0) then                     write(stderr,'(*(g0:,1x))') '<ERROR> Execution for object "',basename(executables(i)%s),&                                                 '" returned exit code ',stat(i)                 end if             end do             firsterror = findloc(stat/=0,value=.true.,dim=1)             call fpm_stop(stat(firsterror),'*cmd_run*:stopping due to failed executions')         end if      end if      contains      subroutine compact_list_all()     integer, parameter :: LINE_WIDTH = 80     integer :: ii, jj, nCol         jj = 1         nCol = LINE_WIDTH/col_width         write(stderr,*) 'Available names:'         do ii=1,size(targets)              exe_target => targets(ii)%ptr              if (exe_target%target_type == FPM_TARGET_EXECUTABLE .and. &                 allocated(exe_target%dependencies)) then                  exe_source => exe_target%dependencies(1)%ptr%source                  if (exe_source%unit_scope == run_scope) then                     write(stderr,'(A)',advance=(merge("yes","no ",modulo(jj,nCol)==0))) &                         & [character(len=col_width) :: basename(exe_target%output_file, suffix=.false.)]                     jj = jj + 1                 end if             end if         end do         write(stderr,*)     end subroutine compact_list_all      subroutine compact_list()     integer, parameter :: LINE_WIDTH = 80     integer :: ii, jj, nCol         jj = 1         nCol = LINE_WIDTH/col_width         write(stderr,*) 'Matched names:'         do ii=1,size(executables)             write(stderr,'(A)',advance=(merge("yes","no ",modulo(jj,nCol)==0))) &                 & [character(len=col_width) :: basename(executables(ii)%s, suffix=.false.)]             jj = jj + 1         end do         write(stderr,*)     end subroutine compact_list  end subroutine cmd_run  subroutine delete_skip(is_unix)     !> delete directories in the build folder, skipping dependencies     logical, intent(in) :: is_unix     character(len=:), allocatable :: dir     type(string_t), allocatable :: files(:)     integer :: i     call list_files('build', files, .false.)     do i = 1, size(files)         if (is_dir(files(i)%s)) then             dir = files(i)%s             if (.not.str_ends_with(dir,'dependencies')) call os_delete_dir(is_unix, dir)         end if     end do end subroutine delete_skip  !> Delete the build directory including or excluding dependencies. subroutine cmd_clean(settings)     !> Settings for the clean command.     class(fpm_clean_settings), intent(in) :: settings      character :: user_response      if (is_dir('build')) then         ! Remove the entire build directory         if (settings%clean_call) then             call os_delete_dir(os_is_unix(), 'build'); return         end if          ! Remove the build directory but skip dependencies         if (settings%clean_skip) then             call delete_skip(os_is_unix()); return         end if          ! Prompt to remove the build directory but skip dependencies         write(stdout, '(A)', advance='no') "Delete build, excluding dependencies (y/n)? "         read(stdin, '(A1)') user_response         if (lower(user_response) == 'y') call delete_skip(os_is_unix())     else         write (stdout, '(A)') "fpm: No build directory found."     end if end subroutine cmd_clean  end module fpm 
fpm_backend_console.f90_stripped           module fpm_backend_console use iso_fortran_env, only: stdout=>output_unit implicit none  private public :: console_t public :: LINE_RESET public ::   character(len=*), parameter :: ESC = char(27)  character(len=*), parameter :: LINE_RESET = ESC//"[2K"//ESC//"[1G"  character(len=*), parameter :: LINE_UP = ESC//"[1A"  character(len=*), parameter :: LINE_DOWN = ESC//"[1B"  character(len=*), parameter ::   character(len=*), parameter ::   character(len=*), parameter ::   character(len=*), parameter ::    type console_t          integer :: n_line = 1  contains          procedure :: write_line => console_write_line          procedure :: update_line => console_update_line end type console_t  contains   subroutine console_write_line(console,str,line,advance)          class(console_t), intent(inout) :: console          character(*), intent(in) :: str          integer, intent(out), optional :: line          logical, intent(in), optional :: advance      character(3) :: adv      adv = "yes"     if (present(advance)) then         if (.not.advance) then             adv = "no"         end if     end if            if (present(line)) then         line = console%n_line     end if          write(stdout,'(A)',advance=trim(adv)) LINE_RESET//str      if (adv=="yes") then         console%n_line = console%n_line + 1     end if        end subroutine console_write_line   subroutine console_update_line(console,line_no,str)          class(console_t), intent(in) :: console          integer, intent(in) :: line_no          character(*), intent(in) :: str      integer :: n            n = console%n_line - line_no           write(stdout,'(A)',advance="no") repeat(LINE_UP,n)//LINE_RESET      write(stdout,'(A)',advance="no") str           write(stdout,'(A)',advance="no") repeat(LINE_DOWN,n)//LINE_RESET        end subroutine console_update_line  end module fpm_backend_console
fpm_backend_console.f90_comments !># Build Backend Console !> This module provides a lightweight implementation for printing to the console !> and updating previously-printed console lines. It used by `[[fpm_backend_output]]` !> for pretty-printing build status and progress. !> !> @note The implementation for updating previous lines relies on no other output !> going to `stdout`/`stderr` except through the `console_t` object provided. !> !> @note All write statements to `stdout` are enclosed within OpenMP `critical` regions !> module fpm_backend_console use iso_fortran_env, only: stdout=>output_unit implicit none  private public :: console_t public :: LINE_RESET public :: COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_RESET  character(len=*), parameter :: ESC = char(27) !> Escape code for erasing current line character(len=*), parameter :: LINE_RESET = ESC//"[2K"//ESC//"[1G" !> Escape code for moving up one line character(len=*), parameter :: LINE_UP = ESC//"[1A" !> Escape code for moving down one line character(len=*), parameter :: LINE_DOWN = ESC//"[1B" !> Escape code for red foreground color character(len=*), parameter :: COLOR_RED = ESC//"[31m" !> Escape code for green foreground color character(len=*), parameter :: COLOR_GREEN = ESC//"[32m" !> Escape code for yellow foreground color character(len=*), parameter :: COLOR_YELLOW = ESC//"[93m" !> Escape code to reset foreground color character(len=*), parameter :: COLOR_RESET = ESC//"[0m"  !> Console object type console_t     !> Number of lines printed     integer :: n_line = 1  contains     !> Write a single line to the console     procedure :: write_line => console_write_line     !> Update a previously-written console line     procedure :: update_line => console_update_line end type console_t  contains  !> Write a single line to the standard output subroutine console_write_line(console,str,line,advance)     !> Console object     class(console_t), intent(inout) :: console     !> String to write     character(*), intent(in) :: str     !> Integer needed to later update console line     integer, intent(out), optional :: line     !> Advancing output (print newline?)     logical, intent(in), optional :: advance      character(3) :: adv      adv = "yes"     if (present(advance)) then         if (.not.advance) then             adv = "no"         end if     end if      !$omp critical      if (present(line)) then         line = console%n_line     end if          write(stdout,'(A)',advance=trim(adv)) LINE_RESET//str      if (adv=="yes") then         console%n_line = console%n_line + 1     end if      !$omp end critical  end subroutine console_write_line  !> Overwrite a previously-written line in standard output subroutine console_update_line(console,line_no,str)     !> Console object     class(console_t), intent(in) :: console     !> Integer output from `[[console_write_line]]`     integer, intent(in) :: line_no     !> New string to overwrite line     character(*), intent(in) :: str      integer :: n      !$omp critical      n = console%n_line - line_no      ! Step back to line     write(stdout,'(A)',advance="no") repeat(LINE_UP,n)//LINE_RESET      write(stdout,'(A)',advance="no") str      ! Step forward to end     write(stdout,'(A)',advance="no") repeat(LINE_DOWN,n)//LINE_RESET      !$omp end critical  end subroutine console_update_line  end module fpm_backend_console
fpm_backend_output.f90_stripped            module fpm_backend_output use iso_fortran_env, only: stdout=>output_unit use fpm_filesystem, only: basename use fpm_targets, only: build_target_ptr use fpm_backend_console, only: console_t, LINE_RESET,  implicit none  private public build_progress_t   type build_progress_t          type(console_t) :: console          integer :: n_complete          integer :: n_target          logical :: plain_mode = .true.          integer, allocatable :: output_lines(:)          type(build_target_ptr), pointer :: target_queue(:) contains          procedure :: compiling_status => output_status_compiling          procedure :: completed_status => output_status_complete          procedure :: success => output_progress_success end type build_progress_t   interface build_progress_t     procedure :: new_build_progress end interface build_progress_t  contains               function new_build_progress(target_queue,plain_mode) result(progress)                  type(build_target_ptr), intent(in), target :: target_queue(:)                  logical, intent(in), optional :: plain_mode                  type(build_progress_t) :: progress          progress%n_target = size(target_queue,1)         progress%target_queue => target_queue         progress%plain_mode = plain_mode         progress%n_complete = 0          allocate(progress%output_lines(progress%n_target))      end function new_build_progress           subroutine output_status_compiling(progress, queue_index)                  class(build_progress_t), intent(inout) :: progress                  integer, intent(in) :: queue_index          character(:), allocatable :: target_name         character(100) :: output_string         character(7) :: overall_progress          associate(target=>progress%target_queue(queue_index)%ptr)              if (allocated(target%source)) then                 target_name = basename(target%source%file_name)             else                 target_name = basename(target%output_file)             end if              write(overall_progress,'(A,I3,A)') '[',100*progress%n_complete/progress%n_target,'%] '              if (progress%plain_mode) then                                    write(*,'(A7,A30)') overall_progress,target_name                               else                   write(output_string,'(A,T40,A,A)') target_name,                   call progress%console%write_line(trim(output_string),progress%output_lines(queue_index))                  call progress%console%write_line(overall_progress//'              end if          end associate      end subroutine output_status_compiling           subroutine output_status_complete(progress, queue_index, build_stat)                  class(build_progress_t), intent(inout) :: progress                  integer, intent(in) :: queue_index                  integer, intent(in) :: build_stat          character(:), allocatable :: target_name         character(100) :: output_string         character(7) :: overall_progress                   progress%n_complete = progress%n_complete + 1                   associate(target=>progress%target_queue(queue_index)%ptr)              if (allocated(target%source)) then                 target_name = basename(target%source%file_name)             else                 target_name = basename(target%output_file)             end if              if (build_stat == 0) then                 write(output_string,'(A,T40,A,A)') target_name,             else                 write(output_string,'(A,T40,A,A)') target_name,             end if              write(overall_progress,'(A,I3,A)') '[',100*progress%n_complete/progress%n_target,'%] '              if (progress%plain_mode) then                                     write(*,'(A7,A30,A7)') overall_progress,target_name, 'done.'                               else                   call progress%console%update_line(progress%output_lines(queue_index),trim(output_string))                  call progress%console%write_line(overall_progress//'              end if          end associate      end subroutine output_status_complete           subroutine output_progress_success(progress)         class(build_progress_t), intent(inout) :: progress          if (progress%plain_mode) then               write(*,'(A)') '[100%] Project compiled successfully.'          else               write(*,'(A)') LINE_RESET//          end if      end subroutine output_progress_success  end module fpm_backend_output
fpm_backend_output.f90_comments !># Build Backend Progress Output !> This module provides a derived type `build_progress_t` for printing build status !> and progress messages to the console while the backend is building the package. !> !> The `build_progress_t` type supports two modes: `normal` and `plain` !> where the former does 'pretty' output and the latter does not. !> The `normal` mode is intended for typical interactive usage whereas !> 'plain' mode is used with the `--verbose` flag or when `stdout` is not attached !> to a terminal (e.g. when piping or redirecting `stdout`). In these cases, !> the pretty output must be suppressed to avoid control codes being output.  module fpm_backend_output use iso_fortran_env, only: stdout=>output_unit use fpm_filesystem, only: basename use fpm_targets, only: build_target_ptr use fpm_backend_console, only: console_t, LINE_RESET, COLOR_RED, COLOR_GREEN, COLOR_YELLOW, COLOR_RESET implicit none  private public build_progress_t  !> Build progress object type build_progress_t     !> Console object for updating console lines     type(console_t) :: console     !> Number of completed targets     integer :: n_complete     !> Total number of targets scheduled     integer :: n_target     !> 'Plain' output (no colors or updating)     logical :: plain_mode = .true.     !> Store needed when updating previous console lines     integer, allocatable :: output_lines(:)     !> Queue of scheduled build targets     type(build_target_ptr), pointer :: target_queue(:) contains     !> Output 'compiling' status for build target     procedure :: compiling_status => output_status_compiling     !> Output 'complete' status for build target     procedure :: completed_status => output_status_complete     !> Output finished status for whole package     procedure :: success => output_progress_success end type build_progress_t  !> Constructor for build_progress_t interface build_progress_t     procedure :: new_build_progress end interface build_progress_t  contains          !> Initialise a new build progress object     function new_build_progress(target_queue,plain_mode) result(progress)         !> The queue of scheduled targets         type(build_target_ptr), intent(in), target :: target_queue(:)         !> Enable 'plain' output for progress object         logical, intent(in), optional :: plain_mode         !> Progress object to initialise         type(build_progress_t) :: progress          progress%n_target = size(target_queue,1)         progress%target_queue => target_queue         progress%plain_mode = plain_mode         progress%n_complete = 0          allocate(progress%output_lines(progress%n_target))      end function new_build_progress      !> Output 'compiling' status for build target and overall percentage progress     subroutine output_status_compiling(progress, queue_index)         !> Progress object         class(build_progress_t), intent(inout) :: progress         !> Index of build target in the target queue         integer, intent(in) :: queue_index          character(:), allocatable :: target_name         character(100) :: output_string         character(7) :: overall_progress          associate(target=>progress%target_queue(queue_index)%ptr)              if (allocated(target%source)) then                 target_name = basename(target%source%file_name)             else                 target_name = basename(target%output_file)             end if              write(overall_progress,'(A,I3,A)') '[',100*progress%n_complete/progress%n_target,'%] '              if (progress%plain_mode) then ! Plain output                  !$omp critical                 write(*,'(A7,A30)') overall_progress,target_name                 !$omp end critical              else ! Pretty output                  write(output_string,'(A,T40,A,A)') target_name, COLOR_YELLOW//'compiling...'//COLOR_RESET                  call progress%console%write_line(trim(output_string),progress%output_lines(queue_index))                  call progress%console%write_line(overall_progress//'Compiling...',advance=.false.)              end if          end associate      end subroutine output_status_compiling      !> Output 'complete' status for build target and update overall percentage progress     subroutine output_status_complete(progress, queue_index, build_stat)         !> Progress object         class(build_progress_t), intent(inout) :: progress         !> Index of build target in the target queue         integer, intent(in) :: queue_index         !> Build status flag         integer, intent(in) :: build_stat          character(:), allocatable :: target_name         character(100) :: output_string         character(7) :: overall_progress          !$omp critical          progress%n_complete = progress%n_complete + 1         !$omp end critical          associate(target=>progress%target_queue(queue_index)%ptr)              if (allocated(target%source)) then                 target_name = basename(target%source%file_name)             else                 target_name = basename(target%output_file)             end if              if (build_stat == 0) then                 write(output_string,'(A,T40,A,A)') target_name,COLOR_GREEN//'done.'//COLOR_RESET             else                 write(output_string,'(A,T40,A,A)') target_name,COLOR_RED//'failed.'//COLOR_RESET             end if              write(overall_progress,'(A,I3,A)') '[',100*progress%n_complete/progress%n_target,'%] '              if (progress%plain_mode) then  ! Plain output                  !$omp critical                 write(*,'(A7,A30,A7)') overall_progress,target_name, 'done.'                 !$omp end critical              else ! Pretty output                  call progress%console%update_line(progress%output_lines(queue_index),trim(output_string))                  call progress%console%write_line(overall_progress//'Compiling...',advance=.false.)              end if          end associate      end subroutine output_status_complete      !> Output finished status for whole package     subroutine output_progress_success(progress)         class(build_progress_t), intent(inout) :: progress          if (progress%plain_mode) then ! Plain output              write(*,'(A)') '[100%] Project compiled successfully.'          else ! Pretty output              write(*,'(A)') LINE_RESET//COLOR_GREEN//'[100%] Project compiled successfully.'//COLOR_RESET          end if      end subroutine output_progress_success  end module fpm_backend_output
fpm_command_line.f90_stripped                         module fpm_command_line use fpm_environment,  only : get_os_type, get_env, &                              OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, &                              OS_CYGWIN, OS_SOLARIS, OS_FREEBSD, OS_OPENBSD use M_CLI2,           only : set_args, lget, sget, unnamed, remaining, specified use M_CLI2,           only : get_subcommand,  use fpm_strings,      only : lower, split, to_fortran_name, is_fortran_name, remove_characters_in_set, string_t use fpm_filesystem,   only : basename, canon_path, which, run use fpm_environment,  only : get_command_arguments_quoted use fpm_error,        only : fpm_stop, error_t use fpm_os,           only : get_current_directory use fpm_release,      only : fpm_version, version_t use,intrinsic :: iso_fortran_env, only : stdin=>input_unit, &                                        & stdout=>output_unit, &                                        & stderr=>error_unit  implicit none  private public :: fpm_cmd_settings, &           fpm_build_settings, &           fpm_install_settings, &           fpm_new_settings, &           fpm_run_settings, &           fpm_test_settings, &           fpm_update_settings, &           fpm_clean_settings, &           fpm_publish_settings, &           get_command_line_settings  type, abstract :: fpm_cmd_settings     character(len=:), allocatable :: working_dir     logical                       :: verbose=.true. end type  integer,parameter :: ibug=4096  type, extends(fpm_cmd_settings)  :: fpm_new_settings     character(len=:),allocatable :: name     logical                      :: with_executable=.false.     logical                      :: with_test=.false.     logical                      :: with_lib=.true.     logical                      :: with_example=.false.     logical                      :: with_full=.false.     logical                      :: with_bare=.false.     logical                      :: backfill=.true. end type  type, extends(fpm_cmd_settings)  :: fpm_build_settings     logical                      :: list=.false.     logical                      :: show_model=.false.     logical                      :: build_tests=.false.     logical                      :: prune=.true.     character(len=:),allocatable :: compiler     character(len=:),allocatable :: c_compiler     character(len=:),allocatable :: cxx_compiler     character(len=:),allocatable :: archiver     character(len=:),allocatable :: profile     character(len=:),allocatable :: flag     character(len=:),allocatable :: cflag     character(len=:),allocatable :: cxxflag     character(len=:),allocatable :: ldflag end type  type, extends(fpm_build_settings)  :: fpm_run_settings     character(len=ibug),allocatable :: name(:)     character(len=:),allocatable :: args      character(len=:),allocatable :: runner     character(len=:),allocatable :: runner_args      logical :: example     contains        procedure :: runner_command end type  type, extends(fpm_run_settings)  :: fpm_test_settings end type  type, extends(fpm_build_settings) :: fpm_install_settings     character(len=:), allocatable :: prefix     character(len=:), allocatable :: bindir     character(len=:), allocatable :: libdir     character(len=:), allocatable :: includedir     logical :: no_rebuild end type   type, extends(fpm_cmd_settings)  :: fpm_update_settings     character(len=ibug),allocatable :: name(:)     logical :: fetch_only     logical :: clean end type  type, extends(fpm_cmd_settings)   :: fpm_clean_settings     logical                       :: clean_skip = .false.     logical                       :: clean_call = .false. end type  type, extends(fpm_build_settings) :: fpm_publish_settings     logical :: show_package_version = .false.     logical :: show_upload_data = .false.     logical :: is_dry_run = .false.     character(len=:), allocatable :: token end type  character(len=:),allocatable :: name character(len=:),allocatable :: os_type character(len=ibug),allocatable :: names(:) character(len=:),allocatable :: tnames(:)  character(len=:), allocatable :: version_text(:) character(len=:), allocatable :: help_new(:), help_fpm(:), help_run(:), &                  & help_test(:), help_build(:), help_usage(:), help_runner(:), &                  & help_text(:), help_install(:), help_help(:), help_update(:), &                  & help_list(:), help_list_dash(:), help_list_nodash(:), &                  & help_clean(:), help_publish(:) character(len=20),parameter :: manual(*)=[ character(len=20) ::& &  ' ',     'fpm',    'new',     'build',  'run',    'clean',  & &  'test',  'runner', 'install', 'update', 'list',   'help',   'version', 'publish' ]  character(len=:), allocatable :: val_runner, val_compiler, val_flag, val_cflag, val_cxxflag, val_ldflag, &     val_profile, val_runner_args   character(len=80), parameter :: help_text_build_common(*) = [character(len=80) ::      &     ' --profile PROF    Selects the compilation profile for the build.               ',&     '                        '                   high optimization and "debug" for full debug options.        ',&     '                   If --flag is not specified the "debug" flags are the         ',&     '                   default.                                                     ',&     ' --no-prune             ]  character(len=80), parameter :: help_text_compiler(*) = [character(len=80) :: &     ' --compiler NAME    Specify a compiler name. The default is "gfortran"          ',&     '                    unless set by the environment variable FPM_FC.              ',&     ' --c-compiler NAME  Specify the      '                    default unless set by the environment variable FPM_CC.      ',&     ' --cxx-compiler NAME  Specify the      '                    default unless set by the environment variable FPM_CXX.     ',&     ' --archiver NAME    Specify the archiver name. Automatically determined by      ',&     '                    default unless set by the environment variable FPM_AR.      '&     ]   character(len=80), parameter :: help_text_flag(*) = [character(len=80) :: &     ' --flag  FFLAGS    selects compile arguments for the build, the default value is',&     '                   set by the FPM_FFLAGS environment variable. These are added  ',&     '                   to the profile options if --profile is specified, else these ',&     '                   options override the defaults. Note object and .mod          ',&     '                   directory locations are always built in.                     ',&     ' --c-flag      '                   The default value is set by the FPM_CFLAGS environment       ',&     '                   variable.                                                    ',&     ' --cxx-flag      '                   build. The default value is set by the FPM_CXXFLAGS          ',&     '                   environment variable.                                        ',&     ' --link-flag LDFLAGS  select arguments passed to the linker for the build. The  ',&     '                   default value is set by the FPM_LDFLAGS environment variable.'&     ]   character(len=80), parameter :: help_text_environment(*) = [character(len=80) :: &     'ENVIRONMENT VARIABLES',&     ' FPM_FC            sets the path to the Fortran compiler used for the build,', &     '                   will be overwritten by --compiler command line option', &     '', &     ' FPM_FFLAGS        sets the arguments for the Fortran compiler', &     '                   will be overwritten by --flag command line option', &     '', &     ' FPM_CC            sets the path to the      '                   will be overwritten by --c-compiler command line option', &     '', &     ' FPM_CFLAGS        sets the arguments for the      '                   will be overwritten by --c-flag command line option', &     '', &     ' FPM_CXX           sets the path to the      '                   will be overwritten by --cxx-compiler command line option', &     '', &     ' FPM_CXXFLAGS      sets the arguments for the      '                   will be overwritten by --cxx-flag command line option', &     '', &     ' FPM_AR            sets the path to the archiver used for the build,', &     '                   will be overwritten by --archiver command line option', &     '', &     ' FPM_LDFLAGS       sets additional link arguments for creating executables', &     '                   will be overwritten by --link-flag command line option' &     ]  contains     subroutine get_command_line_settings(cmd_settings)         class(fpm_cmd_settings), allocatable, intent(out) :: cmd_settings          integer, parameter            :: widest = 256         character(len=4096)           :: cmdarg         integer                       :: i         integer                       :: os         type(fpm_install_settings), allocatable :: install_settings         type(version_t) :: version         character(len=:), allocatable :: common_args, compiler_args, run_args, working_dir, &             & c_compiler, cxx_compiler, archiver, version_s, token_s          character(len=*), parameter :: fc_env = "FC", cc_env = "             & fflags_env = "FFLAGS", cflags_env = "             & fc_default = "gfortran", cc_default = " ", ar_default = " ", flags_default = " ", &             & cxx_env = "         type(error_t), allocatable :: error          call set_help()         os = get_os_type()                  select case (os)             case (OS_LINUX);   os_type =  "OS Type:     Linux"             case (OS_MACOS);   os_type =  "OS Type:     macOS"             case (OS_WINDOWS); os_type =  "OS Type:     Windows"             case (OS_CYGWIN);  os_type =  "OS Type:                  case (OS_SOLARIS); os_type =  "OS Type:     Solaris"             case (OS_FREEBSD); os_type =  "OS Type:     FreeBSD"             case (OS_OPENBSD); os_type =  "OS Type:     OpenBSD"             case (OS_UNKNOWN); os_type =  "OS Type:     Unknown"             case default     ; os_type =  "OS Type:     UNKNOWN"         end select                   version = fpm_version()         version_s = version%s()          version_text = [character(len=80) :: &          &  'Version:     '//trim(version_s)//', alpha',               &          &  'Program:     fpm(1)',                                     &          &  '          &  'Home Page:   https://github.com/fortran-lang/fpm',        &          &  'License:     MIT',                                        &          &  os_type]                                    cmdarg = get_subcommand()          common_args = &           ' --directory:           ' --verbose F'          run_args = &           ' --target " "' // &           ' --list F' // &           ' --runner " "' // &           ' --runner-args " "'          compiler_args = &           ' --profile " "' // &           ' --no-prune F' // &           ' --compiler "'//get_fpm_env(fc_env, fc_default)//'"' // &           ' --c-compiler "'//get_fpm_env(cc_env, cc_default)//'"' // &           ' --cxx-compiler "'//get_fpm_env(cxx_env, cxx_default)//'"' // &           ' --archiver "'//get_fpm_env(ar_env, ar_default)//'"' // &           ' --flag:: "'//get_fpm_env(fflags_env, flags_default)//'"' // &           ' --c-flag:: "'//get_fpm_env(cflags_env, flags_default)//'"' // &           ' --cxx-flag:: "'//get_fpm_env(cxxflags_env, flags_default)//'"' // &           ' --link-flag:: "'//get_fpm_env(ldflags_env, flags_default)//'"'                            select case(trim(cmdarg))          case('run')             call set_args(common_args // compiler_args // run_args //'&             & --all F &             & --example F&             & --',help_run,version_text)              call check_build_vals()              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif               if(specified('target') )then                call split(sget('target'),tnames,delimiters=' ,:')                names=[character(len=max(len(names),len(tnames))) :: names,tnames]             endif                           if(lget('all'))then                names=[character(len=max(len(names),1)) :: names,'*' ]             endif                                        do i=1,size(names)                if(names(i)=='..')names(i)='*'             enddo                                        val_runner_args=sget('runner-args')             call remove_characters_in_set(val_runner_args,set='"')              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(fpm_run_settings :: cmd_settings)             val_runner=sget('runner')             if(specified('runner') .and. val_runner=='')val_runner='echo'              cmd_settings=fpm_run_settings(&             & args=remaining,&             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & example=lget('example'), &             & list=lget('list'),&             & build_tests=.false.,&             & name=names,&             & runner=val_runner,&             & runner_args=val_runner_args, &             & verbose=lget('verbose') )          case('build')             call set_args(common_args // compiler_args //'&             & --list F &             & --show-model F &             & --tests F &             & --',help_build,version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate( fpm_build_settings :: cmd_settings )             cmd_settings=fpm_build_settings(  &             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & list=lget('list'),&             & show_model=lget('show-model'),&             & build_tests=lget('tests'),&             & verbose=lget('verbose') )          case('new')             call set_args(common_args // '&             & --src F &             & --lib F &             & --app F &             & --test F &             & --example F &             & --backfill F &             & --full F &             & --bare F', &             & help_new, version_text)             select case(size(unnamed))             case(1)                 if(lget('backfill'))then                    name='.'                 else                    write(stderr,'(*(7x,g0,/))') &                    & '<USAGE> fpm new NAME [[--lib|--src] [--app] [--test] [--example]]|[--full|--bare] [--backfill]'                    call fpm_stop(1,'directory name required')                 endif             case(2)                 name=trim(unnamed(2))             case default                 write(stderr,'(7x,g0)') &                 & '<USAGE> fpm new NAME [[--lib|--src] [--app] [--test] [--example]]| [--full|--bare] [--backfill]'                 call fpm_stop(2,'only one directory name allowed')             end select                          if(name=='.')then                call get_current_directory(name, error)                if (allocated(error)) then                   write(stderr, '("[Error]", 1x, a)') error%message                   stop 1                endif             endif             name=canon_path(name)             if( .not.is_fortran_name(to_fortran_name(basename(name))) )then                 write(stderr,'(g0)') [ character(len=72) :: &                 & '<ERROR> the fpm project name must be made of up to 63 ASCII letters,', &                 & '        numbers, underscores, or hyphens, and start with a letter.']                 call fpm_stop(4,' ')             endif               allocate(fpm_new_settings :: cmd_settings)             if (any( specified([character(len=10) :: 'src','lib','app','test','example','bare'])) &             & .and.lget('full') )then                 write(stderr,'(*(a))')&                 &'<ERROR> --full and any of [--src|--lib,--app,--test,--example,--bare]', &                 &'        are mutually exclusive.'                 call fpm_stop(5,' ')             elseif (any( specified([character(len=10) :: 'src','lib','app','test','example','full'])) &             & .and.lget('bare') )then                 write(stderr,'(*(a))')&                 &'<ERROR> --bare and any of [--src|--lib,--app,--test,--example,--full]', &                 &'        are mutually exclusive.'                 call fpm_stop(3,' ')             elseif (any( specified([character(len=10) :: 'src','lib','app','test','example']) ) )then                 cmd_settings=fpm_new_settings(&                  & backfill=lget('backfill'),               &                  & name=name,                               &                  & with_executable=lget('app'),             &                  & with_lib=any([lget('lib'),lget('src')]), &                  & with_test=lget('test'),                  &                  & with_example=lget('example'),            &                  & verbose=lget('verbose') )             else                   cmd_settings=fpm_new_settings(&                  & backfill=lget('backfill') ,           &                  & name=name,                            &                  & with_executable=.true.,               &                  & with_lib=.true.,                      &                  & with_test=.true.,                     &                  & with_example=lget('full'),            &                  & with_full=lget('full'),               &                  & with_bare=lget('bare'),               &                  & verbose=lget('verbose') )             endif          case('help','manual')             call set_args(common_args, help_help,version_text)             if(size(unnamed)<2)then                 if(unnamed(1)=='help')then                    unnamed=['   ', 'fpm']                 else                    unnamed=manual                 endif             elseif(unnamed(2)=='manual')then                 unnamed=manual             endif             allocate(character(len=widest) :: help_text(0))             do i=2,size(unnamed)                 select case(unnamed(i))                 case('       ' )                 case('fpm    ' )                    help_text=[character(len=widest) :: help_text, help_fpm]                 case('new    ' )                    help_text=[character(len=widest) :: help_text, help_new]                 case('build  ' )                    help_text=[character(len=widest) :: help_text, help_build]                 case('install' )                    help_text=[character(len=widest) :: help_text, help_install]                 case('run    ' )                    help_text=[character(len=widest) :: help_text, help_run]                 case('test   ' )                    help_text=[character(len=widest) :: help_text, help_test]                 case('runner' )                    help_text=[character(len=widest) :: help_text, help_runner]                 case('list   ' )                    help_text=[character(len=widest) :: help_text, help_list]                 case('update ' )                    help_text=[character(len=widest) :: help_text, help_update]                 case('help   ' )                    help_text=[character(len=widest) :: help_text, help_help]                 case('version' )                    help_text=[character(len=widest) :: help_text, version_text]                 case('clean' )                    help_text=[character(len=widest) :: help_text, help_clean]                 case('publish')                    help_text=[character(len=widest) :: help_text, help_publish]                 case default                    help_text=[character(len=widest) :: help_text, &                    & '<ERROR> unknown help topic "'//trim(unnamed(i))//'"']                                     end select             enddo             call printhelp(help_text)          case('install')             call set_args(common_args // compiler_args // '&                 & --no-rebuild F --prefix " " &                 & --list F &                 & --libdir "lib" --bindir "bin" --includedir "include"', &                 help_install, version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(install_settings, source=fpm_install_settings(&                 list=lget('list'), &                 profile=val_profile,&                 prune=.not.lget('no-prune'), &                 compiler=val_compiler, &                 c_compiler=c_compiler, &                 cxx_compiler=cxx_compiler, &                 archiver=archiver, &                 flag=val_flag, &                 cflag=val_cflag, &                 cxxflag=val_cxxflag, &                 ldflag=val_ldflag, &                 no_rebuild=lget('no-rebuild'), &                 verbose=lget('verbose')))             call get_char_arg(install_settings%prefix, 'prefix')             call get_char_arg(install_settings%libdir, 'libdir')             call get_char_arg(install_settings%bindir, 'bindir')             call get_char_arg(install_settings%includedir, 'includedir')             call move_alloc(install_settings, cmd_settings)          case('list')             call set_args(common_args // '&             & --list F&             &', help_list, version_text)             if(lget('list'))then                 help_text = [character(widest) :: help_list_nodash, help_list_dash]             else                 help_text = help_list_nodash             endif             call printhelp(help_text)          case('test')             call set_args(common_args // compiler_args // run_args // ' --', &               help_test,version_text)              call check_build_vals()              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif              if(specified('target') )then                call split(sget('target'),tnames,delimiters=' ,:')                names=[character(len=max(len(names),len(tnames))) :: names,tnames]             endif                                        do i=1,size(names)                if(names(i)=='..')names(i)='*'             enddo                                        val_runner_args=sget('runner-args')             call remove_characters_in_set(val_runner_args,set='"')              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(fpm_test_settings :: cmd_settings)             val_runner=sget('runner')             if(specified('runner') .and. val_runner=='')val_runner='echo'              cmd_settings=fpm_test_settings(&             & args=remaining, &             & profile=val_profile, &             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & example=.false., &             & list=lget('list'), &             & build_tests=.true., &             & name=names, &             & runner=val_runner, &             & runner_args=val_runner_args, &             & verbose=lget('verbose'))          case('update')             call set_args(common_args // ' --fetch-only F --clean F', &                 help_update, version_text)              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif              allocate(fpm_update_settings :: cmd_settings)             cmd_settings=fpm_update_settings(name=names, &                 fetch_only=lget('fetch-only'), verbose=lget('verbose'), &                 clean=lget('clean'))          case('clean')             call set_args(common_args // &             &   ' --skip'             // &             &   ' --all',                &                 help_clean, version_text)             allocate(fpm_clean_settings :: cmd_settings)             call get_current_directory(working_dir, error)             cmd_settings=fpm_clean_settings( &             &   clean_skip=lget('skip'),     &             &   clean_call=lget('all'))          case('publish')             call set_args(common_args // compiler_args //'&             & --show-package-version F &             & --show-upload-data F &             & --dry-run F &             & --token " " &             & --list F &             & --show-model F &             & --tests F &             & --', help_publish, version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             token_s = sget('token')              allocate(fpm_publish_settings :: cmd_settings)             cmd_settings = fpm_publish_settings( &             & show_package_version = lget('show-package-version'), &             & show_upload_data = lget('show-upload-data'), &             & is_dry_run = lget('dry-run'), &             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & list=lget('list'),&             & show_model=lget('show-model'),&             & build_tests=lget('tests'),&             & verbose=lget('verbose'),&             & token=token_s)          case default              if(cmdarg.ne.''.and.which('fpm-'//cmdarg).ne.'')then                 call run('fpm-'//trim(cmdarg)//' '// get_command_arguments_quoted(),.false.)                 stop             else                 call set_args('&                 & --list F&                 &', help_fpm, version_text)                                                   if(lget('list'))then                     help_text = help_list_dash                 elseif(len_trim(cmdarg)==0)then                     write(stdout,'(*(a))')'Fortran Package Manager:'                     write(stdout,'(*(a))')' '                     help_text = [character(widest) :: help_list_nodash, help_usage]                 else                     write(stderr,'(*(a))')'<ERROR> unknown subcommand [', &                      & trim(cmdarg), ']'                     help_text = [character(widest) :: help_list_dash, help_usage]                 endif                 call printhelp(help_text)             endif          end select          if (allocated(cmd_settings)) then             working_dir = sget("directory")             call move_alloc(working_dir, cmd_settings%working_dir)         end if      contains      subroutine check_build_vals()         val_compiler=sget('compiler')         if(val_compiler=='') val_compiler='gfortran'          val_flag = " " // sget('flag')         val_cflag = " " // sget('c-flag')         val_cxxflag = " "// sget('cxx-flag')         val_ldflag = " " // sget('link-flag')         val_profile = sget('profile')      end subroutine check_build_vals           subroutine printhelp(lines)     character(len=:),intent(in),allocatable :: lines(:)     integer :: iii,ii         if(allocated(lines))then            ii=size(lines)            if(ii > 0 .and. len(lines)> 0) then                write(stdout,'(g0)')(trim(lines(iii)), iii=1, ii)            else                write(stdout,'(a)')'<WARNING> *printhelp* output requested is empty'            endif         endif         stop     end subroutine printhelp      end subroutine get_command_line_settings      subroutine set_help()    help_list_nodash=[character(len=80) :: &    'USAGE: fpm [ SUBCOMMAND [SUBCOMMAND_OPTIONS] ]|[--list|--help|--version]', &    '       where SUBCOMMAND is commonly new|build|run|test                  ', &    '                                                                        ', &    ' subcommand may be one of                                               ', &    '                                                                        ', &    '  build         '  help          '  list          '  new           '  run       Run the local package application programs                  ', &    '  test      Run the test programs                                       ', &    '  update    Update and manage project dependencies                      ', &    '  install   Install project                                             ', &    '  clean         '  publish   Publish package to the registry                             ', &    '                                                                        ', &    ' Enter "fpm --list" for a brief list of subcommand options. Enter       ', &    ' "fpm --help" or "fpm SUBCOMMAND --help" for detailed descriptions.     ', &    ' ']    help_list_dash = [character(len=80) :: &    '                                                                                ', &    ' build [--compiler     '       [--tests] [--no-prune]                                                   ', &    ' help [NAME(s)]                                                                 ', &    ' new NAME [[--lib|--src] [--app] [--test] [--example]]|                         ', &    '          [--full|--bare][--backfill]                                           ', &    ' update [NAME(s)] [--fetch-only] [--clean] [--verbose]                          ', &    ' list [--list]                                                                  ', &    ' run  [[--target] NAME(s) [--example] [--profile PROF] [--flag FFLAGS] [--all]  ', &    '      [--runner "    ' test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--runner "    '      [--list] [--compiler     ' install [--profile PROF] [--flag FFLAGS] [--no-rebuild] [--prefix PATH]        ', &    '         [options]                                                              ', &    ' clean [--skip] [--all]                                                         ', &    ' publish [--token TOKEN] [--show-package-version] [--show-upload-data]          ', &    '         [--dry-run] [--verbose]                                                ', &    ' ']     help_usage=[character(len=80) :: &     '' ]     help_runner=[character(len=80) :: &    'NAME                                                                            ', &    '   --runner(1) - a shared option for specifying an application to launch        ', &    '                 executables.                                                   ', &    '                                                                                ', &    'SYNOPSIS                                                                        ', &    '   fpm run|test --runner     '                                                                                ', &    '    '   The --runner option allows specifying a program to launch                    ', &    '   executables selected via the fpm(1) subcommands "run" and "test". This       ', &    '   gives easy recourse to utilities such as debuggers and other tools           ', &    '   that wrap other executables.                                                 ', &    '                                                                                ', &    '   These external commands are not part of fpm(1) itself as they vary           ', &    '   from platform to platform or require independent installation.               ', &    '                                                                                ', &    'OPTION                                                                          ', &    ' --runner ''    '               Available for both the "run" and "test" subcommands.             ', &    '               If the keyword is specified without a value the default command  ', &    '               is "echo".                                                       ', &    ' --runner-args "args"    an additional option to pass command-line arguments    ', &    '               to the runner command, instead of to the fpm app.                ', &    ' -- SUFFIX_OPTIONS  additional options to suffix the command     '                    file names with. These options are passed as command-line   ', &    '                    arguments to the app.                                       ', &    'EXAMPLES                                                                        ', &    '   Use cases for ''fpm run|test --runner "    '   the following common GNU/Linux and Unix commands:                            ', &    '                                                                                ', &    ' INTERROGATE                                                                    ', &    '    + nm - list symbols from object files                                       ', &    '    + size - list section sizes and total size.                                 ', &    '    + ldd - print shared object dependencies                                    ', &    '    + ls - list directory contents                                              ', &    '    + stat - display file or file system status                                 ', &    '    + file - determine file type                                                ', &    ' PERFORMANCE AND     '    + gdb - The GNU     '    + valgrind - a suite of tools for debugging and profiling                   ', &    '    + time - time a simple command or give resource usage                       ', &    '    + timeout - run a command with a time limit                                 ', &    '     '    + install - copy files and set attributes                                   ', &    '    + tar - an archiving utility                                                ', &    ' ALTER                                                                          ', &    '    + rm - remove files or directories                                          ', &    '    + chmod - change permissions of a file                                      ', &    '    + strip - remove unnecessary information from strippable files              ', &    '                                                                                ', &    ' For example                                                                    ', &    '                                                                                ', &    '  fpm test --runner gdb                                                         ', &    '  fpm run --runner "tar cvfz $HOME/bundle.tgz"                                  ', &    '  fpm run --runner "mpiexec" --runner-args "-np 12"                             ', &    '  fpm run --runner ldd                                                          ', &    '  fpm run --runner strip                                                        ', &    '  fpm run --runner ''cp -t /usr/local/bin''                                       ', &    '                                                                                ', &    '  # options after executable name can be specified after the -- option          ', &    '  fpm --runner cp run -- /usr/local/bin/                                        ', &    '  # generates commands of the form "cp $FILENAME /usr/local/bin/"               ', &    '                                                                                ', &    '  # bash(1) alias example:                                                      ', &    '  alias fpm-install=\                                                           ', &    '  "fpm run --profile release --runner ''install -vbp -m 0711 -t ~/.local/bin''" ', &    '  fpm-install                                                           ', &     '' ]     help_fpm=[character(len=80) :: &     'NAME                                                                   ', &     '   fpm(1) - A Fortran package manager and build system                 ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     '   fpm SUBCOMMAND [SUBCOMMAND_OPTIONS]                                 ', &     '                                                                       ', &     '   fpm --help|--version|--list                                         ', &     '                                                                       ', &     '     '   fpm(1) is a package manager that helps you create Fortran projects  ', &     '   from source -- it automatically determines dependencies     '                                                                       ', &     '   Most significantly fpm(1) lets you draw upon other fpm(1) packages  ', &     '   in distributed git(1) repositories as if the packages were a basic  ', &     '   part of your default programming environment, as well as letting    ', &     '   you share your projects with others in a similar manner.            ', &     '                                                                       ', &     '   All output goes into the directory "build/" which can generally be  ', &     '   removed and rebuilt if required. Note that if external packages are ', &     '   being used you need network connectivity to rebuild from scratch.   ', &     '                                                                       ', &     'SUBCOMMANDS                                                            ', &     '  Valid fpm(1) subcommands are:                                        ', &     '                                                                       ', &     '  + build         '  + new           '  + update   Update the project dependencies.                          ', &     '  + run      Run the local package binaries.      '             for that release.                                         ', &     '  + test     Run the tests.                                            ', &     '  + help     Alternate to the --help switch for displaying help text.  ', &     '  + list          '  + install  Install project.                                          ', &     '  + clean         '             dependencies. Prompts for confirmation to delete.         ', &     '  + publish  Publish package to the registry.                          ', &     '                                                                       ', &     '  Their syntax is                                                      ', &     '                                                                                ', &     '    build [--profile PROF] [--flag FFLAGS] [--list] [--compiler      '          [--tests] [--no-prune]                                                ', &     '    new NAME [[--lib|--src] [--app] [--test] [--example]]|                      ', &     '             [--full|--bare][--backfill]                                        ', &     '    update [NAME(s)] [--fetch-only] [--clean]                                   ', &     '    run [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--list] [--all]  ', &     '        [--example] [--runner "     '        [--no-prune] [-- ARGS]                                                  ', &     '    test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--list]         ', &     '         [--runner "     '    help [NAME(s)]                                                              ', &     '    list [--list]                                                               ', &     '    install [--profile PROF] [--flag FFLAGS] [--no-rebuild] [--prefix PATH]     ', &     '            [options]                                                           ', &     '    clean [--skip] [--all]                                                      ', &     '    publish [--token TOKEN] [--show-package-version] [--show-upload-data]       ', &     '            [--dry-run] [--verbose]                                             ', &     '                                                                                ', &     'SUBCOMMAND OPTIONS                                                              ', &     ' -     '                  help_text_build_common, &     help_text_compiler, &     help_text_flag, &     '  --list     List candidates instead of building or running them. On   ', &     '             the fpm(1) command this shows a brief list of subcommands.', &     '  --runner      '  -- ARGS    Arguments to pass to executables.                         ', &     '  --skip          '             prompting, but skip dependencies.                         ', &     '  --all           '             prompting, including dependencies.                        ', &     '                                                                       ', &     'VALID FOR ALL SUBCOMMANDS                                              ', &     '  --help     Show help text and exit                                   ', &     '  --verbose       '  --version  Show version information and exit.                        ', &     '                                                                       ', &     '@file                                                                  ', &     '   You may replace the default options for the fpm(1) command from a   ', &     '   file if your first options begin with @file. Initial options will   ', &     '   then be read from the "response file" "file.rsp" in the current     ', &     '   directory.                                                          ', &     '                                                                       ', &     '   If "file" does not exist or cannot be read, then an error occurs and', &     '   the program stops. Each line of the file is prefixed with "options" ', &     '   and interpreted as a separate argument. The file itself may not     ', &     '   contain @file arguments. That is, it is not processed recursively.  ', &     '                                                                       ', &     '   For more information on response files see                          ', &     '                                                                       ', &     '      https://urbanjost.github.io/M_CLI2/set_args.3m_cli2.html         ', &     '                                                                       ', &     '   The basic functionality described here will remain the same, but    ', &     '   other features described at the above reference may change.         ', &     '                                                                       ', &     '   An example file:                                                    ', &     '                                                                       ', &     '     # my build options                                                ', &     '     options build                                                     ', &     '     options --compiler gfortran                                       ', &     '     options --flag "-pg -static -pthread -Wunreachable-code -Wunused  ', &     '      -Wuninitialized -g -O -fbacktrace -fdump-core -fno-underscoring  ', &     '      -frecord-marker=4 -L/usr/X11R6/lib -L/usr/X11R6/lib64 -lX11"     ', &     '                                                                       ', &     '   Note --flag would have to be on one line as response files do not   ', &     '   (currently) allow for continued lines or multiple specifications of ', &     '   the same option.                                                    ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     '   sample commands:                                                    ', &     '                                                                       ', &     '    fpm new mypackage --app --test                                     ', &     '    fpm build                                                          ', &     '    fpm test                                                           ', &     '    fpm run                                                            ', &     '    fpm run --example                                                  ', &     '    fpm new --help                                                     ', &     '    fpm run myprogram --profile release -- -x 10 -y 20 --title "my title"       ', &     '    fpm install --prefix ~/.local                                               ', &     '    fpm clean --all                                                             ', &     '                                                                                ', &     'SEE ALSO                                                                        ', &     '                                                                                ', &     ' + The fpm(1) home page is at https://github.com/fortran-lang/fpm               ', &     ' + Registered fpm(1) packages are at https://fortran-lang.org/packages          ', &     ' + The fpm(1) TOML file format is described at                                  ', &     '   https://fpm.fortran-lang.org/en/spec/manifest.html                           ', &     '']     help_list=[character(len=80) :: &     'NAME                                                                   ', &     ' list(1) - list summary of fpm(1) subcommands                          ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm list                                                              ', &     '                                                                       ', &     ' fpm list --help|--version                                             ', &     '                                                                       ', &     '     '      '                                                                       ', &     'OPTIONS                                                                ', &     ' --list     display a list of command options as well. This is the     ', &     '            same output as generated by "fpm --list".                  ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' display a short list of fpm(1) subcommands                            ', &     '                                                                       ', &     '  fpm list                                                             ', &     '  fpm --list                                                           ', &     '' ]     help_run=[character(len=80) :: &     'NAME                                                                   ', &     ' run(1) - the fpm(1) subcommand to run project applications            ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm run [[--target] NAME(s) [--profile PROF] [--flag FFLAGS]', &     '         [--compiler      '         [--list] [--all] [-- ARGS]', &     '                                                                       ', &     ' fpm run --help|--version                                              ', &     '                                                                       ', &     '     ' Run the applications in your fpm(1) package. By default applications  ', &     ' in /app or specified as "executable" in your "fpm.toml" manifest are  ', &     ' used. Alternatively demonstration programs in example/ or specified in', &     ' the "example" section in "fpm.toml" can be executed. The applications ', &     ' are automatically rebuilt before being run if they are out of date.   ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' --target NAME(s)  list of application names to execute. No name is    ', &     '                   required if only one target exists. If no name is   ', &     '                   supplied and more than one candidate exists or a    ', &     '                   name has no match a list is produced and fpm(1)     ', &     '                   exits.                                              ', &     '                                                                       ', &     '                   Basic "globbing" is supported where "?" represents  ', &     '                   any single character and "*" represents any string. ', &     '                   Note The glob string normally needs quoted to       ', &     '                   the special characters from shell expansion.        ', &     ' --all   Run all examples or applications. An alias for --target ''*''.  ', &     ' --example  Run example programs instead of applications.              ', &     help_text_build_common, &     help_text_compiler, &     help_text_flag, &     ' --runner      '               see "fpm help runner" for further details.              ', &     ' --list     list basenames of candidates instead of running them. Note ', &     '            out-of-date candidates will still be rebuilt before being  ', &     '            listed.                                                    ', &     ' -- ARGS    optional arguments to pass to the program(s). The same     ', &     '            arguments are passed to all program names specified.       ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' fpm(1) - run or display project applications:                         ', &     '                                                                       ', &     '  fpm run        # run a target when only one exists or list targets   ', &     '  fpm run --list # list basename of all targets, running nothing.      ', &     '  fpm run "demo*" --list # list target basenames starting with "demo*".', &     '  fpm run "psi*" --runner # list target pathnames starting with "psi*".', &     '  fpm run --all  # run all targets, no matter how many there are.      ', &     '                                                                       ', &     '  # run default program built or to be built with the compiler command ', &     '  # "f90". If more than one app exists a list displays and target names', &     '  # are required.                                                      ', &     '  fpm run --compiler f90                                               ', &     '                                                                       ', &     '  # run example programs instead of the application programs.          ', &     '  fpm run --example "*"                                                ', &     '                                                                       ', &     '  # run a specific program and pass arguments to the command           ', &     '  fpm run myprog -- -x 10 -y 20 --title "my title line"                ', &     '                                                                       ', &     '  # run production version of two applications                         ', &     '  fpm run --target prg1,prg2 --profile release                         ', &     '                                                                       ', &     '  # install executables in directory (assuming install(1) exists)      ', &     '  fpm run --runner ''install -b -m 0711 -p -t /usr/local/bin''         ', &     '' ]     help_build=[character(len=80) :: &     'NAME                                                                   ', &     ' build(1) - the fpm(1) subcommand to build a project                   ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm build [--profile PROF] [--flag FFLAGS] [--compiler      '           [--list] [--tests]                                          ', &     '                                                                       ', &     ' fpm build --help|--version                                            ', &     '                                                                       ', &     '     ' The "fpm build" command                                               ', &     '    o Fetches any dependencies                                         ', &     '    o Scans your sources                                               ', &     '    o Builds them in the proper order                                  ', &     '                                                                       ', &     ' The Fortran source files are assumed by default to be in              ', &     '    o src/     for modules and procedure source                        ', &     '    o app/     main program(s) for applications                        ', &     '    o test/    main program(s) and support files for project tests     ', &     '    o example/ main program(s) for example programs                    ', &     '      ' the build/ directory.                                                 ', &     '                                                                       ', &     ' Non-default pathnames and remote dependencies are used if             ', &     ' specified in the "fpm.toml" file.                                     ', &     '                                                                       ', &     'OPTIONS                                                                ', &     help_text_build_common,&     help_text_compiler, &     help_text_flag, &     ' --list        list candidates instead of building or running them     ', &     ' --tests       build all tests (otherwise only if needed)              ', &     ' --show-model  show the model and exit (do not build)                  ', &     ' --help        print this help and exit                                ', &     ' --version     print program version information and exit              ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' Sample commands:                                                      ', &     '                                                                       ', &     '  fpm build                   # build with debug options               ', &     '  fpm build --profile release # build with high optimization           ', &     '' ]      help_help=[character(len=80) :: &     'NAME                                                                   ', &     '   help(1) - the fpm(1) subcommand to display help                     ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     '   fpm help [fpm] [new] [build] [run] [test] [help] [version] [manual] ', &     '   [runner]                                                            ', &     '                                                                       ', &     '     '   The "fpm help" command is an alternative to the --help parameter    ', &     '   on the fpm(1) command and its subcommands.                          ', &     '                                                                       ', &     'OPTIONS                                                                ', &     '   NAME(s)    A list of topic names to display. All the subcommands    ', &     '              have their own page (new, build, run, test, ...).        ', &     '                                                                       ', &     '              The special name "manual" displays all the fpm(1)        ', &     '              built-in documentation.                                  ', &     '                                                                       ', &     '              The default is to display help for the fpm(1) command    ', &     '              itself.                                                  ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     '   Sample usage:                                                       ', &     '                                                                       ', &     '     fpm help           # general fpm(1) command help                  ', &     '     fpm help version   # show program version                         ', &     '     fpm help new       # display help for "new" subcommand            ', &     '     fpm help manual    # All fpm(1) built-in documentation            ', &     '                                                                       ', &     '' ]     help_new=[character(len=80) ::                                             &     'NAME                                                                   ', &     ' new(1) - the fpm(1) subcommand to initialize a new project            ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm new NAME [[--lib|--src] [--app] [--test] [--example]]|            ', &     '              [--full|--bare][--backfill]                              ', &     ' fpm new --help|--version                                              ', &     '                                                                       ', &     '     ' "fpm new" creates and populates a new programming project directory.  ', &     '                                                                       ', &     ' It                                                                    ', &     '   o creates a directory with the specified name                       ', &     '   o runs the command "git init" in that directory                     ', &     '   o populates the directory with the default project directories      ', &     '   o adds sample Fortran source files                                  ', &     '                                                                       ', &     ' The default file structure (that will be automatically scanned) is    ', &     '                                                                       ', &     '     NAME/                                                             ', &     '       fpm.toml                                                        ', &     '       src/                                                            ', &     '           NAME.f90                                                    ', &     '       app/                                                            ', &     '           main.f90                                                    ', &     '       test/                                                           ', &     '           check.f90                                                   ', &     '       example/                                                        ', &     '           demo.f90                                                    ', &     '                                                                       ', &     ' Using this file structure is highly encouraged, particularly for      ', &     ' small packages primarily intended to be used as dependencies.         ', &     '                                                                       ', &     ' If you find this restrictive and need to customize the package        ', &     ' structure you will find using the --full switch creates a             ', &     ' heavily annotated manifest file with references to documentation      ', &     ' to aid in constructing complex package structures.                    ', &     '                                                                       ', &     ' Remember to update the information in the sample "fpm.toml"           ', &     ' file with your name and e-mail address.                               ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' NAME   the name of the project directory to create. The name          ', &     '        must be made of up to 63 ASCII letters, digits, underscores,   ', &     '        or hyphens, and start with a letter.                           ', &     '                                                                       ', &     ' The default is to create the src/, app/, and test/ directories.       ', &     ' If any of the following options are specified then only the           ', &     ' selected subdirectories are generated:                                ', &     '                                                                       ', &     ' --lib,--src  create directory src/ and a placeholder module           ', &     '              named "NAME.f90" for use with subcommand "build".        ', &     ' --app        create directory app/ and a placeholder main             ', &     '              program for use with subcommand "run".                   ', &     ' --test       create directory test/ and a placeholder program         ', &     '              for use with the subcommand "test". Note that sans       ', &     '              "--lib" it really does not have anything to test.        ', &     ' --example    create directory example/ and a placeholder program      ', &     '              for use with the subcommand "run --example".             ', &     '              It is only created by default if "--full is" specified.  ', &     '                                                                       ', &     ' So the default is equivalent to                                        ',&     '                                                                       ', &     '    fpm NAME --lib --app --test                                        ', &     '                                                                       ', &     ' --backfill   By default the directory must not exist. If this         ', &     '              option is present the directory may pre-exist and        ', &     '              only subdirectories and files that do not                ', &     '              already exist will be created. For example, if you       ', &     '              previously entered "fpm new myname --lib" entering       ', &     '              "fpm new myname -full --backfill" will create any missing', &     '              app/, example/, and test/ directories and programs.      ', &     '                                                                       ', &     ' --full       By default a minimal manifest file ("fpm.toml") is       ', &     '              created that depends on auto-discovery. With this        ', &     '              option a much more extensive manifest sample is written  ', &     '              and the example/ directory is created and populated.     ', &     '              It is designed to facilitate creating projects that      ', &     '              depend extensively on non-default build options.         ', &     '                                                                       ', &     ' --bare       A minimal manifest file ("fpm.toml") is created and      ', &     '              "README.md" file is created but no directories or        ', &     '              sample Fortran are generated.                            ', &     '                                                                       ', &     ' --help       print this help and exit                                 ', &     ' --version    print program version information and exit               ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' Sample use                                                            ', &     '                                                                       ', &     '   fpm new myproject  # create new project directory and seed it       ', &     '   cd myproject       # Enter the new directory                        ', &     '   # and run commands such as                                          ', &     '   fpm build                                                           ', &     '   fpm run            # run lone example application program           ', &     '   fpm test           # run example test program(s)                    ', &     '   fpm run --example  # run lone example program                       ', &     '                                                                       ', &     '   fpm new A --full # create example/ and an annotated fpm.toml as well', &     '   fpm new A --bare # create no directories                            ', &     '   create any missing files in current directory                       ', &     '   fpm new --full --backfill                                           ', &     '' ]     help_test=[character(len=80) :: &     'NAME                                                                   ', &     ' test(1) - the fpm(1) subcommand to run project tests                  ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS]', &     '          [--compiler      '                                                                       ', &     ' fpm test --help|--version                                             ', &     '                                                                       ', &     '     ' Run applications you have built to test your project.                 ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' --target NAME(s)  optional list of specific test names to execute.    ', &     '                   The default is to run all the tests in test/        ', &     '                   or the tests listed in the "fpm.toml" file.         ', &     '                                                                       ', &     '                   Basic "globbing" is supported where "?" represents  ', &     '                   any single character and "*" represents any string. ', &     '                   Note The glob string normally needs quoted to       ', &     '                   protect the special characters from shell expansion.', &     help_text_build_common,&     help_text_compiler, &     help_text_flag, &     ' --runner      '               see "fpm help runner" for further details.              ', &     ' --list     list candidate basenames instead of running them. Note they', &     ' --list     will still be built if not currently up to date.           ', &     ' -- ARGS    optional arguments to pass to the test program(s).         ', &     '            The same arguments are passed to all test names            ', &     '            specified.                                                 ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     'run tests                                                              ', &     '                                                                       ', &     ' # run default tests in /test or as specified in "fpm.toml"            ', &     ' fpm test                                                              ', &     '                                                                       ', &     ' # run using compiler command "f90"                                    ', &     ' fpm test --compiler f90                                               ', &     '                                                                       ', &     ' # run a specific test and pass arguments to the command               ', &     ' fpm test mytest -- -x 10 -y 20 --title "my title line"                ', &     '                                                                       ', &     ' fpm test tst1 tst2 --profile PROF  # run production version of two tests', &     '' ]     help_update=[character(len=80) :: &     'NAME', &     ' update(1) - manage project dependencies', &     '', &     'SYNOPSIS', &     ' fpm update [--fetch-only] [--clean] [--verbose] [NAME(s)]', &     '', &     '     ' Manage and update project dependencies. If no dependency names are', &     ' provided all the dependencies are updated automatically.', &     '', &     'OPTIONS', &     ' --fetch-only  Only fetch dependencies, do not update existing projects', &     ' --clean            ' --verbose     Show additional printout', &     '', &     'SEE ALSO', &     ' The fpm(1) home page at https://github.com/fortran-lang/fpm', &     '' ]     help_install=[character(len=80) :: &     'NAME', &     ' install(1) - install fpm projects', &     '', &     'SYNOPSIS', &     ' fpm install [--profile PROF] [--flag FFLAGS] [--list] [--no-rebuild]', &     '             [--prefix      '             [--verbose]', &     '', &     '     ' Subcommand to install fpm projects. Running install will export the', &     ' current project to the selected prefix, this will by default install all', &     ' executables (tests and examples are excluded) which are part of the projects.', &     ' Libraries and module files are only installed for projects requiring the', &     ' installation of those components in the package manifest.', &     '', &     'OPTIONS', &     ' --list            list all installable targets for this project,', &     '                   but do not install any of them', &     help_text_build_common,&     help_text_flag, &     ' --no-rebuild      do not rebuild project before installation', &     ' --prefix      '                   the default prefix on Unix systems is $HOME/.local', &     '                   and %APPDATA%\local on Windows', &     ' --bindir      ' --libdir      '                   (default: lib)', &     ' --includedir      '                   (default: include)', &     ' --verbose         print more information', &     '', &     help_text_environment, &     '', &     'EXAMPLES', &     ' 1. Install release version of project:', &     '', &     '    fpm install --profile release', &     '', &     ' 2. Install the project without rebuilding the executables:', &     '', &     '    fpm install --no-rebuild', &     '', &     ' 3. Install executables to a custom prefix into the exe directory:', &     '', &     '    fpm install --prefix $PWD --bindir exe', &     '' ]     help_clean=[character(len=80) :: &     'NAME', &     ' clean(1) - delete the build', &     '', &     'SYNOPSIS', &     ' fpm clean', &     '', &     '     ' Prompts the user to confirm deletion of the build. If affirmative,', &     ' directories in the build/ directory are deleted, except dependencies.', &     '', &     'OPTIONS', &     ' --skip           delete the build without prompting but skip dependencies.', &     ' --all            delete the build without prompting including dependencies.', &     '' ]     help_publish=[character(len=80) :: &     'NAME', &     ' publish(1) - publish package to the registry', &     '', &     'SYNOPSIS', &     ' fpm publish [--token TOKEN] [--show-package-version] [--show-upload-data]', &     '             [--dry-run] [--verbose]                                      ', &     '', &     ' fpm publish --help|--version', &     '', &     '     ' Follow the steps to create a tarball and upload a package to the registry:', &     '', &     '  1. Register on the website (https://registry-frontend.vercel.app/).', &     '  2.      '     namespace to avoid conflicts among packages with similar names. A', &     '     namespace can accommodate multiple packages.', &     '  3.      '     and is used to authenticate you during the upload process.      '     the token with others.', &     '  4. Run fpm publish --token TOKEN to upload the package to the registry.', &     '     But be aware that the upload is permanent. An uploaded package cannot be', &     '     deleted.', &     '', &     ' See documentation for more information regarding package upload and usage:', &     '', &     ' Package upload:', &     ' https://fpm.fortran-lang.org/en/spec/publish.html', &     '', &     ' Package usage:', &     ' https://fpm.fortran-lang.org/en/spec/manifest.html#dependencies-from-a-registry', &     '', &     'OPTIONS', &     ' --show-package-version   show package version without publishing', &     ' --show-upload-data       show upload data without publishing', &     ' --dry-run                perform dry run without publishing', &     ' --help                   print this help and exit', &     ' --version                print program version information and exit', &     ' --verbose                print more information', &     '', &     'EXAMPLES', &     '', &     ' fpm publish --show-package-version    # show package version without publishing', &     ' fpm publish --show-upload-data        # show upload data without publishing', &     ' fpm publish --token TOKEN --dry-run   # perform dry run without publishing', &     ' fpm publish --token TOKEN             # upload package to the registry', &     '' ]      end subroutine set_help      subroutine get_char_arg(var, arg)       character(len=:), allocatable, intent(out) :: var       character(len=*), intent(in) :: arg       var = sget(arg)       if (len_trim(var) == 0) deallocate(var)     end subroutine get_char_arg                 function get_fpm_env(env, default) result(val)       character(len=*), intent(in) :: env       character(len=*), intent(in) :: default       character(len=:), allocatable :: val        character(len=*), parameter :: fpm_prefix = "FPM_"        val = get_env(fpm_prefix//env, default)     end function get_fpm_env            function runner_command(cmd) result(run_cmd)         class(fpm_run_settings), intent(in) :: cmd         character(len=:), allocatable :: run_cmd                  if (len_trim(cmd%runner)>0) then             run_cmd = trim(cmd%runner)         else             run_cmd = ''         end if                  if (len_trim(cmd%runner_args)>0) run_cmd = run_cmd//' '//trim(cmd%runner_args)     end function runner_command   end module fpm_command_line 
fpm_command_line.f90_comments !># Definition of the command line interface !> !> This module uses [M_CLI2](https://github.com/urbanjost/M_CLI2) to define !> the command line interface. !> To define a command line interface create a new command settings type !> from the [[fpm_cmd_settings]] base class or the respective parent command !> settings. !> !> The subcommand is selected by the first non-option argument in the command !> line. In the subcase block the actual command line is defined and transferred !> to an instance of the [[fpm_cmd_settings]], the actual type is used by the !> *fpm* main program to determine which command entry point is chosen. !> !> To add a new subcommand add a new case to select construct and specify the !> wanted command line and the expected default values. !> Some of the following points also apply if you add a new option or argument !> to an existing *fpm* subcommand. !> At this point you should create a help page for the new command in a simple !> catman-like format as well in the ``set_help`` procedure. !> Make sure to register new subcommands in the ``fpm-manual`` command by adding !> them to the manual character array and in the help/manual case as well. !> You should add the new command to the synopsis section of the ``fpm-list``, !> ``fpm-help`` and ``fpm --list`` help pages below to make sure the help output !> is complete and consistent as well. module fpm_command_line use fpm_environment,  only : get_os_type, get_env, &                              OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, &                              OS_CYGWIN, OS_SOLARIS, OS_FREEBSD, OS_OPENBSD use M_CLI2,           only : set_args, lget, sget, unnamed, remaining, specified use M_CLI2,           only : get_subcommand, CLI_RESPONSE_FILE use fpm_strings,      only : lower, split, to_fortran_name, is_fortran_name, remove_characters_in_set, string_t use fpm_filesystem,   only : basename, canon_path, which, run use fpm_environment,  only : get_command_arguments_quoted use fpm_error,        only : fpm_stop, error_t use fpm_os,           only : get_current_directory use fpm_release,      only : fpm_version, version_t use,intrinsic :: iso_fortran_env, only : stdin=>input_unit, &                                        & stdout=>output_unit, &                                        & stderr=>error_unit  implicit none  private public :: fpm_cmd_settings, &           fpm_build_settings, &           fpm_install_settings, &           fpm_new_settings, &           fpm_run_settings, &           fpm_test_settings, &           fpm_update_settings, &           fpm_clean_settings, &           fpm_publish_settings, &           get_command_line_settings  type, abstract :: fpm_cmd_settings     character(len=:), allocatable :: working_dir     logical                       :: verbose=.true. end type  integer,parameter :: ibug=4096  type, extends(fpm_cmd_settings)  :: fpm_new_settings     character(len=:),allocatable :: name     logical                      :: with_executable=.false.     logical                      :: with_test=.false.     logical                      :: with_lib=.true.     logical                      :: with_example=.false.     logical                      :: with_full=.false.     logical                      :: with_bare=.false.     logical                      :: backfill=.true. end type  type, extends(fpm_cmd_settings)  :: fpm_build_settings     logical                      :: list=.false.     logical                      :: show_model=.false.     logical                      :: build_tests=.false.     logical                      :: prune=.true.     character(len=:),allocatable :: compiler     character(len=:),allocatable :: c_compiler     character(len=:),allocatable :: cxx_compiler     character(len=:),allocatable :: archiver     character(len=:),allocatable :: profile     character(len=:),allocatable :: flag     character(len=:),allocatable :: cflag     character(len=:),allocatable :: cxxflag     character(len=:),allocatable :: ldflag end type  type, extends(fpm_build_settings)  :: fpm_run_settings     character(len=ibug),allocatable :: name(:)     character(len=:),allocatable :: args ! passed to the app     character(len=:),allocatable :: runner     character(len=:),allocatable :: runner_args ! passed to the runner     logical :: example     contains        procedure :: runner_command end type  type, extends(fpm_run_settings)  :: fpm_test_settings end type  type, extends(fpm_build_settings) :: fpm_install_settings     character(len=:), allocatable :: prefix     character(len=:), allocatable :: bindir     character(len=:), allocatable :: libdir     character(len=:), allocatable :: includedir     logical :: no_rebuild end type  !> Settings for interacting and updating with project dependencies type, extends(fpm_cmd_settings)  :: fpm_update_settings     character(len=ibug),allocatable :: name(:)     logical :: fetch_only     logical :: clean end type  type, extends(fpm_cmd_settings)   :: fpm_clean_settings     logical                       :: clean_skip = .false.     logical                       :: clean_call = .false. end type  type, extends(fpm_build_settings) :: fpm_publish_settings     logical :: show_package_version = .false.     logical :: show_upload_data = .false.     logical :: is_dry_run = .false.     character(len=:), allocatable :: token end type  character(len=:),allocatable :: name character(len=:),allocatable :: os_type character(len=ibug),allocatable :: names(:) character(len=:),allocatable :: tnames(:)  character(len=:), allocatable :: version_text(:) character(len=:), allocatable :: help_new(:), help_fpm(:), help_run(:), &                  & help_test(:), help_build(:), help_usage(:), help_runner(:), &                  & help_text(:), help_install(:), help_help(:), help_update(:), &                  & help_list(:), help_list_dash(:), help_list_nodash(:), &                  & help_clean(:), help_publish(:) character(len=20),parameter :: manual(*)=[ character(len=20) ::& &  ' ',     'fpm',    'new',     'build',  'run',    'clean',  & &  'test',  'runner', 'install', 'update', 'list',   'help',   'version', 'publish' ]  character(len=:), allocatable :: val_runner, val_compiler, val_flag, val_cflag, val_cxxflag, val_ldflag, &     val_profile, val_runner_args  !   '12345678901234567890123456789012345678901234567890123456789012345678901234567890',& character(len=80), parameter :: help_text_build_common(*) = [character(len=80) ::      &     ' --profile PROF    Selects the compilation profile for the build.               ',&     '                   Currently available profiles are "release" for               ',&     '                   high optimization and "debug" for full debug options.        ',&     '                   If --flag is not specified the "debug" flags are the         ',&     '                   default.                                                     ',&     ' --no-prune        Disable tree-shaking/pruning of unused module dependencies   '&     ] !   '12345678901234567890123456789012345678901234567890123456789012345678901234567890',& character(len=80), parameter :: help_text_compiler(*) = [character(len=80) :: &     ' --compiler NAME    Specify a compiler name. The default is "gfortran"          ',&     '                    unless set by the environment variable FPM_FC.              ',&     ' --c-compiler NAME  Specify the C compiler name. Automatically determined by    ',&     '                    default unless set by the environment variable FPM_CC.      ',&     ' --cxx-compiler NAME  Specify the C++ compiler name. Automatically determined by',&     '                    default unless set by the environment variable FPM_CXX.     ',&     ' --archiver NAME    Specify the archiver name. Automatically determined by      ',&     '                    default unless set by the environment variable FPM_AR.      '&     ]  !   '12345678901234567890123456789012345678901234567890123456789012345678901234567890',& character(len=80), parameter :: help_text_flag(*) = [character(len=80) :: &     ' --flag  FFLAGS    selects compile arguments for the build, the default value is',&     '                   set by the FPM_FFLAGS environment variable. These are added  ',&     '                   to the profile options if --profile is specified, else these ',&     '                   options override the defaults. Note object and .mod          ',&     '                   directory locations are always built in.                     ',&     ' --c-flag CFLAGS   selects compile arguments specific for C source in the build.',&     '                   The default value is set by the FPM_CFLAGS environment       ',&     '                   variable.                                                    ',&     ' --cxx-flag CFLAGS selects compile arguments specific for C++ source in the     ',&     '                   build. The default value is set by the FPM_CXXFLAGS          ',&     '                   environment variable.                                        ',&     ' --link-flag LDFLAGS  select arguments passed to the linker for the build. The  ',&     '                   default value is set by the FPM_LDFLAGS environment variable.'&     ]   character(len=80), parameter :: help_text_environment(*) = [character(len=80) :: &     'ENVIRONMENT VARIABLES',&     ' FPM_FC            sets the path to the Fortran compiler used for the build,', &     '                   will be overwritten by --compiler command line option', &     '', &     ' FPM_FFLAGS        sets the arguments for the Fortran compiler', &     '                   will be overwritten by --flag command line option', &     '', &     ' FPM_CC            sets the path to the C compiler used for the build,', &     '                   will be overwritten by --c-compiler command line option', &     '', &     ' FPM_CFLAGS        sets the arguments for the C compiler', &     '                   will be overwritten by --c-flag command line option', &     '', &     ' FPM_CXX           sets the path to the C++ compiler used for the build,', &     '                   will be overwritten by --cxx-compiler command line option', &     '', &     ' FPM_CXXFLAGS      sets the arguments for the C++ compiler', &     '                   will be overwritten by --cxx-flag command line option', &     '', &     ' FPM_AR            sets the path to the archiver used for the build,', &     '                   will be overwritten by --archiver command line option', &     '', &     ' FPM_LDFLAGS       sets additional link arguments for creating executables', &     '                   will be overwritten by --link-flag command line option' &     ]  contains     subroutine get_command_line_settings(cmd_settings)         class(fpm_cmd_settings), allocatable, intent(out) :: cmd_settings          integer, parameter            :: widest = 256         character(len=4096)           :: cmdarg         integer                       :: i         integer                       :: os         type(fpm_install_settings), allocatable :: install_settings         type(version_t) :: version         character(len=:), allocatable :: common_args, compiler_args, run_args, working_dir, &             & c_compiler, cxx_compiler, archiver, version_s, token_s          character(len=*), parameter :: fc_env = "FC", cc_env = "CC", ar_env = "AR", &             & fflags_env = "FFLAGS", cflags_env = "CFLAGS", cxxflags_env = "CXXFLAGS", ldflags_env = "LDFLAGS", &             & fc_default = "gfortran", cc_default = " ", ar_default = " ", flags_default = " ", &             & cxx_env = "CXX", cxx_default = " "         type(error_t), allocatable :: error          call set_help()         os = get_os_type()         ! text for --version switch,         select case (os)             case (OS_LINUX);   os_type =  "OS Type:     Linux"             case (OS_MACOS);   os_type =  "OS Type:     macOS"             case (OS_WINDOWS); os_type =  "OS Type:     Windows"             case (OS_CYGWIN);  os_type =  "OS Type:     Cygwin"             case (OS_SOLARIS); os_type =  "OS Type:     Solaris"             case (OS_FREEBSD); os_type =  "OS Type:     FreeBSD"             case (OS_OPENBSD); os_type =  "OS Type:     OpenBSD"             case (OS_UNKNOWN); os_type =  "OS Type:     Unknown"             case default     ; os_type =  "OS Type:     UNKNOWN"         end select          ! Get current release version         version = fpm_version()         version_s = version%s()          version_text = [character(len=80) :: &          &  'Version:     '//trim(version_s)//', alpha',               &          &  'Program:     fpm(1)',                                     &          &  'Description: A Fortran package manager and build system', &          &  'Home Page:   https://github.com/fortran-lang/fpm',        &          &  'License:     MIT',                                        &          &  os_type]         ! find the subcommand name by looking for first word on command         ! not starting with dash         CLI_RESPONSE_FILE=.true.         cmdarg = get_subcommand()          common_args = &           ' --directory:C " "' // &           ' --verbose F'          run_args = &           ' --target " "' // &           ' --list F' // &           ' --runner " "' // &           ' --runner-args " "'          compiler_args = &           ' --profile " "' // &           ' --no-prune F' // &           ' --compiler "'//get_fpm_env(fc_env, fc_default)//'"' // &           ' --c-compiler "'//get_fpm_env(cc_env, cc_default)//'"' // &           ' --cxx-compiler "'//get_fpm_env(cxx_env, cxx_default)//'"' // &           ' --archiver "'//get_fpm_env(ar_env, ar_default)//'"' // &           ' --flag:: "'//get_fpm_env(fflags_env, flags_default)//'"' // &           ' --c-flag:: "'//get_fpm_env(cflags_env, flags_default)//'"' // &           ' --cxx-flag:: "'//get_fpm_env(cxxflags_env, flags_default)//'"' // &           ' --link-flag:: "'//get_fpm_env(ldflags_env, flags_default)//'"'          ! now set subcommand-specific help text and process commandline         ! arguments. Then call subcommand routine         select case(trim(cmdarg))          case('run')             call set_args(common_args // compiler_args // run_args //'&             & --all F &             & --example F&             & --',help_run,version_text)              call check_build_vals()              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif               if(specified('target') )then                call split(sget('target'),tnames,delimiters=' ,:')                names=[character(len=max(len(names),len(tnames))) :: names,tnames]             endif              ! convert --all to '*'             if(lget('all'))then                names=[character(len=max(len(names),1)) :: names,'*' ]             endif              ! convert special string '..' to equivalent (shorter) '*'             ! to allow for a string that does not require shift-key and quoting             do i=1,size(names)                if(names(i)=='..')names(i)='*'             enddo              ! If there are additional command-line arguments, remove the additional             ! double quotes which have been added by M_CLI2             val_runner_args=sget('runner-args')             call remove_characters_in_set(val_runner_args,set='"')              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(fpm_run_settings :: cmd_settings)             val_runner=sget('runner')             if(specified('runner') .and. val_runner=='')val_runner='echo'              cmd_settings=fpm_run_settings(&             & args=remaining,&             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & example=lget('example'), &             & list=lget('list'),&             & build_tests=.false.,&             & name=names,&             & runner=val_runner,&             & runner_args=val_runner_args, &             & verbose=lget('verbose') )          case('build')             call set_args(common_args // compiler_args //'&             & --list F &             & --show-model F &             & --tests F &             & --',help_build,version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate( fpm_build_settings :: cmd_settings )             cmd_settings=fpm_build_settings(  &             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & list=lget('list'),&             & show_model=lget('show-model'),&             & build_tests=lget('tests'),&             & verbose=lget('verbose') )          case('new')             call set_args(common_args // '&             & --src F &             & --lib F &             & --app F &             & --test F &             & --example F &             & --backfill F &             & --full F &             & --bare F', &             & help_new, version_text)             select case(size(unnamed))             case(1)                 if(lget('backfill'))then                    name='.'                 else                    write(stderr,'(*(7x,g0,/))') &                    & '<USAGE> fpm new NAME [[--lib|--src] [--app] [--test] [--example]]|[--full|--bare] [--backfill]'                    call fpm_stop(1,'directory name required')                 endif             case(2)                 name=trim(unnamed(2))             case default                 write(stderr,'(7x,g0)') &                 & '<USAGE> fpm new NAME [[--lib|--src] [--app] [--test] [--example]]| [--full|--bare] [--backfill]'                 call fpm_stop(2,'only one directory name allowed')             end select             !*! canon_path is not converting ".", etc.             if(name=='.')then                call get_current_directory(name, error)                if (allocated(error)) then                   write(stderr, '("[Error]", 1x, a)') error%message                   stop 1                endif             endif             name=canon_path(name)             if( .not.is_fortran_name(to_fortran_name(basename(name))) )then                 write(stderr,'(g0)') [ character(len=72) :: &                 & '<ERROR> the fpm project name must be made of up to 63 ASCII letters,', &                 & '        numbers, underscores, or hyphens, and start with a letter.']                 call fpm_stop(4,' ')             endif               allocate(fpm_new_settings :: cmd_settings)             if (any( specified([character(len=10) :: 'src','lib','app','test','example','bare'])) &             & .and.lget('full') )then                 write(stderr,'(*(a))')&                 &'<ERROR> --full and any of [--src|--lib,--app,--test,--example,--bare]', &                 &'        are mutually exclusive.'                 call fpm_stop(5,' ')             elseif (any( specified([character(len=10) :: 'src','lib','app','test','example','full'])) &             & .and.lget('bare') )then                 write(stderr,'(*(a))')&                 &'<ERROR> --bare and any of [--src|--lib,--app,--test,--example,--full]', &                 &'        are mutually exclusive.'                 call fpm_stop(3,' ')             elseif (any( specified([character(len=10) :: 'src','lib','app','test','example']) ) )then                 cmd_settings=fpm_new_settings(&                  & backfill=lget('backfill'),               &                  & name=name,                               &                  & with_executable=lget('app'),             &                  & with_lib=any([lget('lib'),lget('src')]), &                  & with_test=lget('test'),                  &                  & with_example=lget('example'),            &                  & verbose=lget('verbose') )             else  ! default if no specific directories are requested                 cmd_settings=fpm_new_settings(&                  & backfill=lget('backfill') ,           &                  & name=name,                            &                  & with_executable=.true.,               &                  & with_lib=.true.,                      &                  & with_test=.true.,                     &                  & with_example=lget('full'),            &                  & with_full=lget('full'),               &                  & with_bare=lget('bare'),               &                  & verbose=lget('verbose') )             endif          case('help','manual')             call set_args(common_args, help_help,version_text)             if(size(unnamed)<2)then                 if(unnamed(1)=='help')then                    unnamed=['   ', 'fpm']                 else                    unnamed=manual                 endif             elseif(unnamed(2)=='manual')then                 unnamed=manual             endif             allocate(character(len=widest) :: help_text(0))             do i=2,size(unnamed)                 select case(unnamed(i))                 case('       ' )                 case('fpm    ' )                    help_text=[character(len=widest) :: help_text, help_fpm]                 case('new    ' )                    help_text=[character(len=widest) :: help_text, help_new]                 case('build  ' )                    help_text=[character(len=widest) :: help_text, help_build]                 case('install' )                    help_text=[character(len=widest) :: help_text, help_install]                 case('run    ' )                    help_text=[character(len=widest) :: help_text, help_run]                 case('test   ' )                    help_text=[character(len=widest) :: help_text, help_test]                 case('runner' )                    help_text=[character(len=widest) :: help_text, help_runner]                 case('list   ' )                    help_text=[character(len=widest) :: help_text, help_list]                 case('update ' )                    help_text=[character(len=widest) :: help_text, help_update]                 case('help   ' )                    help_text=[character(len=widest) :: help_text, help_help]                 case('version' )                    help_text=[character(len=widest) :: help_text, version_text]                 case('clean' )                    help_text=[character(len=widest) :: help_text, help_clean]                 case('publish')                    help_text=[character(len=widest) :: help_text, help_publish]                 case default                    help_text=[character(len=widest) :: help_text, &                    & '<ERROR> unknown help topic "'//trim(unnamed(i))//'"']                    !!& '<ERROR> unknown help topic "'//trim(unnamed(i)).'not found in:',manual]                 end select             enddo             call printhelp(help_text)          case('install')             call set_args(common_args // compiler_args // '&                 & --no-rebuild F --prefix " " &                 & --list F &                 & --libdir "lib" --bindir "bin" --includedir "include"', &                 help_install, version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(install_settings, source=fpm_install_settings(&                 list=lget('list'), &                 profile=val_profile,&                 prune=.not.lget('no-prune'), &                 compiler=val_compiler, &                 c_compiler=c_compiler, &                 cxx_compiler=cxx_compiler, &                 archiver=archiver, &                 flag=val_flag, &                 cflag=val_cflag, &                 cxxflag=val_cxxflag, &                 ldflag=val_ldflag, &                 no_rebuild=lget('no-rebuild'), &                 verbose=lget('verbose')))             call get_char_arg(install_settings%prefix, 'prefix')             call get_char_arg(install_settings%libdir, 'libdir')             call get_char_arg(install_settings%bindir, 'bindir')             call get_char_arg(install_settings%includedir, 'includedir')             call move_alloc(install_settings, cmd_settings)          case('list')             call set_args(common_args // '&             & --list F&             &', help_list, version_text)             if(lget('list'))then                 help_text = [character(widest) :: help_list_nodash, help_list_dash]             else                 help_text = help_list_nodash             endif             call printhelp(help_text)          case('test')             call set_args(common_args // compiler_args // run_args // ' --', &               help_test,version_text)              call check_build_vals()              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif              if(specified('target') )then                call split(sget('target'),tnames,delimiters=' ,:')                names=[character(len=max(len(names),len(tnames))) :: names,tnames]             endif              ! convert special string '..' to equivalent (shorter) '*'             ! to allow for a string that does not require shift-key and quoting             do i=1,size(names)                if(names(i)=='..')names(i)='*'             enddo              ! If there are additional command-line arguments, remove the additional             ! double quotes which have been added by M_CLI2             val_runner_args=sget('runner-args')             call remove_characters_in_set(val_runner_args,set='"')              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             allocate(fpm_test_settings :: cmd_settings)             val_runner=sget('runner')             if(specified('runner') .and. val_runner=='')val_runner='echo'              cmd_settings=fpm_test_settings(&             & args=remaining, &             & profile=val_profile, &             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & example=.false., &             & list=lget('list'), &             & build_tests=.true., &             & name=names, &             & runner=val_runner, &             & runner_args=val_runner_args, &             & verbose=lget('verbose'))          case('update')             call set_args(common_args // ' --fetch-only F --clean F', &                 help_update, version_text)              if( size(unnamed) > 1 )then                 names=unnamed(2:)             else                 names=[character(len=len(names)) :: ]             endif              allocate(fpm_update_settings :: cmd_settings)             cmd_settings=fpm_update_settings(name=names, &                 fetch_only=lget('fetch-only'), verbose=lget('verbose'), &                 clean=lget('clean'))          case('clean')             call set_args(common_args // &             &   ' --skip'             // &             &   ' --all',                &                 help_clean, version_text)             allocate(fpm_clean_settings :: cmd_settings)             call get_current_directory(working_dir, error)             cmd_settings=fpm_clean_settings( &             &   clean_skip=lget('skip'),     &             &   clean_call=lget('all'))          case('publish')             call set_args(common_args // compiler_args //'&             & --show-package-version F &             & --show-upload-data F &             & --dry-run F &             & --token " " &             & --list F &             & --show-model F &             & --tests F &             & --', help_publish, version_text)              call check_build_vals()              c_compiler = sget('c-compiler')             cxx_compiler = sget('cxx-compiler')             archiver = sget('archiver')             token_s = sget('token')              allocate(fpm_publish_settings :: cmd_settings)             cmd_settings = fpm_publish_settings( &             & show_package_version = lget('show-package-version'), &             & show_upload_data = lget('show-upload-data'), &             & is_dry_run = lget('dry-run'), &             & profile=val_profile,&             & prune=.not.lget('no-prune'), &             & compiler=val_compiler, &             & c_compiler=c_compiler, &             & cxx_compiler=cxx_compiler, &             & archiver=archiver, &             & flag=val_flag, &             & cflag=val_cflag, &             & cxxflag=val_cxxflag, &             & ldflag=val_ldflag, &             & list=lget('list'),&             & show_model=lget('show-model'),&             & build_tests=lget('tests'),&             & verbose=lget('verbose'),&             & token=token_s)          case default              if(cmdarg.ne.''.and.which('fpm-'//cmdarg).ne.'')then                 call run('fpm-'//trim(cmdarg)//' '// get_command_arguments_quoted(),.false.)                 stop             else                 call set_args('&                 & --list F&                 &', help_fpm, version_text)                 ! Note: will not get here if --version or --usage or --help                 ! is present on commandline                 if(lget('list'))then                     help_text = help_list_dash                 elseif(len_trim(cmdarg)==0)then                     write(stdout,'(*(a))')'Fortran Package Manager:'                     write(stdout,'(*(a))')' '                     help_text = [character(widest) :: help_list_nodash, help_usage]                 else                     write(stderr,'(*(a))')'<ERROR> unknown subcommand [', &                      & trim(cmdarg), ']'                     help_text = [character(widest) :: help_list_dash, help_usage]                 endif                 call printhelp(help_text)             endif          end select          if (allocated(cmd_settings)) then             working_dir = sget("directory")             call move_alloc(working_dir, cmd_settings%working_dir)         end if      contains      subroutine check_build_vals()         val_compiler=sget('compiler')         if(val_compiler=='') val_compiler='gfortran'          val_flag = " " // sget('flag')         val_cflag = " " // sget('c-flag')         val_cxxflag = " "// sget('cxx-flag')         val_ldflag = " " // sget('link-flag')         val_profile = sget('profile')      end subroutine check_build_vals      !> Print help text and stop     subroutine printhelp(lines)     character(len=:),intent(in),allocatable :: lines(:)     integer :: iii,ii         if(allocated(lines))then            ii=size(lines)            if(ii > 0 .and. len(lines)> 0) then                write(stdout,'(g0)')(trim(lines(iii)), iii=1, ii)            else                write(stdout,'(a)')'<WARNING> *printhelp* output requested is empty'            endif         endif         stop     end subroutine printhelp      end subroutine get_command_line_settings      subroutine set_help()    help_list_nodash=[character(len=80) :: &    'USAGE: fpm [ SUBCOMMAND [SUBCOMMAND_OPTIONS] ]|[--list|--help|--version]', &    '       where SUBCOMMAND is commonly new|build|run|test                  ', &    '                                                                        ', &    ' subcommand may be one of                                               ', &    '                                                                        ', &    '  build     Compile the package placing results in the "build" directory', &    '  help      Display help                                                ', &    '  list      Display this list of subcommand descriptions                ', &    '  new       Create a new Fortran package directory with sample files    ', &    '  run       Run the local package application programs                  ', &    '  test      Run the test programs                                       ', &    '  update    Update and manage project dependencies                      ', &    '  install   Install project                                             ', &    '  clean     Delete the build                                            ', &    '  publish   Publish package to the registry                             ', &    '                                                                        ', &    ' Enter "fpm --list" for a brief list of subcommand options. Enter       ', &    ' "fpm --help" or "fpm SUBCOMMAND --help" for detailed descriptions.     ', &    ' ']    help_list_dash = [character(len=80) :: &    '                                                                                ', &    ' build [--compiler COMPILER_NAME] [--profile PROF] [--flag FFLAGS] [--list]     ', &    '       [--tests] [--no-prune]                                                   ', &    ' help [NAME(s)]                                                                 ', &    ' new NAME [[--lib|--src] [--app] [--test] [--example]]|                         ', &    '          [--full|--bare][--backfill]                                           ', &    ' update [NAME(s)] [--fetch-only] [--clean] [--verbose]                          ', &    ' list [--list]                                                                  ', &    ' run  [[--target] NAME(s) [--example] [--profile PROF] [--flag FFLAGS] [--all]  ', &    '      [--runner "CMD"] [--compiler COMPILER_NAME] [--list] [-- ARGS]            ', &    ' test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--runner "CMD"]    ', &    '      [--list] [--compiler COMPILER_NAME] [-- ARGS]                             ', &    ' install [--profile PROF] [--flag FFLAGS] [--no-rebuild] [--prefix PATH]        ', &    '         [options]                                                              ', &    ' clean [--skip] [--all]                                                         ', &    ' publish [--token TOKEN] [--show-package-version] [--show-upload-data]          ', &    '         [--dry-run] [--verbose]                                                ', &    ' ']     help_usage=[character(len=80) :: &     '' ]     help_runner=[character(len=80) :: &    'NAME                                                                            ', &    '   --runner(1) - a shared option for specifying an application to launch        ', &    '                 executables.                                                   ', &    '                                                                                ', &    'SYNOPSIS                                                                        ', &    '   fpm run|test --runner CMD ... --runner-args ARGS -- SUFFIX_OPTIONS           ', &    '                                                                                ', &    'DESCRIPTION                                                                     ', &    '   The --runner option allows specifying a program to launch                    ', &    '   executables selected via the fpm(1) subcommands "run" and "test". This       ', &    '   gives easy recourse to utilities such as debuggers and other tools           ', &    '   that wrap other executables.                                                 ', &    '                                                                                ', &    '   These external commands are not part of fpm(1) itself as they vary           ', &    '   from platform to platform or require independent installation.               ', &    '                                                                                ', &    'OPTION                                                                          ', &    ' --runner ''CMD''  quoted command used to launch the fpm(1) executables.          ', &    '               Available for both the "run" and "test" subcommands.             ', &    '               If the keyword is specified without a value the default command  ', &    '               is "echo".                                                       ', &    ' --runner-args "args"    an additional option to pass command-line arguments    ', &    '               to the runner command, instead of to the fpm app.                ', &    ' -- SUFFIX_OPTIONS  additional options to suffix the command CMD and executable ', &    '                    file names with. These options are passed as command-line   ', &    '                    arguments to the app.                                       ', &    'EXAMPLES                                                                        ', &    '   Use cases for ''fpm run|test --runner "CMD"'' include employing                ', &    '   the following common GNU/Linux and Unix commands:                            ', &    '                                                                                ', &    ' INTERROGATE                                                                    ', &    '    + nm - list symbols from object files                                       ', &    '    + size - list section sizes and total size.                                 ', &    '    + ldd - print shared object dependencies                                    ', &    '    + ls - list directory contents                                              ', &    '    + stat - display file or file system status                                 ', &    '    + file - determine file type                                                ', &    ' PERFORMANCE AND DEBUGGING                                                      ', &    '    + gdb - The GNU Debugger                                                    ', &    '    + valgrind - a suite of tools for debugging and profiling                   ', &    '    + time - time a simple command or give resource usage                       ', &    '    + timeout - run a command with a time limit                                 ', &    ' COPY                                                                           ', &    '    + install - copy files and set attributes                                   ', &    '    + tar - an archiving utility                                                ', &    ' ALTER                                                                          ', &    '    + rm - remove files or directories                                          ', &    '    + chmod - change permissions of a file                                      ', &    '    + strip - remove unnecessary information from strippable files              ', &    '                                                                                ', &    ' For example                                                                    ', &    '                                                                                ', &    '  fpm test --runner gdb                                                         ', &    '  fpm run --runner "tar cvfz $HOME/bundle.tgz"                                  ', &    '  fpm run --runner "mpiexec" --runner-args "-np 12"                             ', &    '  fpm run --runner ldd                                                          ', &    '  fpm run --runner strip                                                        ', &    '  fpm run --runner ''cp -t /usr/local/bin''                                       ', &    '                                                                                ', &    '  # options after executable name can be specified after the -- option          ', &    '  fpm --runner cp run -- /usr/local/bin/                                        ', &    '  # generates commands of the form "cp $FILENAME /usr/local/bin/"               ', &    '                                                                                ', &    '  # bash(1) alias example:                                                      ', &    '  alias fpm-install=\                                                           ', &    '  "fpm run --profile release --runner ''install -vbp -m 0711 -t ~/.local/bin''" ', &    '  fpm-install                                                           ', &     '' ]     help_fpm=[character(len=80) :: &     'NAME                                                                   ', &     '   fpm(1) - A Fortran package manager and build system                 ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     '   fpm SUBCOMMAND [SUBCOMMAND_OPTIONS]                                 ', &     '                                                                       ', &     '   fpm --help|--version|--list                                         ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     '   fpm(1) is a package manager that helps you create Fortran projects  ', &     '   from source -- it automatically determines dependencies!            ', &     '                                                                       ', &     '   Most significantly fpm(1) lets you draw upon other fpm(1) packages  ', &     '   in distributed git(1) repositories as if the packages were a basic  ', &     '   part of your default programming environment, as well as letting    ', &     '   you share your projects with others in a similar manner.            ', &     '                                                                       ', &     '   All output goes into the directory "build/" which can generally be  ', &     '   removed and rebuilt if required. Note that if external packages are ', &     '   being used you need network connectivity to rebuild from scratch.   ', &     '                                                                       ', &     'SUBCOMMANDS                                                            ', &     '  Valid fpm(1) subcommands are:                                        ', &     '                                                                       ', &     '  + build    Compile the packages into the "build/" directory.         ', &     '  + new      Create a new Fortran package directory with sample files. ', &     '  + update   Update the project dependencies.                          ', &     '  + run      Run the local package binaries. Defaults to all binaries  ', &     '             for that release.                                         ', &     '  + test     Run the tests.                                            ', &     '  + help     Alternate to the --help switch for displaying help text.  ', &     '  + list     Display brief descriptions of all subcommands.            ', &     '  + install  Install project.                                          ', &     '  + clean    Delete directories in the "build/" directory, except      ', &     '             dependencies. Prompts for confirmation to delete.         ', &     '  + publish  Publish package to the registry.                          ', &     '                                                                       ', &     '  Their syntax is                                                      ', &     '                                                                                ', &     '    build [--profile PROF] [--flag FFLAGS] [--list] [--compiler COMPILER_NAME]  ', &     '          [--tests] [--no-prune]                                                ', &     '    new NAME [[--lib|--src] [--app] [--test] [--example]]|                      ', &     '             [--full|--bare][--backfill]                                        ', &     '    update [NAME(s)] [--fetch-only] [--clean]                                   ', &     '    run [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--list] [--all]  ', &     '        [--example] [--runner "CMD"] [--compiler COMPILER_NAME]                 ', &     '        [--no-prune] [-- ARGS]                                                  ', &     '    test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS] [--list]         ', &     '         [--runner "CMD"] [--compiler COMPILER_NAME] [--no-prune] [-- ARGS]     ', &     '    help [NAME(s)]                                                              ', &     '    list [--list]                                                               ', &     '    install [--profile PROF] [--flag FFLAGS] [--no-rebuild] [--prefix PATH]     ', &     '            [options]                                                           ', &     '    clean [--skip] [--all]                                                      ', &     '    publish [--token TOKEN] [--show-package-version] [--show-upload-data]       ', &     '            [--dry-run] [--verbose]                                             ', &     '                                                                                ', &     'SUBCOMMAND OPTIONS                                                              ', &     ' -C, --directory PATH', &     '             Change working directory to PATH before running any command', &     help_text_build_common, &     help_text_compiler, &     help_text_flag, &     '  --list     List candidates instead of building or running them. On   ', &     '             the fpm(1) command this shows a brief list of subcommands.', &     '  --runner CMD   Provides a command to prefix program execution paths. ', &     '  -- ARGS    Arguments to pass to executables.                         ', &     '  --skip     Delete directories in the build/ directory without        ', &     '             prompting, but skip dependencies.                         ', &     '  --all      Delete directories in the build/ directory without        ', &     '             prompting, including dependencies.                        ', &     '                                                                       ', &     'VALID FOR ALL SUBCOMMANDS                                              ', &     '  --help     Show help text and exit                                   ', &     '  --verbose  Display additional information when available             ', &     '  --version  Show version information and exit.                        ', &     '                                                                       ', &     '@file                                                                  ', &     '   You may replace the default options for the fpm(1) command from a   ', &     '   file if your first options begin with @file. Initial options will   ', &     '   then be read from the "response file" "file.rsp" in the current     ', &     '   directory.                                                          ', &     '                                                                       ', &     '   If "file" does not exist or cannot be read, then an error occurs and', &     '   the program stops. Each line of the file is prefixed with "options" ', &     '   and interpreted as a separate argument. The file itself may not     ', &     '   contain @file arguments. That is, it is not processed recursively.  ', &     '                                                                       ', &     '   For more information on response files see                          ', &     '                                                                       ', &     '      https://urbanjost.github.io/M_CLI2/set_args.3m_cli2.html         ', &     '                                                                       ', &     '   The basic functionality described here will remain the same, but    ', &     '   other features described at the above reference may change.         ', &     '                                                                       ', &     '   An example file:                                                    ', &     '                                                                       ', &     '     # my build options                                                ', &     '     options build                                                     ', &     '     options --compiler gfortran                                       ', &     '     options --flag "-pg -static -pthread -Wunreachable-code -Wunused  ', &     '      -Wuninitialized -g -O -fbacktrace -fdump-core -fno-underscoring  ', &     '      -frecord-marker=4 -L/usr/X11R6/lib -L/usr/X11R6/lib64 -lX11"     ', &     '                                                                       ', &     '   Note --flag would have to be on one line as response files do not   ', &     '   (currently) allow for continued lines or multiple specifications of ', &     '   the same option.                                                    ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     '   sample commands:                                                    ', &     '                                                                       ', &     '    fpm new mypackage --app --test                                     ', &     '    fpm build                                                          ', &     '    fpm test                                                           ', &     '    fpm run                                                            ', &     '    fpm run --example                                                  ', &     '    fpm new --help                                                     ', &     '    fpm run myprogram --profile release -- -x 10 -y 20 --title "my title"       ', &     '    fpm install --prefix ~/.local                                               ', &     '    fpm clean --all                                                             ', &     '                                                                                ', &     'SEE ALSO                                                                        ', &     '                                                                                ', &     ' + The fpm(1) home page is at https://github.com/fortran-lang/fpm               ', &     ' + Registered fpm(1) packages are at https://fortran-lang.org/packages          ', &     ' + The fpm(1) TOML file format is described at                                  ', &     '   https://fpm.fortran-lang.org/en/spec/manifest.html                           ', &     '']     help_list=[character(len=80) :: &     'NAME                                                                   ', &     ' list(1) - list summary of fpm(1) subcommands                          ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm list                                                              ', &     '                                                                       ', &     ' fpm list --help|--version                                             ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     ' Display a short description for each fpm(1) subcommand.               ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' --list     display a list of command options as well. This is the     ', &     '            same output as generated by "fpm --list".                  ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' display a short list of fpm(1) subcommands                            ', &     '                                                                       ', &     '  fpm list                                                             ', &     '  fpm --list                                                           ', &     '' ]     help_run=[character(len=80) :: &     'NAME                                                                   ', &     ' run(1) - the fpm(1) subcommand to run project applications            ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm run [[--target] NAME(s) [--profile PROF] [--flag FFLAGS]', &     '         [--compiler COMPILER_NAME] [--runner "CMD"] [--example]', &     '         [--list] [--all] [-- ARGS]', &     '                                                                       ', &     ' fpm run --help|--version                                              ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     ' Run the applications in your fpm(1) package. By default applications  ', &     ' in /app or specified as "executable" in your "fpm.toml" manifest are  ', &     ' used. Alternatively demonstration programs in example/ or specified in', &     ' the "example" section in "fpm.toml" can be executed. The applications ', &     ' are automatically rebuilt before being run if they are out of date.   ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' --target NAME(s)  list of application names to execute. No name is    ', &     '                   required if only one target exists. If no name is   ', &     '                   supplied and more than one candidate exists or a    ', &     '                   name has no match a list is produced and fpm(1)     ', &     '                   exits.                                              ', &     '                                                                       ', &     '                   Basic "globbing" is supported where "?" represents  ', &     '                   any single character and "*" represents any string. ', &     '                   Note The glob string normally needs quoted to       ', &     '                   the special characters from shell expansion.        ', &     ' --all   Run all examples or applications. An alias for --target ''*''.  ', &     ' --example  Run example programs instead of applications.              ', &     help_text_build_common, &     help_text_compiler, &     help_text_flag, &     ' --runner CMD  A command to prefix the program execution paths with.   ', &     '               see "fpm help runner" for further details.              ', &     ' --list     list basenames of candidates instead of running them. Note ', &     '            out-of-date candidates will still be rebuilt before being  ', &     '            listed.                                                    ', &     ' -- ARGS    optional arguments to pass to the program(s). The same     ', &     '            arguments are passed to all program names specified.       ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' fpm(1) - run or display project applications:                         ', &     '                                                                       ', &     '  fpm run        # run a target when only one exists or list targets   ', &     '  fpm run --list # list basename of all targets, running nothing.      ', &     '  fpm run "demo*" --list # list target basenames starting with "demo*".', &     '  fpm run "psi*" --runner # list target pathnames starting with "psi*".', &     '  fpm run --all  # run all targets, no matter how many there are.      ', &     '                                                                       ', &     '  # run default program built or to be built with the compiler command ', &     '  # "f90". If more than one app exists a list displays and target names', &     '  # are required.                                                      ', &     '  fpm run --compiler f90                                               ', &     '                                                                       ', &     '  # run example programs instead of the application programs.          ', &     '  fpm run --example "*"                                                ', &     '                                                                       ', &     '  # run a specific program and pass arguments to the command           ', &     '  fpm run myprog -- -x 10 -y 20 --title "my title line"                ', &     '                                                                       ', &     '  # run production version of two applications                         ', &     '  fpm run --target prg1,prg2 --profile release                         ', &     '                                                                       ', &     '  # install executables in directory (assuming install(1) exists)      ', &     '  fpm run --runner ''install -b -m 0711 -p -t /usr/local/bin''         ', &     '' ]     help_build=[character(len=80) :: &     'NAME                                                                   ', &     ' build(1) - the fpm(1) subcommand to build a project                   ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm build [--profile PROF] [--flag FFLAGS] [--compiler COMPILER_NAME] ', &     '           [--list] [--tests]                                          ', &     '                                                                       ', &     ' fpm build --help|--version                                            ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     ' The "fpm build" command                                               ', &     '    o Fetches any dependencies                                         ', &     '    o Scans your sources                                               ', &     '    o Builds them in the proper order                                  ', &     '                                                                       ', &     ' The Fortran source files are assumed by default to be in              ', &     '    o src/     for modules and procedure source                        ', &     '    o app/     main program(s) for applications                        ', &     '    o test/    main program(s) and support files for project tests     ', &     '    o example/ main program(s) for example programs                    ', &     ' Changed or new files found are rebuilt. The results are placed in     ', &     ' the build/ directory.                                                 ', &     '                                                                       ', &     ' Non-default pathnames and remote dependencies are used if             ', &     ' specified in the "fpm.toml" file.                                     ', &     '                                                                       ', &     'OPTIONS                                                                ', &     help_text_build_common,&     help_text_compiler, &     help_text_flag, &     ' --list        list candidates instead of building or running them     ', &     ' --tests       build all tests (otherwise only if needed)              ', &     ' --show-model  show the model and exit (do not build)                  ', &     ' --help        print this help and exit                                ', &     ' --version     print program version information and exit              ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' Sample commands:                                                      ', &     '                                                                       ', &     '  fpm build                   # build with debug options               ', &     '  fpm build --profile release # build with high optimization           ', &     '' ]      help_help=[character(len=80) :: &     'NAME                                                                   ', &     '   help(1) - the fpm(1) subcommand to display help                     ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     '   fpm help [fpm] [new] [build] [run] [test] [help] [version] [manual] ', &     '   [runner]                                                            ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     '   The "fpm help" command is an alternative to the --help parameter    ', &     '   on the fpm(1) command and its subcommands.                          ', &     '                                                                       ', &     'OPTIONS                                                                ', &     '   NAME(s)    A list of topic names to display. All the subcommands    ', &     '              have their own page (new, build, run, test, ...).        ', &     '                                                                       ', &     '              The special name "manual" displays all the fpm(1)        ', &     '              built-in documentation.                                  ', &     '                                                                       ', &     '              The default is to display help for the fpm(1) command    ', &     '              itself.                                                  ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     '   Sample usage:                                                       ', &     '                                                                       ', &     '     fpm help           # general fpm(1) command help                  ', &     '     fpm help version   # show program version                         ', &     '     fpm help new       # display help for "new" subcommand            ', &     '     fpm help manual    # All fpm(1) built-in documentation            ', &     '                                                                       ', &     '' ]     help_new=[character(len=80) ::                                             &     'NAME                                                                   ', &     ' new(1) - the fpm(1) subcommand to initialize a new project            ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm new NAME [[--lib|--src] [--app] [--test] [--example]]|            ', &     '              [--full|--bare][--backfill]                              ', &     ' fpm new --help|--version                                              ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     ' "fpm new" creates and populates a new programming project directory.  ', &     '                                                                       ', &     ' It                                                                    ', &     '   o creates a directory with the specified name                       ', &     '   o runs the command "git init" in that directory                     ', &     '   o populates the directory with the default project directories      ', &     '   o adds sample Fortran source files                                  ', &     '                                                                       ', &     ' The default file structure (that will be automatically scanned) is    ', &     '                                                                       ', &     '     NAME/                                                             ', &     '       fpm.toml                                                        ', &     '       src/                                                            ', &     '           NAME.f90                                                    ', &     '       app/                                                            ', &     '           main.f90                                                    ', &     '       test/                                                           ', &     '           check.f90                                                   ', &     '       example/                                                        ', &     '           demo.f90                                                    ', &     '                                                                       ', &     ' Using this file structure is highly encouraged, particularly for      ', &     ' small packages primarily intended to be used as dependencies.         ', &     '                                                                       ', &     ' If you find this restrictive and need to customize the package        ', &     ' structure you will find using the --full switch creates a             ', &     ' heavily annotated manifest file with references to documentation      ', &     ' to aid in constructing complex package structures.                    ', &     '                                                                       ', &     ' Remember to update the information in the sample "fpm.toml"           ', &     ' file with your name and e-mail address.                               ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' NAME   the name of the project directory to create. The name          ', &     '        must be made of up to 63 ASCII letters, digits, underscores,   ', &     '        or hyphens, and start with a letter.                           ', &     '                                                                       ', &     ' The default is to create the src/, app/, and test/ directories.       ', &     ' If any of the following options are specified then only the           ', &     ' selected subdirectories are generated:                                ', &     '                                                                       ', &     ' --lib,--src  create directory src/ and a placeholder module           ', &     '              named "NAME.f90" for use with subcommand "build".        ', &     ' --app        create directory app/ and a placeholder main             ', &     '              program for use with subcommand "run".                   ', &     ' --test       create directory test/ and a placeholder program         ', &     '              for use with the subcommand "test". Note that sans       ', &     '              "--lib" it really does not have anything to test.        ', &     ' --example    create directory example/ and a placeholder program      ', &     '              for use with the subcommand "run --example".             ', &     '              It is only created by default if "--full is" specified.  ', &     '                                                                       ', &     ' So the default is equivalent to                                        ',&     '                                                                       ', &     '    fpm NAME --lib --app --test                                        ', &     '                                                                       ', &     ' --backfill   By default the directory must not exist. If this         ', &     '              option is present the directory may pre-exist and        ', &     '              only subdirectories and files that do not                ', &     '              already exist will be created. For example, if you       ', &     '              previously entered "fpm new myname --lib" entering       ', &     '              "fpm new myname -full --backfill" will create any missing', &     '              app/, example/, and test/ directories and programs.      ', &     '                                                                       ', &     ' --full       By default a minimal manifest file ("fpm.toml") is       ', &     '              created that depends on auto-discovery. With this        ', &     '              option a much more extensive manifest sample is written  ', &     '              and the example/ directory is created and populated.     ', &     '              It is designed to facilitate creating projects that      ', &     '              depend extensively on non-default build options.         ', &     '                                                                       ', &     ' --bare       A minimal manifest file ("fpm.toml") is created and      ', &     '              "README.md" file is created but no directories or        ', &     '              sample Fortran are generated.                            ', &     '                                                                       ', &     ' --help       print this help and exit                                 ', &     ' --version    print program version information and exit               ', &     '                                                                       ', &     'EXAMPLES                                                               ', &     ' Sample use                                                            ', &     '                                                                       ', &     '   fpm new myproject  # create new project directory and seed it       ', &     '   cd myproject       # Enter the new directory                        ', &     '   # and run commands such as                                          ', &     '   fpm build                                                           ', &     '   fpm run            # run lone example application program           ', &     '   fpm test           # run example test program(s)                    ', &     '   fpm run --example  # run lone example program                       ', &     '                                                                       ', &     '   fpm new A --full # create example/ and an annotated fpm.toml as well', &     '   fpm new A --bare # create no directories                            ', &     '   create any missing files in current directory                       ', &     '   fpm new --full --backfill                                           ', &     '' ]     help_test=[character(len=80) :: &     'NAME                                                                   ', &     ' test(1) - the fpm(1) subcommand to run project tests                  ', &     '                                                                       ', &     'SYNOPSIS                                                               ', &     ' fpm test [[--target] NAME(s)] [--profile PROF] [--flag FFLAGS]', &     '          [--compiler COMPILER_NAME ] [--runner "CMD"] [--list][-- ARGS]', &     '                                                                       ', &     ' fpm test --help|--version                                             ', &     '                                                                       ', &     'DESCRIPTION                                                            ', &     ' Run applications you have built to test your project.                 ', &     '                                                                       ', &     'OPTIONS                                                                ', &     ' --target NAME(s)  optional list of specific test names to execute.    ', &     '                   The default is to run all the tests in test/        ', &     '                   or the tests listed in the "fpm.toml" file.         ', &     '                                                                       ', &     '                   Basic "globbing" is supported where "?" represents  ', &     '                   any single character and "*" represents any string. ', &     '                   Note The glob string normally needs quoted to       ', &     '                   protect the special characters from shell expansion.', &     help_text_build_common,&     help_text_compiler, &     help_text_flag, &     ' --runner CMD  A command to prefix the program execution paths with.   ', &     '               see "fpm help runner" for further details.              ', &     ' --list     list candidate basenames instead of running them. Note they', &     ' --list     will still be built if not currently up to date.           ', &     ' -- ARGS    optional arguments to pass to the test program(s).         ', &     '            The same arguments are passed to all test names            ', &     '            specified.                                                 ', &     '                                                                       ', &     help_text_environment, &     '                                                                       ', &     'EXAMPLES                                                               ', &     'run tests                                                              ', &     '                                                                       ', &     ' # run default tests in /test or as specified in "fpm.toml"            ', &     ' fpm test                                                              ', &     '                                                                       ', &     ' # run using compiler command "f90"                                    ', &     ' fpm test --compiler f90                                               ', &     '                                                                       ', &     ' # run a specific test and pass arguments to the command               ', &     ' fpm test mytest -- -x 10 -y 20 --title "my title line"                ', &     '                                                                       ', &     ' fpm test tst1 tst2 --profile PROF  # run production version of two tests', &     '' ]     help_update=[character(len=80) :: &     'NAME', &     ' update(1) - manage project dependencies', &     '', &     'SYNOPSIS', &     ' fpm update [--fetch-only] [--clean] [--verbose] [NAME(s)]', &     '', &     'DESCRIPTION', &     ' Manage and update project dependencies. If no dependency names are', &     ' provided all the dependencies are updated automatically.', &     '', &     'OPTIONS', &     ' --fetch-only  Only fetch dependencies, do not update existing projects', &     ' --clean       Do not use previous dependency cache', &     ' --verbose     Show additional printout', &     '', &     'SEE ALSO', &     ' The fpm(1) home page at https://github.com/fortran-lang/fpm', &     '' ]     help_install=[character(len=80) :: &     'NAME', &     ' install(1) - install fpm projects', &     '', &     'SYNOPSIS', &     ' fpm install [--profile PROF] [--flag FFLAGS] [--list] [--no-rebuild]', &     '             [--prefix DIR] [--bindir DIR] [--libdir DIR] [--includedir DIR]', &     '             [--verbose]', &     '', &     'DESCRIPTION', &     ' Subcommand to install fpm projects. Running install will export the', &     ' current project to the selected prefix, this will by default install all', &     ' executables (tests and examples are excluded) which are part of the projects.', &     ' Libraries and module files are only installed for projects requiring the', &     ' installation of those components in the package manifest.', &     '', &     'OPTIONS', &     ' --list            list all installable targets for this project,', &     '                   but do not install any of them', &     help_text_build_common,&     help_text_flag, &     ' --no-rebuild      do not rebuild project before installation', &     ' --prefix DIR      path to installation directory (requires write access),', &     '                   the default prefix on Unix systems is $HOME/.local', &     '                   and %APPDATA%\local on Windows', &     ' --bindir DIR      subdirectory to place executables in (default: bin)', &     ' --libdir DIR      subdirectory to place libraries and archives in', &     '                   (default: lib)', &     ' --includedir DIR  subdirectory to place headers and module files in', &     '                   (default: include)', &     ' --verbose         print more information', &     '', &     help_text_environment, &     '', &     'EXAMPLES', &     ' 1. Install release version of project:', &     '', &     '    fpm install --profile release', &     '', &     ' 2. Install the project without rebuilding the executables:', &     '', &     '    fpm install --no-rebuild', &     '', &     ' 3. Install executables to a custom prefix into the exe directory:', &     '', &     '    fpm install --prefix $PWD --bindir exe', &     '' ]     help_clean=[character(len=80) :: &     'NAME', &     ' clean(1) - delete the build', &     '', &     'SYNOPSIS', &     ' fpm clean', &     '', &     'DESCRIPTION', &     ' Prompts the user to confirm deletion of the build. If affirmative,', &     ' directories in the build/ directory are deleted, except dependencies.', &     '', &     'OPTIONS', &     ' --skip           delete the build without prompting but skip dependencies.', &     ' --all            delete the build without prompting including dependencies.', &     '' ]     help_publish=[character(len=80) :: &     'NAME', &     ' publish(1) - publish package to the registry', &     '', &     'SYNOPSIS', &     ' fpm publish [--token TOKEN] [--show-package-version] [--show-upload-data]', &     '             [--dry-run] [--verbose]                                      ', &     '', &     ' fpm publish --help|--version', &     '', &     'DESCRIPTION', &     ' Follow the steps to create a tarball and upload a package to the registry:', &     '', &     '  1. Register on the website (https://registry-frontend.vercel.app/).', &     '  2. Create a namespace. Uploaded packages must be assigned to a unique', &     '     namespace to avoid conflicts among packages with similar names. A', &     '     namespace can accommodate multiple packages.', &     '  3. Create a token for that namespace. A token is linked to your username', &     '     and is used to authenticate you during the upload process. Do not share', &     '     the token with others.', &     '  4. Run fpm publish --token TOKEN to upload the package to the registry.', &     '     But be aware that the upload is permanent. An uploaded package cannot be', &     '     deleted.', &     '', &     ' See documentation for more information regarding package upload and usage:', &     '', &     ' Package upload:', &     ' https://fpm.fortran-lang.org/en/spec/publish.html', &     '', &     ' Package usage:', &     ' https://fpm.fortran-lang.org/en/spec/manifest.html#dependencies-from-a-registry', &     '', &     'OPTIONS', &     ' --show-package-version   show package version without publishing', &     ' --show-upload-data       show upload data without publishing', &     ' --dry-run                perform dry run without publishing', &     ' --help                   print this help and exit', &     ' --version                print program version information and exit', &     ' --verbose                print more information', &     '', &     'EXAMPLES', &     '', &     ' fpm publish --show-package-version    # show package version without publishing', &     ' fpm publish --show-upload-data        # show upload data without publishing', &     ' fpm publish --token TOKEN --dry-run   # perform dry run without publishing', &     ' fpm publish --token TOKEN             # upload package to the registry', &     '' ]      end subroutine set_help      subroutine get_char_arg(var, arg)       character(len=:), allocatable, intent(out) :: var       character(len=*), intent(in) :: arg       var = sget(arg)       if (len_trim(var) == 0) deallocate(var)     end subroutine get_char_arg       !> Get an environment variable for fpm, this routine ensures that every variable     !> used by fpm is prefixed with FPM_.     function get_fpm_env(env, default) result(val)       character(len=*), intent(in) :: env       character(len=*), intent(in) :: default       character(len=:), allocatable :: val        character(len=*), parameter :: fpm_prefix = "FPM_"        val = get_env(fpm_prefix//env, default)     end function get_fpm_env       !> Build a full runner command (executable + command-line arguments)     function runner_command(cmd) result(run_cmd)         class(fpm_run_settings), intent(in) :: cmd         character(len=:), allocatable :: run_cmd         !> Get executable         if (len_trim(cmd%runner)>0) then             run_cmd = trim(cmd%runner)         else             run_cmd = ''         end if         !> Append command-line arguments         if (len_trim(cmd%runner_args)>0) run_cmd = run_cmd//' '//trim(cmd%runner_args)     end function runner_command   end module fpm_command_line 
fpm_environment.f90_stripped     module fpm_environment     use,intrinsic :: iso_fortran_env, only : stdin=>input_unit,   &                                            & stdout=>output_unit, &                                            & stderr=>error_unit     use fpm_error, only : fpm_stop     implicit none     private     public :: get_os_type     public :: os_is_unix     public :: get_env     public :: get_command_arguments_quoted     public :: separator      integer, parameter, public :: OS_UNKNOWN = 0     integer, parameter, public :: OS_LINUX   = 1     integer, parameter, public :: OS_MACOS   = 2     integer, parameter, public :: OS_WINDOWS = 3     integer, parameter, public :: OS_CYGWIN  = 4     integer, parameter, public :: OS_SOLARIS = 5     integer, parameter, public :: OS_FREEBSD = 6     integer, parameter, public :: OS_OPENBSD = 7 contains          integer function get_os_type() result(r)                                                                                                   character(len=255) :: val         integer            :: length, rc         logical            :: file_exists         logical, save      :: first_run = .true.         integer, save      :: ret = OS_UNKNOWN                   if (.not. first_run) then             r = ret             return         end if          first_run = .false.         r = OS_UNKNOWN                   call get_environment_variable('OSTYPE', val, length, rc)          if (rc == 0 .and. length > 0) then                          if (index(val, 'linux') > 0) then                 r = OS_LINUX                 ret = r                 return             end if                           if (index(val, 'darwin') > 0) then                 r = OS_MACOS                 ret = r                 return             end if                           if (index(val, 'win') > 0 .or. index(val, 'msys') > 0) then                 r = OS_WINDOWS                 ret = r                 return             end if                           if (index(val, 'cygwin') > 0) then                 r = OS_CYGWIN                 ret = r                 return             end if                           if (index(val, 'SunOS') > 0 .or. index(val, 'solaris') > 0) then                 r = OS_SOLARIS                 ret = r                 return             end if                           if (index(val, 'FreeBSD') > 0 .or. index(val, 'freebsd') > 0) then                 r = OS_FREEBSD                 ret = r                 return             end if                           if (index(val, 'OpenBSD') > 0 .or. index(val, 'openbsd') > 0) then                 r = OS_OPENBSD                 ret = r                 return             end if         end if                   call get_environment_variable('OS', val, length, rc)          if (rc == 0 .and. length > 0 .and. index(val, 'Windows_NT') > 0) then             r = OS_WINDOWS             ret = r             return         end if                   inquire (file='/etc/os-release', exist=file_exists)          if (file_exists) then             r = OS_LINUX             ret = r             return         end if                   inquire (file='/usr/bin/sw_vers', exist=file_exists)          if (file_exists) then             r = OS_MACOS             ret = r             return         end if                   inquire (file='/bin/freebsd-version', exist=file_exists)          if (file_exists) then             r = OS_FREEBSD             ret = r             return         end if     end function get_os_type                     logical function os_is_unix(os)         integer, intent(in), optional :: os         integer :: build_os         if (present(os)) then             build_os = os         else             build_os = get_os_type()         end if         os_is_unix = build_os /= OS_WINDOWS     end function os_is_unix                function get_env(NAME,     implicit none          character(len=*),intent(in)          :: NAME          character(len=*),intent(in),optional ::           character(len=:),allocatable         :: VALUE     integer                              :: howbig     integer                              :: stat     integer                              :: length                  length=0         if(NAME/='')then            call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)            select case (stat)            case (1)                                VALUE=''            case (2)                                VALUE=''            case default                                allocate(character(len=max(howbig,1)) :: VALUE)                                call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)                if(stat/=0)VALUE=''            end select         else            VALUE=''         endif         if(VALUE==''.and.present(      end function get_env      function get_command_arguments_quoted() result(args)     character(len=:),allocatable :: args     character(len=:),allocatable :: arg     character(len=1)             :: quote     integer                      :: ilength, istatus, i     ilength=0     args=''         quote=merge('"',"'",separator()=='\')         do i=2,command_argument_count()              call get_command_argument(number=i,length=ilength,status=istatus)             if(istatus /= 0) then                 write(stderr,'(*(g0,1x))')'<ERROR>*get_command_arguments_stack* error obtaining argument ',i                 exit             else                 if(allocated(arg))deallocate(arg)                 allocate(character(len=ilength) :: arg)                 call get_command_argument(number=i,value=arg,length=ilength,status=istatus)                 if(istatus /= 0) then                     write(stderr,'(*(g0,1x))')'<ERROR>*get_command_arguments_stack* error obtaining argument ',i                     exit                 elseif(ilength>0)then                     if(index(arg//' ','-')/=1)then                         args=args//quote//arg//quote//' '                     elseif(index(arg,' ')/=0)then                         args=args//quote//arg//quote//' '                     else                         args=args//arg//' '                     endif                 else                     args=args//repeat(quote,2)//' '                 endif              endif          enddo     end function get_command_arguments_quoted  function separator() result(sep)                                   implicit none character(len=:),allocatable :: arg0 integer                      :: arg0_length integer                      :: istat logical                      :: existing character(len=1)             :: sep  character(len=4096)          :: name character(len=:),allocatable :: fname                      arg0_length=0    name=' '    call get_command_argument(0,length=arg0_length,status=istat)    if(allocated(arg0))deallocate(arg0)    allocate(character(len=arg0_length) :: arg0)    call get_command_argument(0,arg0,status=istat)        if(index(arg0,'\')/=0)then       sep='\'    elseif(index(arg0,'/')/=0)then       sep='/'    else              existing=.false.       name=' '       inquire(file=arg0,iostat=istat,exist=existing,name=name)       if(index(name,'\')/=0)then          sep='\'       elseif(index(name,'/')/=0)then          sep='/'       else                    fname='.\'//arg0          inquire(file=fname,iostat=istat,exist=existing)          if(existing)then             sep='\'          else             fname='./'//arg0             inquire(file=fname,iostat=istat,exist=existing)             if(existing)then                sep='/'             else                 sep=merge('\','/',index(get_env('PATH'),'\')/=0)                             endif          endif       endif    endif     end function separator end module fpm_environment 
fpm_environment.f90_comments !> This module contains procedures that interact with the programming environment. !! !! * [get_os_type] -- Determine the OS type !! * [get_env] -- return the value of an environment variable module fpm_environment     use,intrinsic :: iso_fortran_env, only : stdin=>input_unit,   &                                            & stdout=>output_unit, &                                            & stderr=>error_unit     use fpm_error, only : fpm_stop     implicit none     private     public :: get_os_type     public :: os_is_unix     public :: get_env     public :: get_command_arguments_quoted     public :: separator      integer, parameter, public :: OS_UNKNOWN = 0     integer, parameter, public :: OS_LINUX   = 1     integer, parameter, public :: OS_MACOS   = 2     integer, parameter, public :: OS_WINDOWS = 3     integer, parameter, public :: OS_CYGWIN  = 4     integer, parameter, public :: OS_SOLARIS = 5     integer, parameter, public :: OS_FREEBSD = 6     integer, parameter, public :: OS_OPENBSD = 7 contains     !> Determine the OS type     integer function get_os_type() result(r)         !!         !! Returns one of OS_UNKNOWN, OS_LINUX, OS_MACOS, OS_WINDOWS, OS_CYGWIN,         !! OS_SOLARIS, OS_FREEBSD, OS_OPENBSD.         !!         !! At first, the environment variable `OS` is checked, which is usually         !! found on Windows. Then, `OSTYPE` is read in and compared with common         !! names. If this fails too, check the existence of files that can be         !! found on specific system types only.         !!         !! Returns OS_UNKNOWN if the operating system cannot be determined.         character(len=255) :: val         integer            :: length, rc         logical            :: file_exists         logical, save      :: first_run = .true.         integer, save      :: ret = OS_UNKNOWN         !$omp threadprivate(ret, first_run)          if (.not. first_run) then             r = ret             return         end if          first_run = .false.         r = OS_UNKNOWN          ! Check environment variable `OSTYPE`.         call get_environment_variable('OSTYPE', val, length, rc)          if (rc == 0 .and. length > 0) then             ! Linux             if (index(val, 'linux') > 0) then                 r = OS_LINUX                 ret = r                 return             end if              ! macOS             if (index(val, 'darwin') > 0) then                 r = OS_MACOS                 ret = r                 return             end if              ! Windows, MSYS, MinGW, Git Bash             if (index(val, 'win') > 0 .or. index(val, 'msys') > 0) then                 r = OS_WINDOWS                 ret = r                 return             end if              ! Cygwin             if (index(val, 'cygwin') > 0) then                 r = OS_CYGWIN                 ret = r                 return             end if              ! Solaris, OpenIndiana, ...             if (index(val, 'SunOS') > 0 .or. index(val, 'solaris') > 0) then                 r = OS_SOLARIS                 ret = r                 return             end if              ! FreeBSD             if (index(val, 'FreeBSD') > 0 .or. index(val, 'freebsd') > 0) then                 r = OS_FREEBSD                 ret = r                 return             end if              ! OpenBSD             if (index(val, 'OpenBSD') > 0 .or. index(val, 'openbsd') > 0) then                 r = OS_OPENBSD                 ret = r                 return             end if         end if          ! Check environment variable `OS`.         call get_environment_variable('OS', val, length, rc)          if (rc == 0 .and. length > 0 .and. index(val, 'Windows_NT') > 0) then             r = OS_WINDOWS             ret = r             return         end if          ! Linux         inquire (file='/etc/os-release', exist=file_exists)          if (file_exists) then             r = OS_LINUX             ret = r             return         end if          ! macOS         inquire (file='/usr/bin/sw_vers', exist=file_exists)          if (file_exists) then             r = OS_MACOS             ret = r             return         end if          ! FreeBSD         inquire (file='/bin/freebsd-version', exist=file_exists)          if (file_exists) then             r = OS_FREEBSD             ret = r             return         end if     end function get_os_type      !> Compare the output of [[get_os_type]] or the optional     !! passed INTEGER value to the value for OS_WINDOWS     !! and return .TRUE. if they match and .FALSE. otherwise     logical function os_is_unix(os)         integer, intent(in), optional :: os         integer :: build_os         if (present(os)) then             build_os = os         else             build_os = get_os_type()         end if         os_is_unix = build_os /= OS_WINDOWS     end function os_is_unix      !> get named environment variable value. It it is blank or     !! not set return the optional default value     function get_env(NAME,DEFAULT) result(VALUE)     implicit none     !> name of environment variable to get the value of     character(len=*),intent(in)          :: NAME     !> default value to return if the requested value is undefined or blank     character(len=*),intent(in),optional :: DEFAULT     !> the returned value     character(len=:),allocatable         :: VALUE     integer                              :: howbig     integer                              :: stat     integer                              :: length         ! get length required to hold value         length=0         if(NAME/='')then            call get_environment_variable(NAME, length=howbig,status=stat,trim_name=.true.)            select case (stat)            case (1)                !*!print *, NAME, " is not defined in the environment. Strange..."                VALUE=''            case (2)                !*!print *, "This processor doesn't support environment variables. Boooh!"                VALUE=''            case default                ! make string to hold value of sufficient size                allocate(character(len=max(howbig,1)) :: VALUE)                ! get value                call get_environment_variable(NAME,VALUE,status=stat,trim_name=.true.)                if(stat/=0)VALUE=''            end select         else            VALUE=''         endif         if(VALUE==''.and.present(DEFAULT))VALUE=DEFAULT      end function get_env      function get_command_arguments_quoted() result(args)     character(len=:),allocatable :: args     character(len=:),allocatable :: arg     character(len=1)             :: quote     integer                      :: ilength, istatus, i     ilength=0     args=''         quote=merge('"',"'",separator()=='\')         do i=2,command_argument_count() ! look at all arguments after subcommand             call get_command_argument(number=i,length=ilength,status=istatus)             if(istatus /= 0) then                 write(stderr,'(*(g0,1x))')'<ERROR>*get_command_arguments_stack* error obtaining argument ',i                 exit             else                 if(allocated(arg))deallocate(arg)                 allocate(character(len=ilength) :: arg)                 call get_command_argument(number=i,value=arg,length=ilength,status=istatus)                 if(istatus /= 0) then                     write(stderr,'(*(g0,1x))')'<ERROR>*get_command_arguments_stack* error obtaining argument ',i                     exit                 elseif(ilength>0)then                     if(index(arg//' ','-')/=1)then                         args=args//quote//arg//quote//' '                     elseif(index(arg,' ')/=0)then                         args=args//quote//arg//quote//' '                     else                         args=args//arg//' '                     endif                 else                     args=args//repeat(quote,2)//' '                 endif              endif          enddo     end function get_command_arguments_quoted  function separator() result(sep) !> !!##NAME !!    separator(3f) - [M_io:ENVIRONMENT] try to determine pathname directory separator character !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function separator() result(sep) !! !!     character(len=1) :: sep !! !!##DESCRIPTION !!    First using the name the program was invoked with, then the name !!    returned by an INQUIRE(3f) of that name, then ".\NAME" and "./NAME" !!    try to determine the separator character used to separate directory !!    names from file basenames. !! !!    If a slash or backslash is not found in the name, the environment !!    variable PATH is examined first for a backslash, then a slash. !! !!    Can be very system dependent. If the queries fail the default returned !!    is "/". !! !!##EXAMPLE !! !!   sample usage !! !!    program demo_separator !!    use M_io, only : separator !!    implicit none !!       write(*,*)'separator=',separator() !!    end program demo_separator  ! use the pathname returned as arg0 to determine pathname separator implicit none character(len=:),allocatable :: arg0 integer                      :: arg0_length integer                      :: istat logical                      :: existing character(len=1)             :: sep !*ifort_bug*!character(len=1),save        :: sep_cache=' ' character(len=4096)          :: name character(len=:),allocatable :: fname     !*ifort_bug*!   if(sep_cache/=' ')then  ! use cached value. NOTE:  A parallel code might theoretically use multiple OS    !*ifort_bug*!      sep=sep_cache    !*ifort_bug*!      return    !*ifort_bug*!   endif     arg0_length=0    name=' '    call get_command_argument(0,length=arg0_length,status=istat)    if(allocated(arg0))deallocate(arg0)    allocate(character(len=arg0_length) :: arg0)    call get_command_argument(0,arg0,status=istat)    ! check argument name    if(index(arg0,'\')/=0)then       sep='\'    elseif(index(arg0,'/')/=0)then       sep='/'    else       ! try name returned by INQUIRE(3f)       existing=.false.       name=' '       inquire(file=arg0,iostat=istat,exist=existing,name=name)       if(index(name,'\')/=0)then          sep='\'       elseif(index(name,'/')/=0)then          sep='/'       else          ! well, try some common syntax and assume in current directory          fname='.\'//arg0          inquire(file=fname,iostat=istat,exist=existing)          if(existing)then             sep='\'          else             fname='./'//arg0             inquire(file=fname,iostat=istat,exist=existing)             if(existing)then                sep='/'             else ! check environment variable PATH                sep=merge('\','/',index(get_env('PATH'),'\')/=0)                !*!write(*,*)'<WARNING>unknown system directory path separator'             endif          endif       endif    endif    !*ifort_bug*!sep_cache=sep end function separator end module fpm_environment 
fpm_meta.f90_stripped                   module fpm_meta use fpm_strings, only: string_t, len_trim, remove_newline_characters, str_begins_with_str, &                        str_ends_with use fpm_error, only: error_t, fatal_error, syntax_error, fpm_stop use fpm_compiler use fpm_model use fpm_command_line use fpm_manifest_dependency, only: dependency_config_t use fpm_git, only : git_target_branch, git_target_tag use fpm_manifest, only: package_config_t use fpm_environment, only: get_env,os_is_unix use fpm_filesystem, only: run, get_temp_filename, getline, exists, canon_path, is_dir, get_dos_path use fpm_versioning, only: version_t, new_version, regex_version_from_text use fpm_os, only: get_absolute_path use shlex_module, only: shlex_split => split use regex_module, only: regex use iso_fortran_env, only: stdout => output_unit  implicit none  private  public :: resolve_metapackages   type, public :: metapackage_t           type(version_t), allocatable :: version      logical :: has_link_libraries   = .false.     logical :: has_link_flags       = .false.     logical :: has_build_flags      = .false.     logical :: has_fortran_flags    = .false.     logical :: has_c_flags          = .false.     logical :: has_cxx_flags        = .false.     logical :: has_include_dirs     = .false.     logical :: has_dependencies     = .false.     logical :: has_run_command      = .false.     logical :: has_external_modules = .false.           type(string_t) :: flags     type(string_t) :: fflags     type(string_t) :: cflags     type(string_t) :: cxxflags     type(string_t) :: link_flags     type(string_t) :: run_command     type(string_t), allocatable :: incl_dirs(:)     type(string_t), allocatable :: link_libs(:)     type(string_t), allocatable :: external_modules(:)           type(fortran_features_t), allocatable :: fortran                type(dependency_config_t), allocatable :: dependency(:)      contains                 procedure :: destroy                 procedure :: new => init_from_name                 procedure, private :: resolve_cmd        procedure, private :: resolve_model        procedure, private :: resolve_package_config        generic :: resolve => resolve_cmd,resolve_model,resolve_package_config  end type metapackage_t  interface resolve_metapackages     module procedure resolve_metapackage_model end interface resolve_metapackages  integer, parameter :: MPI_TYPE_NONE    = 0 integer, parameter :: MPI_TYPE_OPENMPI = 1 integer, parameter :: MPI_TYPE_MPICH   = 2 integer, parameter :: MPI_TYPE_INTEL   = 3 integer, parameter :: MPI_TYPE_MSMPI   = 4 public             :: MPI_TYPE_NAME   logical, parameter, private :: verbose = .false.  integer, parameter, private :: LANG_FORTRAN = 1 integer, parameter, private :: LANG_C       = 2 integer, parameter, private :: LANG_CXX     = 3  character(*), parameter :: LANG_NAME(*) = [character(7) :: 'Fortran','  contains   pure function MPI_TYPE_NAME(mpilib) result(name)    integer, intent(in) :: mpilib    character(len=:), allocatable :: name    select case (mpilib)       case (MPI_TYPE_NONE);    name = "none"       case (MPI_TYPE_OPENMPI); name = "OpenMPI"       case (MPI_TYPE_MPICH);   name = "MPICH"       case (MPI_TYPE_INTEL);   name = "INTELMPI"       case (MPI_TYPE_MSMPI);   name = "MS-MPI"       case default;            name = "UNKNOWN"    end select end function MPI_TYPE_NAME   elemental subroutine destroy(this)    class(metapackage_t), intent(inout) :: this     this%has_link_libraries   = .false.    this%has_link_flags       = .false.    this%has_build_flags      = .false.    this%has_fortran_flags    = .false.    this%has_c_flags          = .false.    this%has_cxx_flags        = .false.    this%has_include_dirs     = .false.    this%has_dependencies     = .false.    this%has_run_command      = .false.    this%has_external_modules = .false.     if (allocated(this%fortran)) deallocate(this%fortran)    if (allocated(this%version)) deallocate(this%version)    if (allocated(this%flags%s)) deallocate(this%flags%s)    if (allocated(this%fflags%s)) deallocate(this%fflags%s)    if (allocated(this%cflags%s)) deallocate(this%cflags%s)    if (allocated(this%cxxflags%s)) deallocate(this%cxxflags%s)    if (allocated(this%link_flags%s)) deallocate(this%link_flags%s)    if (allocated(this%run_command%s)) deallocate(this%run_command%s)    if (allocated(this%link_libs)) deallocate(this%link_libs)    if (allocated(this%dependency)) deallocate(this%dependency)    if (allocated(this%incl_dirs)) deallocate(this%incl_dirs)    if (allocated(this%external_modules)) deallocate(this%external_modules)  end subroutine destroy   subroutine init_from_name(this,name,compiler,error)     class(metapackage_t), intent(inout) :: this     character(*), intent(in) :: name     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error           select case(name)         case("openmp");  call init_openmp (this,compiler,error)         case("stdlib");  call init_stdlib (this,compiler,error)         case("minpack"); call init_minpack(this,compiler,error)         case("mpi");     call init_mpi    (this,compiler,error)         case default             call syntax_error(error, "Package "//name//" is not supported in [metapackages]")             return     end select  end subroutine init_from_name   subroutine init_openmp(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error           call destroy(this)           this%has_build_flags = .true.     this%has_link_flags  = .true.           which_compiler: select case (compiler%id)        case (id_gcc,id_f95)             this%flags      = string_t(flag_gnu_openmp)             this%link_flags = string_t(flag_gnu_openmp)         case (id_intel_classic_windows,id_intel_llvm_windows)             this%flags      = string_t(flag_intel_openmp_win)             this%link_flags = string_t(flag_intel_openmp_win)         case (id_intel_classic_nix,id_intel_classic_mac,&              id_intel_llvm_nix)             this%flags      = string_t(flag_intel_openmp)             this%link_flags = string_t(flag_intel_openmp)         case (id_pgi,id_nvhpc)             this%flags      = string_t(flag_pgi_openmp)             this%link_flags = string_t(flag_pgi_openmp)         case (id_ibmxl)             this%flags      = string_t(" -qsmp=omp")             this%link_flags = string_t(" -qsmp=omp")         case (id_nag)             this%flags      = string_t(flag_nag_openmp)             this%link_flags = string_t(flag_nag_openmp)         case (id_lfortran)             this%flags      = string_t(flag_lfortran_openmp)             this%link_flags = string_t(flag_lfortran_openmp)         case default            call fatal_error(error,'openmp not supported on compiler '//compiler%name()//' yet')      end select which_compiler   end subroutine init_openmp   subroutine init_minpack(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error           call destroy(this)           this%has_dependencies = .true.      allocate(this%dependency(1))           this%dependency(1)%name = "minpack"     this%dependency(1)%git = git_target_tag("https://github.com/fortran-lang/minpack", "v2.0.0-rc.1")     if (.not.allocated(this%dependency(1)%git)) then         call fatal_error(error,'cannot initialize git repo dependency for minpack metapackage')         return     end if  end subroutine init_minpack   subroutine init_stdlib(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error           call destroy(this)           this%has_dependencies = .true.      allocate(this%dependency(2))           this%dependency(1)%name = "test-drive"     this%dependency(1)%git = git_target_branch("https://github.com/fortran-lang/test-drive","v0.4.0")     if (.not.allocated(this%dependency(1)%git)) then         call fatal_error(error,'cannot initialize test-drive git dependency for stdlib metapackage')         return     end if           this%dependency(2)%name = "stdlib"     this%dependency(2)%git = git_target_branch("https://github.com/fortran-lang/stdlib","stdlib-fpm")     if (.not.allocated(this%dependency(2)%git)) then         call fatal_error(error,'cannot initialize git repo dependency for stdlib metapackage')         return     end if  end subroutine init_stdlib   subroutine resolve_cmd(self,settings,error)     class(metapackage_t), intent(in) :: self     class(fpm_cmd_settings), intent(inout) :: settings     type(error_t), allocatable, intent(out) :: error           if (self%has_run_command) then          select type (cmd=>settings)            class is (fpm_run_settings)                                if (.not.len_trim(cmd%runner)>0) cmd%runner = self%run_command%s          end select      endif  end subroutine resolve_cmd   subroutine resolve_model(self,model,error)     class(metapackage_t), intent(in) :: self     type(fpm_model_t), intent(inout) :: model     type(error_t), allocatable, intent(out) :: error           if (self%has_build_flags) then         model%fortran_compile_flags = model%fortran_compile_flags//self%flags%s         model%c_compile_flags       = model%c_compile_flags//self%flags%s         model%cxx_compile_flags     = model%cxx_compile_flags//self%flags%s     endif           if (self%has_fortran_flags) model%fortran_compile_flags = model%fortran_compile_flags//self%fflags%s     if (self%has_c_flags)       model%c_compile_flags       = model%c_compile_flags//self%cflags%s     if (self%has_cxx_flags)     model%cxx_compile_flags     = model%cxx_compile_flags//self%cxxflags%s      if (self%has_link_flags) then         model%link_flags            = model%link_flags//self%link_flags%s     end if      if (self%has_link_libraries) then         model%link_libraries        = [model%link_libraries,self%link_libs]     end if      if (self%has_include_dirs) then         model%include_dirs          = [model%include_dirs,self%incl_dirs]     end if      if (self%has_external_modules) then         model%external_modules      = [model%external_modules,self%external_modules]     end if  end subroutine resolve_model  subroutine resolve_package_config(self,package,error)     class(metapackage_t), intent(in) :: self     type(package_config_t), intent(inout) :: package     type(error_t), allocatable, intent(out) :: error                if (self%has_dependencies) then         if (allocated(package%dev_dependency)) then            package%dev_dependency = [package%dev_dependency,self%dependency]         else            package%dev_dependency = self%dependency         end if     end if           if (allocated(self%fortran)) then          if (self%fortran%implicit_external.neqv.package%fortran%implicit_external) then             call fatal_error(error,'metapackage fortran error: metapackage '// &                                    dn(self%fortran%implicit_external)//' require implicit-external, main package '//&                                    dn(package%fortran%implicit_external))             return         end if          if (self%fortran%implicit_typing.neqv.package%fortran%implicit_typing) then             call fatal_error(error,'metapackage fortran error: metapackage '// &                                    dn(self%fortran%implicit_external)//' require implicit-typing, main package '//&                                    dn(package%fortran%implicit_external))             return         end if      end if      contains      pure function dn(bool)        logical, intent(in) :: bool        character(len=:), allocatable :: dn        if (bool) then           dn = "does"        else           dn = "does not"        end if     end function dn   end subroutine resolve_package_config   subroutine add_metapackage_model(model,package,settings,name,error)     type(fpm_model_t), intent(inout) :: model     type(package_config_t), intent(inout) :: package     class(fpm_cmd_settings), intent(inout) :: settings     character(*), intent(in) :: name     type(error_t), allocatable, intent(out) :: error      type(metapackage_t) :: meta           call meta%new(name,model%compiler,error)     if (allocated(error)) return           call meta%resolve(model,error)     if (allocated(error)) return           call meta%resolve(package,error)     if (allocated(error)) return           call meta%resolve(settings,error)     if (allocated(error)) return           if (name=="mpi") then         select type (settings)            class is (fpm_run_settings)                if (.not.meta%has_run_command) &               call fatal_error(error,"cannot find a valid mpi runner on the local host")         end select     endif  end subroutine add_metapackage_model   subroutine resolve_metapackage_model(model,package,settings,error)     type(fpm_model_t), intent(inout) :: model     type(package_config_t), intent(inout) :: package     class(fpm_build_settings), intent(inout) :: settings     type(error_t), allocatable, intent(out) :: error                     if (model%compiler%is_unknown()) &     write(stdout,'(a)') '<WARNING> compiler not initialized: metapackages may not be available'           if (package%meta%openmp%on) then         call add_metapackage_model(model,package,settings,"openmp",error)         if (allocated(error)) return     endif           if (package%meta%stdlib%on) then         call add_metapackage_model(model,package,settings,"stdlib",error)         if (allocated(error)) return     endif           if (package%meta%minpack%on) then         call add_metapackage_model(model,package,settings,"minpack",error)         if (allocated(error)) return     endif            if (package%meta%stdlib%on .and. package%meta%openmp%on) then         write(stdout,'(a)')'<WARNING> both openmp and stdlib requested: some functions may not be thread-safe     end if           if (package%meta%mpi%on) then         call add_metapackage_model(model,package,settings,"mpi",error)         if (allocated(error)) return     endif  end subroutine resolve_metapackage_model   subroutine init_mpi(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error       type(string_t), allocatable :: c_wrappers(:),cpp_wrappers(:),fort_wrappers(:)     type(string_t) :: output,fwrap,cwrap,cxxwrap     character(256) :: msg_out     character(len=:), allocatable :: tokens(:)     integer :: wcfit(3),mpilib(3),ic,icpp,i     logical :: found           call destroy(this)           call mpi_wrappers(compiler,fort_wrappers,c_wrappers,cpp_wrappers)     if (verbose) print 1, size(fort_wrappers),size(c_wrappers),size(cpp_wrappers)      call wrapper_compiler_fit(fort_wrappers,c_wrappers,cpp_wrappers,compiler,wcfit,mpilib,error)      if (allocated(error) .or. all(wcfit==0)) then                   found = msmpi_init(this,compiler,error)         if (allocated(error)) return                   if (.not.found) then             call fatal_error(error,"cannot find MPI wrappers or libraries for "//compiler%name()//" compiler")             return         endif      else          if (wcfit(LANG_FORTRAN)>0) fwrap   = fort_wrappers(wcfit(LANG_FORTRAN))         if (wcfit(LANG_C)>0)       cwrap   = c_wrappers   (wcfit(LANG_C))         if (wcfit(LANG_CXX)>0)     cxxwrap = cpp_wrappers (wcfit(LANG_CXX))                                              if (wcfit(LANG_FORTRAN)>0 .and. all(wcfit([LANG_C,LANG_CXX])==0)) then             cwrap   = fort_wrappers(wcfit(LANG_FORTRAN))             cxxwrap = fort_wrappers(wcfit(LANG_FORTRAN))         end if          if (verbose) print *, '+ MPI fortran wrapper: ',fwrap%s         if (verbose) print *, '+ MPI c       wrapper: ',cwrap%s         if (verbose) print *, '+ MPI c++     wrapper: ',cxxwrap%s                   call init_mpi_from_wrappers(this,compiler,mpilib(LANG_FORTRAN),fwrap,cwrap,cxxwrap,error)         if (allocated(error)) return                   if (mpilib(LANG_FORTRAN)/=MPI_TYPE_INTEL) then             allocate(this%fortran)             this%fortran%implicit_typing   = .true.             this%fortran%implicit_external = .true.         endif      end if                this%has_external_modules = .true.     this%external_modules = [string_t("mpi"),string_t("mpi_f08")]      1 format('MPI wrappers found: fortran=',i0,' c=',i0,' c++=',i0)  end subroutine init_mpi    logical function is_64bit_environment()    use iso_c_binding, only: c_intptr_t    integer, parameter :: nbits = bit_size(0_c_intptr_t)    is_64bit_environment = nbits==64 end function is_64bit_environment   subroutine wrapper_compiler_fit(fort_wrappers,c_wrappers,cpp_wrappers,compiler,wrap,mpi,error)    type(string_t), allocatable, intent(in) :: fort_wrappers(:),c_wrappers(:),cpp_wrappers(:)    type(compiler_t), intent(in) :: compiler    type(error_t), allocatable, intent(out) :: error    integer, intent(out), dimension(3) :: wrap, mpi     type(error_t), allocatable :: wrap_error     wrap = 0    mpi  = MPI_TYPE_NONE     if (size(fort_wrappers)>0) &    call mpi_compiler_match(LANG_FORTRAN,fort_wrappers,compiler,wrap(LANG_FORTRAN),mpi(LANG_FORTRAN),wrap_error)     if (size(c_wrappers)>0) &    call mpi_compiler_match(LANG_C,c_wrappers,compiler,wrap(LANG_C),mpi(LANG_C),wrap_error)     if (size(cpp_wrappers)>0) &    call mpi_compiler_match(LANG_CXX,cpp_wrappers,compiler,wrap(LANG_CXX),mpi(LANG_CXX),wrap_error)         if (all(wrap==0)) then         call fatal_error(error,'no valid wrappers match current compiler, '//compiler_name(compiler))         return    end if  end subroutine wrapper_compiler_fit   logical function msmpi_init(this,compiler,error) result(found)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      character(len=:), allocatable :: incdir,windir,libdir,bindir,post,reall,msysdir     type(version_t) :: ver,ver10     type(string_t) :: cpath,msys_path,runner_path     logical :: msys2           found = .false.      if (get_os_type()==OS_WINDOWS) then                   is_minGW: if (compiler%id==id_gcc) then              call compiler_get_version(compiler,ver,msys2,error)             if (allocated(error)) return          endif is_minGW                   if (is_64bit_environment()) then             libdir = get_env('MSMPI_LIB64')             post   = 'x64'         else             libdir = get_env('MSMPI_LIB32')             post   = 'x86'                           call fatal_error(error,'MS-MPI error: this package requires 64-bit Windows environment')             return          end if                   bindir = ""         call get_absolute_path(get_env('MSMPI_BIN'),bindir,error)         if (verbose) print *, '+ %MSMPI_BIN%=',bindir                            if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching              call get_absolute_path('         endif                   if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching /c/Program Files/Microsoft MPI/Bin/ ...'             call get_absolute_path('/c/Program Files/Microsoft MPI/Bin/mpiexec.exe',bindir,error)         endif                   if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+               call get_mpi_runner(runner_path,verbose,error)              if (.not.allocated(error)) then                if (verbose) print *, '+ mpiexec found: ',runner_path%s                call find_command_location(runner_path%s,bindir,verbose=verbose,error=error)             endif          endif          if (allocated(error)) then             call fatal_error(error,'MS-MPI error: MS-MPI Runtime directory is missing. '//&                                    'check environment variable %MSMPI_BIN% or that the folder is in %PATH%.')             return         end if                   found = .true.                   call destroy(this)                   use_prebuilt: if (msys2) then                           call compiler_get_path(compiler,cpath,error)             if (allocated(error)) return              call get_absolute_path(join_path(cpath%s,'..'),msys_path%s,error)             if (allocated(error)) return              call get_absolute_path(join_path(msys_path%s,'include'),incdir,error)             if (allocated(error)) return              call get_absolute_path(join_path(msys_path%s,'lib'),libdir,error)             if (allocated(error)) return              if (verbose) print 1, 'include',incdir,exists(incdir)             if (verbose) print 1, 'library',libdir,exists(libdir)                           call get_absolute_path(join_path(libdir,'libmsmpi.dll.a'),post,error)             if (allocated(error)) return              if (len_trim(post)<=0 .or. .not.exists(post)) then                 call fatal_error(error,'MS-MPI available through the MSYS2 system not found. '// &                                        'Run <pacman -Sy mingw64/mingw-w64-x86_64-msmpi> '// &                                        'or your system-specific version to install.')                 return             end if                           this%has_link_flags = .true.             this%link_flags = string_t(' -L'//get_dos_path(libdir,error))              this%has_link_libraries = .true.             this%link_libs = [string_t('msmpi.dll')]              if (allocated(error)) return              this%has_include_dirs = .true.             this%incl_dirs = [string_t(get_dos_path(incdir,error))]             if (allocated(error)) return          else              call fatal_error(error,'MS-MPI cannot work with non-MSYS2 GNU compilers yet')             return                           this%has_link_flags = .true.             this%link_flags = string_t(' -L'//get_dos_path(libdir,error))              this%has_link_libraries = .true.             this%link_libs = [string_t('msmpi'),string_t('msmpifec'),string_t('msmpifmc')]              if (allocated(error)) return              this%has_include_dirs = .true.             this%incl_dirs = [string_t(get_dos_path(incdir,error)), &                               string_t(get_dos_path(incdir//post,error))]             if (allocated(error)) return           end if use_prebuilt                   allocate(this%fortran)         this%fortran%implicit_typing = .true.         this%fortran%implicit_external = .true.                            allow_BOZ: if (compiler%id==id_gcc) then              call new_version(ver10,'10.0.0',error)             if (allocated(error)) return              if (ver>=ver10) then                 this%has_build_flags = .true.                 this%flags = string_t(' -fallow-invalid-boz')             end if          endif allow_BOZ                   this%has_run_command = .true.         this%run_command = string_t(join_path(get_dos_path(bindir,error),'mpiexec.exe')//' -np * ')      else                   found = .false.      end if      1 format('MSMSPI ',a,' directory: PATH=',a,' EXISTS=',l1)  end function msmpi_init   logical function wsl_shell()     if (get_os_type()==OS_WINDOWS) then         wsl_shell = exists('/proc/sys/fs/binfmt_misc/WSLInterop')     else         wsl_shell = .false.     endif end function wsl_shell   subroutine find_command_location(command,path,echo,verbose,error)     character(*), intent(in) :: command     character(len=:), allocatable, intent(out) :: path     logical, optional, intent(in) :: echo,verbose     type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: tmp_file,screen_output,line,fullpath,search_command     integer :: stat,iunit,ire,length,try     character(*), parameter :: search(2) = ["where ","which "]      if (len_trim(command)<=0) then         call fatal_error(error,'empty command provided in find_command_location')         return     end if      tmp_file = get_temp_filename()           do try=merge(1,2,get_os_type()==OS_WINDOWS),2        search_command = search(try)//command        call run(search_command, echo=echo, exitstat=stat, verbose=verbose, redirect=tmp_file)        if (stat==0) exit     end do     if (stat/=0) then         call fatal_error(error,'find_command_location failed for '//command)         return     end if           allocate(character(len=0) :: screen_output)     open(newunit=iunit,file=tmp_file,status='old',iostat=stat)     if (stat == 0)then        do            call getline(iunit, line, stat)            if (stat /= 0) exit            if (len(screen_output)>0) then                 screen_output = screen_output//new_line('a')//line            else                 screen_output = line            endif        end do                close(iunit,status='delete')     else        call fatal_error(error,'cannot read temporary file from successful find_command_location')        return     endif           length = index(screen_output,new_line('a'))      multiline: if (length>1) then         fullpath = screen_output(1:length-1)     else         fullpath = screen_output     endif multiline     if (len_trim(fullpath)<1) then         call fatal_error(error,'no paths found to command ('//command//')')         return     end if           length = index(fullpath,command,BACK=.true.)     if (length<=0) then         call fatal_error(error,'full path to command ('//command//') does not include command name')         return     elseif (length==1) then                  path = '.'     else         path = fullpath(1:length-1)     end if     if (allocated(error)) return           if (get_os_type()==OS_WINDOWS) path = get_dos_path(path,error)      if (allocated(error) .or. .not.is_dir(path)) then         call fatal_error(error,'full path ('//path//') to command ('//command//') is not a directory')         return     end if  end subroutine find_command_location   subroutine get_mpi_runner(command,verbose,error)     type(string_t), intent(out) :: command     logical, intent(in) :: verbose     type(error_t), allocatable, intent(out) :: error      character(*), parameter :: try(*) = ['mpiexec    ','mpirun     ','mpiexec.exe','mpirun.exe ']     character(:), allocatable :: bindir     integer :: itri     logical :: success           do itri=1,size(try)        call find_command_location(trim(try(itri)),command%s,verbose=verbose,error=error)        if (allocated(error)) cycle                 success = len_trim(command%s)>0        if (success) then            if (verbose) print *, '+ runner folder found: '//command%s            command%s = join_path(command%s,trim(try(itri)))            return        endif     end do           if (get_os_type()==OS_WINDOWS) then                  bindir = ""         call get_absolute_path(get_env('MSMPI_BIN'),bindir,error)         if (verbose) print *, '+ %MSMPI_BIN%=',bindir                           if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching              call get_absolute_path('         endif         if (len_trim(bindir)>0 .and. .not.allocated(error)) then                          command%s = join_path(bindir,'mpiexec.exe')             return         endif     endif           call fatal_error(error,'cannot find a valid mpi runner command')     return  end subroutine get_mpi_runner   subroutine compiler_get_path(self,path,error)     type(compiler_t), intent(in) :: self     type(string_t), intent(out) :: path     type(error_t), allocatable, intent(out) :: error      call find_command_location(self%fc,path%s,self%echo,self%verbose,error)  end subroutine compiler_get_path   subroutine compiler_get_version(self,version,is_msys2,error)     type(compiler_t), intent(in) :: self     type(version_t), intent(out) :: version     logical, intent(out) :: is_msys2     type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: tmp_file,screen_output,line     type(string_t) :: ver     integer :: stat,iunit,ire,length      is_msys2 = .false.      select case (self%id)        case (id_gcc)              tmp_file = get_temp_filename()              call run(self%fc // " --version ", echo=self%echo, verbose=self%verbose, redirect=tmp_file, exitstat=stat)             if (stat/=0) then                 call fatal_error(error,'compiler_get_version failed for '//self%fc)                 return             end if              allocate(character(len=0) :: screen_output)             open(newunit=iunit,file=tmp_file,status='old',iostat=stat)             if (stat == 0)then                do                    call getline(iunit, line, stat)                    if (stat /= 0) exit                    screen_output = screen_output//' '//line//' '                end do                                close(iunit,status='delete')             else                call fatal_error(error,'cannot read temporary file from successful compiler_get_version')                return             endif                           is_msys2 = index(screen_output,'MSYS2')>0              ver = regex_version_from_text(screen_output,self%fc//' compiler',error)             if (allocated(error)) return                           call new_version(version,ver%s,error)          case default             call fatal_error(error,'compiler_get_version not yet implemented for compiler '//self%fc)             return     end select  end subroutine compiler_get_version   subroutine init_mpi_from_wrappers(this,compiler,mpilib,fort_wrapper,c_wrapper,cxx_wrapper,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     integer, intent(in) :: mpilib     type(string_t), intent(in) :: fort_wrapper,c_wrapper,cxx_wrapper     type(error_t), allocatable, intent(out) :: error      type(version_t) :: version     type(error_t), allocatable :: runner_error           call destroy(this)           this%link_flags = mpi_wrapper_query(mpilib,fort_wrapper,'link',verbose,error)     if (allocated(error)) return           call filter_link_arguments(compiler,this%link_flags)      this%has_link_flags = len_trim(this%link_flags)>0           if (this%has_link_flags .and. compiler%is_gnu() .and. os_is_unix() .and. get_os_type()/=OS_MACOS) then         this%link_flags = string_t(' -Wl,--start-group '//this%link_flags%s)     end if           call set_language_flags(compiler,mpilib,fort_wrapper,this%has_fortran_flags,this%fflags,verbose,error)     if (allocated(error)) return     call set_language_flags(compiler,mpilib,c_wrapper,this%has_c_flags,this%cflags,verbose,error)     if (allocated(error)) return     call set_language_flags(compiler,mpilib,cxx_wrapper,this%has_cxx_flags,this%cxxflags,verbose,error)     if (allocated(error)) return           version = mpi_version_get(mpilib,fort_wrapper,error)     if (allocated(error)) then        return     else        allocate(this%version,source=version)     end if           this%run_command = mpi_wrapper_query(mpilib,fort_wrapper,'runner',verbose,runner_error)     this%has_run_command = (len_trim(this%run_command)>0) .and. .not.allocated(runner_error)      contains      subroutine set_language_flags(compiler,mpilib,wrapper,has_flags,flags,verbose,error)         type(compiler_t), intent(in) :: compiler         integer, intent(in) :: mpilib         type(string_t), intent(in) :: wrapper         logical, intent(inout) :: has_flags         type(string_t), intent(inout) :: flags         logical, intent(in) :: verbose         type(error_t), allocatable, intent(out) :: error                   if (len_trim(wrapper)>0) then             flags = mpi_wrapper_query(mpilib,wrapper,'flags',verbose,error)              if (allocated(error)) return             has_flags = len_trim(flags)>0                           flags = string_t(' '//flags%s)              if (verbose) print *, '+ MPI language flags from wrapper <',wrapper%s,'>: flags=',flags%s              call filter_build_arguments(compiler,flags)          endif      end subroutine set_language_flags  end subroutine init_mpi_from_wrappers   subroutine mpi_compiler_match(language,wrappers,compiler,which_one,mpilib,error)     integer, intent(in) :: language     type(string_t), intent(in) :: wrappers(:)     type(compiler_t), intent(in) :: compiler     integer, intent(out) :: which_one, mpilib     type(error_t), allocatable, intent(out) :: error      integer :: i, same_vendor, vendor_mpilib     type(string_t) :: screen     character(128) :: msg_out     type(compiler_t) :: mpi_compiler      which_one   = 0     same_vendor = 0     mpilib      = MPI_TYPE_NONE      if (verbose) print *, '+ Trying to match available ',LANG_NAME(language),' MPI wrappers to ',compiler%fc,'...'      do i=1,size(wrappers)          mpilib = which_mpi_library(wrappers(i),compiler,verbose=.false.)          screen = mpi_wrapper_query(mpilib,wrappers(i),'compiler',verbose=.false.,error=error)         if (allocated(error)) return          if (verbose) print *, '  Wrapper ',wrappers(i)%s,' lib=',MPI_TYPE_NAME(mpilib),' uses ',screen%s          select case (language)            case (LANG_FORTRAN)                                call new_compiler(mpi_compiler,screen%s,'','',echo=.true.,verbose=.false.)                                 if (mpi_compiler%id == compiler%id) then                    which_one = i                    return                end if            case (LANG_C)                                if (screen%s==compiler%cc .or. screen%s==compiler%fc) then                    which_one = i                    return                end if            case (LANG_CXX)                if (screen%s==compiler%cxx .or. screen%s==compiler%fc) then                    which_one = i                    return                end if         end select                            if (is_intel_classic_option(language,same_vendor,screen,compiler,mpi_compiler)) then             same_vendor = i             vendor_mpilib = mpilib         end if     end do           if (which_one==0 .and. same_vendor>0) then         which_one = same_vendor         mpilib    = vendor_mpilib     end if           write(msg_out,1) size(wrappers),compiler%fc     call fatal_error(error,trim(msg_out))     1 format('<ERROR> None out of ',i0,' valid MPI wrappers matches compiler ',a)  end subroutine mpi_compiler_match    logical function is_intel_classic_option(language,same_vendor_ID,screen_out,compiler,mpi_compiler)     integer, intent(in) :: language,same_vendor_ID     type(string_t), intent(in) :: screen_out     type(compiler_t), intent(in) :: compiler,mpi_compiler      if (same_vendor_ID/=0) then         is_intel_classic_option = .false.     else         select case (language)            case (LANG_FORTRAN)                is_intel_classic_option = mpi_compiler%is_intel() .and. compiler%is_intel()            case (LANG_C)                is_intel_classic_option = screen_out%s=='icc' .and. compiler%cc=='icx'            case (LANG_CXX)                is_intel_classic_option = screen_out%s=='icpc' .and. compiler%cc=='icpx'         end select     end if  end function is_intel_classic_option   type(version_t) function mpi_version_get(mpilib,wrapper,error)    integer, intent(in) :: mpilib    type(string_t), intent(in) :: wrapper    type(error_t), allocatable, intent(out) :: error     type(string_t) :: version_line         version_line = mpi_wrapper_query(mpilib,wrapper,'version',error=error)    if (allocated(error)) return         call new_version(mpi_version_get,version_line%s,error)  end function mpi_version_get   subroutine mpi_wrappers(compiler,fort_wrappers,c_wrappers,cpp_wrappers)     type(compiler_t), intent(in) :: compiler     type(string_t), allocatable, intent(out) :: c_wrappers(:),cpp_wrappers(:),fort_wrappers(:)      character(len=:), allocatable :: mpi_root,intel_wrap     type(error_t), allocatable :: error           c_wrappers    = [string_t(get_env('MPICC' ,'mpicc'))]     cpp_wrappers  = [string_t(get_env('MPICXX','mpic++'))]     fort_wrappers = [string_t(get_env('MPIFC' ,'mpifc' )),&                      string_t(get_env('MPIf90','mpif90')),&                      string_t(get_env('MPIf77','mpif77'))]      if (get_os_type()==OS_WINDOWS) then         c_wrappers = [c_wrappers,string_t('mpicc.bat')]         cpp_wrappers = [cpp_wrappers,string_t('mpicxx.bat')]         fort_wrappers = [fort_wrappers,string_t('mpifc.bat')]     endif           compiler_specific: select case (compiler%id)        case (id_gcc,id_f95)              c_wrappers = [c_wrappers,string_t('mpigcc'),string_t('mpgcc')]           cpp_wrappers = [cpp_wrappers,string_t('mpig++'),string_t('mpg++')]          fort_wrappers = [fort_wrappers,string_t('mpigfortran'),string_t('mpgfortran'),&                           string_t('mpig77'),string_t('mpg77')]         case (id_intel_classic_windows,id_intel_llvm_windows, &              id_intel_classic_nix,id_intel_classic_mac,id_intel_llvm_nix,id_intel_llvm_unknown)              c_wrappers = [string_t(get_env('I_MPI_CC','mpiicc'))]           cpp_wrappers = [string_t(get_env('I_MPI_CXX','mpiicpc'))]          fort_wrappers = [string_t(get_env('I_MPI_F90','mpiifort'))]                     mpi_root = get_env('I_MPI_ROOT')          if (mpi_root/="") then               mpi_root = join_path(mpi_root,'bin')               intel_wrap = join_path(mpi_root,'mpiifort')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") fort_wrappers = [fort_wrappers,string_t(intel_wrap)]               intel_wrap = join_path(mpi_root,'mpiicc')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") c_wrappers = [c_wrappers,string_t(intel_wrap)]               intel_wrap = join_path(mpi_root,'mpiicpc')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") cpp_wrappers = [cpp_wrappers,string_t(intel_wrap)]           end if         case (id_pgi,id_nvhpc)              c_wrappers = [c_wrappers,string_t('mpipgicc'),string_t('mpgcc')]           cpp_wrappers = [cpp_wrappers,string_t('mpipgic++')]          fort_wrappers = [fort_wrappers,string_t('mpipgifort'),string_t('mpipgf90')]         case (id_cray)              c_wrappers = [c_wrappers,string_t('cc')]           cpp_wrappers = [cpp_wrappers,string_t('          fort_wrappers = [fort_wrappers,string_t('ftn')]      end select compiler_specific      call assert_mpi_wrappers(fort_wrappers,compiler)     call assert_mpi_wrappers(c_wrappers,compiler)     call assert_mpi_wrappers(cpp_wrappers,compiler)  end subroutine mpi_wrappers   subroutine assert_mpi_wrappers(wrappers,compiler,verbose)     type(string_t), allocatable, intent(inout) :: wrappers(:)     type(compiler_t), intent(in) :: compiler     logical, optional, intent(in) :: verbose      integer :: i     integer, allocatable :: works(:)      allocate(works(size(wrappers)))      do i=1,size(wrappers)         if (present(verbose)) then             if (verbose) print *, '+ MPI test wrapper <',wrappers(i)%s,'>'         endif         works(i) = which_mpi_library(wrappers(i),compiler,verbose)     end do           wrappers = pack(wrappers,works/=MPI_TYPE_NONE)  end subroutine assert_mpi_wrappers   subroutine run_mpi_wrapper(wrapper,args,verbose,exitcode,cmd_success,screen_output)     type(string_t), intent(in) :: wrapper     type(string_t), intent(in), optional :: args(:)     logical, intent(in), optional :: verbose     integer, intent(out), optional :: exitcode     logical, intent(out), optional :: cmd_success     type(string_t), intent(out), optional :: screen_output      logical :: echo_local     character(:), allocatable :: redirect_str,command,redirect,line     integer :: iunit,iarg,stat,cmdstat       if(present(verbose))then        echo_local=verbose     else        echo_local=.false.     end if           if (present(screen_output)) then         redirect = get_temp_filename()         redirect_str =  ">"//redirect//" 2>&1"     else         if (os_is_unix()) then             redirect_str = " >/dev/null 2>&1"         else             redirect_str = " >NUL 2>&1"         end if     end if           if (len_trim(wrapper)<=0) then         if (echo_local) print *, '+ <EMPTY          if (present(exitcode)) exitcode = 0         if (present(cmd_success)) cmd_success = .true.         if (present(screen_output)) screen_output = string_t("")         return     end if           command = trim(wrapper%s)      add_arguments: if (present(args)) then         do iarg=1,size(args)             if (len_trim(args(iarg))<=0) cycle             command = trim(command)//' '//args(iarg)%s         end do     endif add_arguments      if (echo_local) print *, '+ ', command           call execute_command_line(command//redirect_str,exitstat=stat,cmdstat=cmdstat)           if (present(cmd_success)) cmd_success = cmdstat==0           if (present(exitcode)) exitcode = stat           if (present(screen_output) .and. cmdstat==0) then          allocate(character(len=0) :: screen_output%s)          open(newunit=iunit,file=redirect,status='old',iostat=stat)         if (stat == 0)then            do                call getline(iunit, line, stat)                if (stat /= 0) exit                 screen_output%s = screen_output%s//new_line('a')//line                 if (echo_local) write(*,'(A)') trim(line)            end do                         close(iunit,status='delete')          else            call fpm_stop(1,'cannot read temporary file from successful MPI wrapper')         endif      end if  end subroutine run_mpi_wrapper   integer function which_mpi_library(wrapper,compiler,verbose)     type(string_t), intent(in) :: wrapper     type(compiler_t), intent(in) :: compiler     logical, intent(in), optional :: verbose      logical :: is_mpi_wrapper     integer :: stat           which_mpi_library = MPI_TYPE_NONE      if (len_trim(wrapper)<=0) return           call run_mpi_wrapper(wrapper,verbose=verbose,cmd_success=is_mpi_wrapper)      if (is_mpi_wrapper) then          if (compiler%is_intel()) then             which_mpi_library = MPI_TYPE_INTEL             return         end if                             call run_mpi_wrapper(wrapper,[string_t('--showme')],verbose,&                              exitcode=stat,cmd_success=is_mpi_wrapper)         if (stat==0 .and. is_mpi_wrapper) then             which_mpi_library = MPI_TYPE_OPENMPI             return         endif                   call run_mpi_wrapper(wrapper,[string_t('-show')],verbose,&                              exitcode=stat,cmd_success=is_mpi_wrapper)         if (stat==0 .and. is_mpi_wrapper) then             which_mpi_library = MPI_TYPE_MPICH             return         endif      end if  end function which_mpi_library   type(string_t) function mpi_wrapper_query(mpilib,wrapper,command,verbose,error) result(screen)     integer, intent(in) :: mpilib     type(string_t), intent(in) :: wrapper     character(*), intent(in) :: command     logical, intent(in), optional :: verbose     type(error_t), allocatable, intent(out) :: error      logical :: success     character(:), allocatable :: redirect_str,tokens(:),unsupported_msg     type(string_t) :: cmdstr     type(compiler_t) :: mpi_compiler     integer :: stat,cmdstat,ire,length      unsupported_msg = 'the MPI library of wrapper '//wrapper%s//' does not support task '//trim(command)      select case (command)                 case ('compiler')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:command')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-compile-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if                         call remove_newline_characters(screen)            call split(screen%s,tokens,delimiters=' ')            screen%s = trim(adjustl(tokens(1)))                 case ('flags')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:compile')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-compile-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if                         select case (mpilib)               case (MPI_TYPE_OPENMPI)                                    call remove_newline_characters(screen)               case (MPI_TYPE_MPICH,MPI_TYPE_INTEL)                                    call remove_newline_characters(screen)                  call split(screen%s,tokens)                                    screen%s = screen%s(len_trim(tokens(1))+1:)               case default                  call fatal_error(error,'invalid MPI library type')                  return            end select                 case ('link')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:link')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-link-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if             select case (mpilib)               case (MPI_TYPE_OPENMPI)                  call remove_newline_characters(screen)               case (MPI_TYPE_MPICH,MPI_TYPE_INTEL)                                    call remove_newline_characters(screen)                  call split(screen%s,tokens)                                    screen%s = screen%s(len_trim(tokens(1))+1:)               case default                  call fatal_error(error,unsupported_msg)                  return            end select                 case ('link_dirs')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                                     call run_mpi_wrapper(wrapper,[string_t('--showme:libdirs')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:libdirs')                     return                  end if                case default                   call fatal_error(error,unsupported_msg)                  return             end select                 case ('incl_dirs')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                                    call run_mpi_wrapper(wrapper,[string_t('--showme:incdirs')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                  if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:incdirs')                     return                  end if               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call remove_newline_characters(screen)                 case ('version')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                                     call run_mpi_wrapper(wrapper,[string_t('--showme:version')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:version')                     return                  else                     call remove_newline_characters(screen)                  end if                case (MPI_TYPE_MPICH)                                                       cmdstr = string_t('mpichversion')                  call run_mpi_wrapper(cmdstr,verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                                     if (stat/=0 .or. .not.success) then                     call run_mpi_wrapper(wrapper,[string_t('-v')],verbose=verbose, &                                          exitcode=stat,cmd_success=success,screen_output=screen)                     call remove_newline_characters(screen)                  endif                                     if (stat/=0 .or. .not.success) then                      cmdstr = string_t('mpiexec --version')                      call run_mpi_wrapper(cmdstr,verbose=verbose, &                                           exitcode=stat,cmd_success=success,screen_output=screen)                  endif                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'cannot retrieve MPICH library version from <mpichversion, '//wrapper%s//', mpiexec>')                     return                  end if                case (MPI_TYPE_INTEL)                                     call run_mpi_wrapper(wrapper,[string_t('-v')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local INTEL MPI library does not support -v')                     return                  else                     call remove_newline_characters(screen)                  end if                case default                   call fatal_error(error,unsupported_msg)                  return             end select                         screen = regex_version_from_text(screen%s,MPI_TYPE_NAME(mpilib)//' library',error)            if (allocated(error)) return                 case ('runner')             select case (mpilib)               case (MPI_TYPE_OPENMPI,MPI_TYPE_MPICH,MPI_TYPE_MSMPI,MPI_TYPE_INTEL)                  call get_mpi_runner(screen,verbose,error)               case default                  call fatal_error(error,unsupported_msg)                  return            end select         case default;            call fatal_error(error,'an invalid MPI wrapper command ('//command//&                                   ') was invoked for wrapper <'//wrapper%s//'>.')            return     end select   end function mpi_wrapper_query   logical function is_link_argument(compiler,string)    type(compiler_t), intent(in) :: compiler    character(*), intent(in) :: string     select case (compiler%id)       case (id_intel_classic_windows,id_intel_llvm_windows)           is_link_argument = string=='/link' &                              .or. str_begins_with_str(string,'/LIBPATH')&                              .or. str_ends_with(string,'.lib')        case default                       is_link_argument = (    str_begins_with_str(string,'-L') &                              .or. str_begins_with_str(string,'-l') &                              .or. str_begins_with_str(string,'-Xlinker') &                              .or. string=='-pthread' &                              .or. (str_begins_with_str(string,'-W') .and. &                                    (string/='-Wall') .and. (.not.str_begins_with_str(string,'-Werror'))) ) &                              .and. .not. ( &                                  (get_os_type()==OS_MACOS .and. index(string,'-commons,use_dylibs')>0) )    end select  end function is_link_argument   subroutine filter_build_arguments(compiler,command)     type(compiler_t), intent(in) :: compiler     type(string_t), intent(inout) :: command     character(len=:), allocatable :: tokens(:)      integer :: i,n,re_i,re_l     logical, allocatable :: keep(:)     logical :: keep_next     character(len=:), allocatable :: module_flag,include_flag      if (len_trim(command)<=0) return           tokens = shlex_split(command%s)      module_flag  = get_module_flag(compiler,"")     include_flag = get_include_flag(compiler,"")      n = size(tokens)     allocate(keep(n),source=.false.)     keep_next = .false.      do i=1,n          if (get_os_type()==OS_MACOS .and. index(tokens(i),'-commons,use_dylibs')>0) then             keep(i) = .false.             keep_next = .false.         elseif (str_begins_with_str(tokens(i),'-                 str_begins_with_str(tokens(i),'-f') .or. &                 str_begins_with_str(tokens(i),'-I') .or. &                 str_begins_with_str(tokens(i),module_flag) .or. &                 str_begins_with_str(tokens(i),include_flag) .or. &                 tokens(i)=='-pthread' .or. &                 (str_begins_with_str(tokens(i),'-W') .and. tokens(i)/='-Wall' .and. .not.str_begins_with_str(tokens(i),'-Werror')) &                 ) then                    keep(i) = .true.                    if (tokens(i)==module_flag .or. tokens(i)==include_flag .or. tokens(i)=='-I') keep_next = .true.         elseif (keep_next) then             keep(i) = .true.             keep_next = .false.         end if     end do           command = string_t("")     do i=1,n         if (.not.keep(i)) cycle          command%s = command%s//' '//trim(tokens(i))     end do   end subroutine filter_build_arguments   subroutine filter_link_arguments(compiler,command)     type(compiler_t), intent(in) :: compiler     type(string_t), intent(inout) :: command     character(len=:), allocatable :: tokens(:)      integer :: i,n     logical, allocatable :: keep(:)     logical :: keep_next      if (len_trim(command)<=0) return           tokens = shlex_split(command%s)      n = size(tokens)     allocate(keep(n),source=.false.)     keep_next = .false.      do i=1,n        if (is_link_argument(compiler,tokens(i))) then            keep(i) = .true.            if (tokens(i)=='-L' .or. tokens(i)=='-Xlinker') keep_next = .true.        elseif (keep_next) then            keep(i) = .true.            keep_next = .false.        end if     end do           command = string_t("")     do i=1,n         if (.not.keep(i)) cycle         command%s = command%s//' '//trim(tokens(i))     end do  end subroutine filter_link_arguments   end module fpm_meta 
fpm_meta.f90_comments !># The fpm meta-package model !> !> This is a wrapper data type that encapsulate all pre-processing information !> (compiler flags, linker libraries, etc.) required to correctly enable a package !> to use a core library. !> !> !>### Available core libraries !> !> - OpenMP !> - MPI !> - fortran-lang stdlib !> - fortran-lang minpack !> !> !> @note Core libraries are enabled in the [build] section of the fpm.toml manifest !> !> module fpm_meta use fpm_strings, only: string_t, len_trim, remove_newline_characters, str_begins_with_str, &                        str_ends_with use fpm_error, only: error_t, fatal_error, syntax_error, fpm_stop use fpm_compiler use fpm_model use fpm_command_line use fpm_manifest_dependency, only: dependency_config_t use fpm_git, only : git_target_branch, git_target_tag use fpm_manifest, only: package_config_t use fpm_environment, only: get_env,os_is_unix use fpm_filesystem, only: run, get_temp_filename, getline, exists, canon_path, is_dir, get_dos_path use fpm_versioning, only: version_t, new_version, regex_version_from_text use fpm_os, only: get_absolute_path use shlex_module, only: shlex_split => split use regex_module, only: regex use iso_fortran_env, only: stdout => output_unit  implicit none  private  public :: resolve_metapackages  !> Type for describing a source file type, public :: metapackage_t      !> Package version (if supported)     type(version_t), allocatable :: version      logical :: has_link_libraries   = .false.     logical :: has_link_flags       = .false.     logical :: has_build_flags      = .false.     logical :: has_fortran_flags    = .false.     logical :: has_c_flags          = .false.     logical :: has_cxx_flags        = .false.     logical :: has_include_dirs     = .false.     logical :: has_dependencies     = .false.     logical :: has_run_command      = .false.     logical :: has_external_modules = .false.      !> List of compiler flags and options to be added     type(string_t) :: flags     type(string_t) :: fflags     type(string_t) :: cflags     type(string_t) :: cxxflags     type(string_t) :: link_flags     type(string_t) :: run_command     type(string_t), allocatable :: incl_dirs(:)     type(string_t), allocatable :: link_libs(:)     type(string_t), allocatable :: external_modules(:)      !> Special fortran features     type(fortran_features_t), allocatable :: fortran      !> List of Development dependency meta data.     !> Metapackage dependencies are never exported from the model     type(dependency_config_t), allocatable :: dependency(:)      contains         !> Clean metapackage structure        procedure :: destroy         !> Initialize the metapackage structure from its given name        procedure :: new => init_from_name         !> Add metapackage dependencies to the model        procedure, private :: resolve_cmd        procedure, private :: resolve_model        procedure, private :: resolve_package_config        generic :: resolve => resolve_cmd,resolve_model,resolve_package_config  end type metapackage_t  interface resolve_metapackages     module procedure resolve_metapackage_model end interface resolve_metapackages  integer, parameter :: MPI_TYPE_NONE    = 0 integer, parameter :: MPI_TYPE_OPENMPI = 1 integer, parameter :: MPI_TYPE_MPICH   = 2 integer, parameter :: MPI_TYPE_INTEL   = 3 integer, parameter :: MPI_TYPE_MSMPI   = 4 public             :: MPI_TYPE_NAME  !> Debugging information logical, parameter, private :: verbose = .false.  integer, parameter, private :: LANG_FORTRAN = 1 integer, parameter, private :: LANG_C       = 2 integer, parameter, private :: LANG_CXX     = 3  character(*), parameter :: LANG_NAME(*) = [character(7) :: 'Fortran','C','C++']  contains  !> Return a name for the MPI library pure function MPI_TYPE_NAME(mpilib) result(name)    integer, intent(in) :: mpilib    character(len=:), allocatable :: name    select case (mpilib)       case (MPI_TYPE_NONE);    name = "none"       case (MPI_TYPE_OPENMPI); name = "OpenMPI"       case (MPI_TYPE_MPICH);   name = "MPICH"       case (MPI_TYPE_INTEL);   name = "INTELMPI"       case (MPI_TYPE_MSMPI);   name = "MS-MPI"       case default;            name = "UNKNOWN"    end select end function MPI_TYPE_NAME  !> Clean the metapackage structure elemental subroutine destroy(this)    class(metapackage_t), intent(inout) :: this     this%has_link_libraries   = .false.    this%has_link_flags       = .false.    this%has_build_flags      = .false.    this%has_fortran_flags    = .false.    this%has_c_flags          = .false.    this%has_cxx_flags        = .false.    this%has_include_dirs     = .false.    this%has_dependencies     = .false.    this%has_run_command      = .false.    this%has_external_modules = .false.     if (allocated(this%fortran)) deallocate(this%fortran)    if (allocated(this%version)) deallocate(this%version)    if (allocated(this%flags%s)) deallocate(this%flags%s)    if (allocated(this%fflags%s)) deallocate(this%fflags%s)    if (allocated(this%cflags%s)) deallocate(this%cflags%s)    if (allocated(this%cxxflags%s)) deallocate(this%cxxflags%s)    if (allocated(this%link_flags%s)) deallocate(this%link_flags%s)    if (allocated(this%run_command%s)) deallocate(this%run_command%s)    if (allocated(this%link_libs)) deallocate(this%link_libs)    if (allocated(this%dependency)) deallocate(this%dependency)    if (allocated(this%incl_dirs)) deallocate(this%incl_dirs)    if (allocated(this%external_modules)) deallocate(this%external_modules)  end subroutine destroy  !> Initialize a metapackage from the given name subroutine init_from_name(this,name,compiler,error)     class(metapackage_t), intent(inout) :: this     character(*), intent(in) :: name     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      !> Initialize metapackage by name     select case(name)         case("openmp");  call init_openmp (this,compiler,error)         case("stdlib");  call init_stdlib (this,compiler,error)         case("minpack"); call init_minpack(this,compiler,error)         case("mpi");     call init_mpi    (this,compiler,error)         case default             call syntax_error(error, "Package "//name//" is not supported in [metapackages]")             return     end select  end subroutine init_from_name  !> Initialize OpenMP metapackage for the current system subroutine init_openmp(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      !> Cleanup     call destroy(this)      !> OpenMP has compiler flags     this%has_build_flags = .true.     this%has_link_flags  = .true.      !> OpenMP flags should be added to     which_compiler: select case (compiler%id)        case (id_gcc,id_f95)             this%flags      = string_t(flag_gnu_openmp)             this%link_flags = string_t(flag_gnu_openmp)         case (id_intel_classic_windows,id_intel_llvm_windows)             this%flags      = string_t(flag_intel_openmp_win)             this%link_flags = string_t(flag_intel_openmp_win)         case (id_intel_classic_nix,id_intel_classic_mac,&              id_intel_llvm_nix)             this%flags      = string_t(flag_intel_openmp)             this%link_flags = string_t(flag_intel_openmp)         case (id_pgi,id_nvhpc)             this%flags      = string_t(flag_pgi_openmp)             this%link_flags = string_t(flag_pgi_openmp)         case (id_ibmxl)             this%flags      = string_t(" -qsmp=omp")             this%link_flags = string_t(" -qsmp=omp")         case (id_nag)             this%flags      = string_t(flag_nag_openmp)             this%link_flags = string_t(flag_nag_openmp)         case (id_lfortran)             this%flags      = string_t(flag_lfortran_openmp)             this%link_flags = string_t(flag_lfortran_openmp)         case default            call fatal_error(error,'openmp not supported on compiler '//compiler%name()//' yet')      end select which_compiler   end subroutine init_openmp  !> Initialize minpack metapackage for the current system subroutine init_minpack(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      !> Cleanup     call destroy(this)      !> minpack is queried as a dependency from the official repository     this%has_dependencies = .true.      allocate(this%dependency(1))      !> 1) minpack. There are no true releases currently. Fetch HEAD     this%dependency(1)%name = "minpack"     this%dependency(1)%git = git_target_tag("https://github.com/fortran-lang/minpack", "v2.0.0-rc.1")     if (.not.allocated(this%dependency(1)%git)) then         call fatal_error(error,'cannot initialize git repo dependency for minpack metapackage')         return     end if  end subroutine init_minpack  !> Initialize stdlib metapackage for the current system subroutine init_stdlib(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      !> Cleanup     call destroy(this)      !> Stdlib is queried as a dependency from the official repository     this%has_dependencies = .true.      allocate(this%dependency(2))      !> 1) Test-drive     this%dependency(1)%name = "test-drive"     this%dependency(1)%git = git_target_branch("https://github.com/fortran-lang/test-drive","v0.4.0")     if (.not.allocated(this%dependency(1)%git)) then         call fatal_error(error,'cannot initialize test-drive git dependency for stdlib metapackage')         return     end if      !> 2) stdlib     this%dependency(2)%name = "stdlib"     this%dependency(2)%git = git_target_branch("https://github.com/fortran-lang/stdlib","stdlib-fpm")     if (.not.allocated(this%dependency(2)%git)) then         call fatal_error(error,'cannot initialize git repo dependency for stdlib metapackage')         return     end if  end subroutine init_stdlib  ! Resolve metapackage dependencies into the command line settings subroutine resolve_cmd(self,settings,error)     class(metapackage_t), intent(in) :: self     class(fpm_cmd_settings), intent(inout) :: settings     type(error_t), allocatable, intent(out) :: error      ! Add customize run commands     if (self%has_run_command) then          select type (cmd=>settings)            class is (fpm_run_settings) ! includes fpm_test_settings                ! Only override runner if user has not provided a custom one               if (.not.len_trim(cmd%runner)>0) cmd%runner = self%run_command%s          end select      endif  end subroutine resolve_cmd  ! Resolve metapackage dependencies into the model subroutine resolve_model(self,model,error)     class(metapackage_t), intent(in) :: self     type(fpm_model_t), intent(inout) :: model     type(error_t), allocatable, intent(out) :: error      ! Add global build flags, to apply to all sources     if (self%has_build_flags) then         model%fortran_compile_flags = model%fortran_compile_flags//self%flags%s         model%c_compile_flags       = model%c_compile_flags//self%flags%s         model%cxx_compile_flags     = model%cxx_compile_flags//self%flags%s     endif      ! Add language-specific flags     if (self%has_fortran_flags) model%fortran_compile_flags = model%fortran_compile_flags//self%fflags%s     if (self%has_c_flags)       model%c_compile_flags       = model%c_compile_flags//self%cflags%s     if (self%has_cxx_flags)     model%cxx_compile_flags     = model%cxx_compile_flags//self%cxxflags%s      if (self%has_link_flags) then         model%link_flags            = model%link_flags//self%link_flags%s     end if      if (self%has_link_libraries) then         model%link_libraries        = [model%link_libraries,self%link_libs]     end if      if (self%has_include_dirs) then         model%include_dirs          = [model%include_dirs,self%incl_dirs]     end if      if (self%has_external_modules) then         model%external_modules      = [model%external_modules,self%external_modules]     end if  end subroutine resolve_model  subroutine resolve_package_config(self,package,error)     class(metapackage_t), intent(in) :: self     type(package_config_t), intent(inout) :: package     type(error_t), allocatable, intent(out) :: error      ! All metapackage dependencies are added as dev-dependencies,     ! as they may change if built upstream     if (self%has_dependencies) then         if (allocated(package%dev_dependency)) then            package%dev_dependency = [package%dev_dependency,self%dependency]         else            package%dev_dependency = self%dependency         end if     end if      ! Check if there are any special fortran requests which the package does not comply to     if (allocated(self%fortran)) then          if (self%fortran%implicit_external.neqv.package%fortran%implicit_external) then             call fatal_error(error,'metapackage fortran error: metapackage '// &                                    dn(self%fortran%implicit_external)//' require implicit-external, main package '//&                                    dn(package%fortran%implicit_external))             return         end if          if (self%fortran%implicit_typing.neqv.package%fortran%implicit_typing) then             call fatal_error(error,'metapackage fortran error: metapackage '// &                                    dn(self%fortran%implicit_external)//' require implicit-typing, main package '//&                                    dn(package%fortran%implicit_external))             return         end if      end if      contains      pure function dn(bool)        logical, intent(in) :: bool        character(len=:), allocatable :: dn        if (bool) then           dn = "does"        else           dn = "does not"        end if     end function dn   end subroutine resolve_package_config  ! Add named metapackage dependency to the model subroutine add_metapackage_model(model,package,settings,name,error)     type(fpm_model_t), intent(inout) :: model     type(package_config_t), intent(inout) :: package     class(fpm_cmd_settings), intent(inout) :: settings     character(*), intent(in) :: name     type(error_t), allocatable, intent(out) :: error      type(metapackage_t) :: meta      !> Init metapackage     call meta%new(name,model%compiler,error)     if (allocated(error)) return      !> Add it into the model     call meta%resolve(model,error)     if (allocated(error)) return      !> Add it into the package     call meta%resolve(package,error)     if (allocated(error)) return      !> Add it into the settings     call meta%resolve(settings,error)     if (allocated(error)) return      ! If we need to run executables, there should be an MPI runner     if (name=="mpi") then         select type (settings)            class is (fpm_run_settings) ! run, test               if (.not.meta%has_run_command) &               call fatal_error(error,"cannot find a valid mpi runner on the local host")         end select     endif  end subroutine add_metapackage_model  !> Resolve all metapackages into the package config subroutine resolve_metapackage_model(model,package,settings,error)     type(fpm_model_t), intent(inout) :: model     type(package_config_t), intent(inout) :: package     class(fpm_build_settings), intent(inout) :: settings     type(error_t), allocatable, intent(out) :: error      ! Dependencies are added to the package config, so they're properly resolved     ! into the dependency tree later.     ! Flags are added to the model (whose compiler needs to be already initialized)     if (model%compiler%is_unknown()) &     write(stdout,'(a)') '<WARNING> compiler not initialized: metapackages may not be available'      ! OpenMP     if (package%meta%openmp%on) then         call add_metapackage_model(model,package,settings,"openmp",error)         if (allocated(error)) return     endif      ! stdlib     if (package%meta%stdlib%on) then         call add_metapackage_model(model,package,settings,"stdlib",error)         if (allocated(error)) return     endif      ! stdlib     if (package%meta%minpack%on) then         call add_metapackage_model(model,package,settings,"minpack",error)         if (allocated(error)) return     endif       ! Stdlib is not 100% thread safe. print a warning to the user     if (package%meta%stdlib%on .and. package%meta%openmp%on) then         write(stdout,'(a)')'<WARNING> both openmp and stdlib requested: some functions may not be thread-safe!'     end if      ! MPI     if (package%meta%mpi%on) then         call add_metapackage_model(model,package,settings,"mpi",error)         if (allocated(error)) return     endif  end subroutine resolve_metapackage_model  !> Initialize MPI metapackage for the current system subroutine init_mpi(this,compiler,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error       type(string_t), allocatable :: c_wrappers(:),cpp_wrappers(:),fort_wrappers(:)     type(string_t) :: output,fwrap,cwrap,cxxwrap     character(256) :: msg_out     character(len=:), allocatable :: tokens(:)     integer :: wcfit(3),mpilib(3),ic,icpp,i     logical :: found      !> Cleanup     call destroy(this)      !> Get all candidate MPI wrappers     call mpi_wrappers(compiler,fort_wrappers,c_wrappers,cpp_wrappers)     if (verbose) print 1, size(fort_wrappers),size(c_wrappers),size(cpp_wrappers)      call wrapper_compiler_fit(fort_wrappers,c_wrappers,cpp_wrappers,compiler,wcfit,mpilib,error)      if (allocated(error) .or. all(wcfit==0)) then          !> No wrapper compiler fit. Are we on Windows? use MSMPI-specific search         found = msmpi_init(this,compiler,error)         if (allocated(error)) return          !> All attempts failed         if (.not.found) then             call fatal_error(error,"cannot find MPI wrappers or libraries for "//compiler%name()//" compiler")             return         endif      else          if (wcfit(LANG_FORTRAN)>0) fwrap   = fort_wrappers(wcfit(LANG_FORTRAN))         if (wcfit(LANG_C)>0)       cwrap   = c_wrappers   (wcfit(LANG_C))         if (wcfit(LANG_CXX)>0)     cxxwrap = cpp_wrappers (wcfit(LANG_CXX))          !> If there's only an available Fortran wrapper, and the compiler's different than fpm's baseline         !> fortran compiler suite, we still want to enable C language flags as that is most likely being         !> ABI-compatible anyways. However, issues may arise.         !> see e.g. Homebrew with clabng C/C++ and GNU fortran at https://gitlab.kitware.com/cmake/cmake/-/issues/18139         if (wcfit(LANG_FORTRAN)>0 .and. all(wcfit([LANG_C,LANG_CXX])==0)) then             cwrap   = fort_wrappers(wcfit(LANG_FORTRAN))             cxxwrap = fort_wrappers(wcfit(LANG_FORTRAN))         end if          if (verbose) print *, '+ MPI fortran wrapper: ',fwrap%s         if (verbose) print *, '+ MPI c       wrapper: ',cwrap%s         if (verbose) print *, '+ MPI c++     wrapper: ',cxxwrap%s          !> Initialize MPI package from wrapper command         call init_mpi_from_wrappers(this,compiler,mpilib(LANG_FORTRAN),fwrap,cwrap,cxxwrap,error)         if (allocated(error)) return          !> Request Fortran implicit typing         if (mpilib(LANG_FORTRAN)/=MPI_TYPE_INTEL) then             allocate(this%fortran)             this%fortran%implicit_typing   = .true.             this%fortran%implicit_external = .true.         endif      end if      !> Not all MPI implementations offer modules mpi and mpi_f08: hence, include them     !> to the list of external modules, so they won't be requested as standard source files     this%has_external_modules = .true.     this%external_modules = [string_t("mpi"),string_t("mpi_f08")]      1 format('MPI wrappers found: fortran=',i0,' c=',i0,' c++=',i0)  end subroutine init_mpi  !> Check if we're on a 64-bit environment !> Accept answer from https://stackoverflow.com/questions/49141093/get-system-information-with-fortran logical function is_64bit_environment()    use iso_c_binding, only: c_intptr_t    integer, parameter :: nbits = bit_size(0_c_intptr_t)    is_64bit_environment = nbits==64 end function is_64bit_environment  !> Check if there is a wrapper-compiler fit subroutine wrapper_compiler_fit(fort_wrappers,c_wrappers,cpp_wrappers,compiler,wrap,mpi,error)    type(string_t), allocatable, intent(in) :: fort_wrappers(:),c_wrappers(:),cpp_wrappers(:)    type(compiler_t), intent(in) :: compiler    type(error_t), allocatable, intent(out) :: error    integer, intent(out), dimension(3) :: wrap, mpi     type(error_t), allocatable :: wrap_error     wrap = 0    mpi  = MPI_TYPE_NONE     if (size(fort_wrappers)>0) &    call mpi_compiler_match(LANG_FORTRAN,fort_wrappers,compiler,wrap(LANG_FORTRAN),mpi(LANG_FORTRAN),wrap_error)     if (size(c_wrappers)>0) &    call mpi_compiler_match(LANG_C,c_wrappers,compiler,wrap(LANG_C),mpi(LANG_C),wrap_error)     if (size(cpp_wrappers)>0) &    call mpi_compiler_match(LANG_CXX,cpp_wrappers,compiler,wrap(LANG_CXX),mpi(LANG_CXX),wrap_error)     !> Find a Fortran wrapper for the current compiler    if (all(wrap==0)) then         call fatal_error(error,'no valid wrappers match current compiler, '//compiler_name(compiler))         return    end if  end subroutine wrapper_compiler_fit  !> Check if a local MS-MPI SDK build is found logical function msmpi_init(this,compiler,error) result(found)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     type(error_t), allocatable, intent(out) :: error      character(len=:), allocatable :: incdir,windir,libdir,bindir,post,reall,msysdir     type(version_t) :: ver,ver10     type(string_t) :: cpath,msys_path,runner_path     logical :: msys2      !> Default: not found     found = .false.      if (get_os_type()==OS_WINDOWS) then          ! to run MSMPI on Windows,         is_minGW: if (compiler%id==id_gcc) then              call compiler_get_version(compiler,ver,msys2,error)             if (allocated(error)) return          endif is_minGW          ! Check we're on a 64-bit environment         if (is_64bit_environment()) then             libdir = get_env('MSMPI_LIB64')             post   = 'x64'         else             libdir = get_env('MSMPI_LIB32')             post   = 'x86'              !> Not working on 32-bit Windows yet             call fatal_error(error,'MS-MPI error: this package requires 64-bit Windows environment')             return          end if          ! Check that the runtime is installed         bindir = ""         call get_absolute_path(get_env('MSMPI_BIN'),bindir,error)         if (verbose) print *, '+ %MSMPI_BIN%=',bindir          ! In some environments, variable %MSMPI_BIN% is missing (i.e. in GitHub Action images).         ! Do a second attempt: search for the default location         if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching C:\Program Files\Microsoft MPI\Bin\ ...'             call get_absolute_path('C:\Program Files\Microsoft MPI\Bin\mpiexec.exe',bindir,error)         endif          ! Third attempt for bash-style shell         if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching /c/Program Files/Microsoft MPI/Bin/ ...'             call get_absolute_path('/c/Program Files/Microsoft MPI/Bin/mpiexec.exe',bindir,error)         endif          ! Do a fourth attempt: search for mpiexec.exe in PATH location         if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ C:\Program Files\Microsoft MPI\Bin\ not found. searching %PATH%...'              call get_mpi_runner(runner_path,verbose,error)              if (.not.allocated(error)) then                if (verbose) print *, '+ mpiexec found: ',runner_path%s                call find_command_location(runner_path%s,bindir,verbose=verbose,error=error)             endif          endif          if (allocated(error)) then             call fatal_error(error,'MS-MPI error: MS-MPI Runtime directory is missing. '//&                                    'check environment variable %MSMPI_BIN% or that the folder is in %PATH%.')             return         end if          ! Success!         found = .true.          ! Init ms-mpi         call destroy(this)          ! MSYS2 provides a pre-built static msmpi.dll.a library. Use that if possible         use_prebuilt: if (msys2) then              ! MSYS executables are in %MSYS_ROOT%/bin             call compiler_get_path(compiler,cpath,error)             if (allocated(error)) return              call get_absolute_path(join_path(cpath%s,'..'),msys_path%s,error)             if (allocated(error)) return              call get_absolute_path(join_path(msys_path%s,'include'),incdir,error)             if (allocated(error)) return              call get_absolute_path(join_path(msys_path%s,'lib'),libdir,error)             if (allocated(error)) return              if (verbose) print 1, 'include',incdir,exists(incdir)             if (verbose) print 1, 'library',libdir,exists(libdir)              ! Check that the necessary files exist             call get_absolute_path(join_path(libdir,'libmsmpi.dll.a'),post,error)             if (allocated(error)) return              if (len_trim(post)<=0 .or. .not.exists(post)) then                 call fatal_error(error,'MS-MPI available through the MSYS2 system not found. '// &                                        'Run <pacman -Sy mingw64/mingw-w64-x86_64-msmpi> '// &                                        'or your system-specific version to install.')                 return             end if              ! Add dir cpath             this%has_link_flags = .true.             this%link_flags = string_t(' -L'//get_dos_path(libdir,error))              this%has_link_libraries = .true.             this%link_libs = [string_t('msmpi.dll')]              if (allocated(error)) return              this%has_include_dirs = .true.             this%incl_dirs = [string_t(get_dos_path(incdir,error))]             if (allocated(error)) return          else              call fatal_error(error,'MS-MPI cannot work with non-MSYS2 GNU compilers yet')             return              ! Add dir path             this%has_link_flags = .true.             this%link_flags = string_t(' -L'//get_dos_path(libdir,error))              this%has_link_libraries = .true.             this%link_libs = [string_t('msmpi'),string_t('msmpifec'),string_t('msmpifmc')]              if (allocated(error)) return              this%has_include_dirs = .true.             this%incl_dirs = [string_t(get_dos_path(incdir,error)), &                               string_t(get_dos_path(incdir//post,error))]             if (allocated(error)) return           end if use_prebuilt          !> Request Fortran implicit typing         allocate(this%fortran)         this%fortran%implicit_typing = .true.         this%fortran%implicit_external = .true.          ! gfortran>=10 is incompatible with the old-style mpif.h MS-MPI headers.         ! If so, add flags to allow old-style BOZ constants in mpif.h         allow_BOZ: if (compiler%id==id_gcc) then              call new_version(ver10,'10.0.0',error)             if (allocated(error)) return              if (ver>=ver10) then                 this%has_build_flags = .true.                 this%flags = string_t(' -fallow-invalid-boz')             end if          endif allow_BOZ          !> Add default run command         this%has_run_command = .true.         this%run_command = string_t(join_path(get_dos_path(bindir,error),'mpiexec.exe')//' -np * ')      else          !> Not on Windows         found = .false.      end if      1 format('MSMSPI ',a,' directory: PATH=',a,' EXISTS=',l1)  end function msmpi_init  !> Check if we're under a WSL bash shell logical function wsl_shell()     if (get_os_type()==OS_WINDOWS) then         wsl_shell = exists('/proc/sys/fs/binfmt_misc/WSLInterop')     else         wsl_shell = .false.     endif end function wsl_shell  !> Find the location of a valid command subroutine find_command_location(command,path,echo,verbose,error)     character(*), intent(in) :: command     character(len=:), allocatable, intent(out) :: path     logical, optional, intent(in) :: echo,verbose     type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: tmp_file,screen_output,line,fullpath,search_command     integer :: stat,iunit,ire,length,try     character(*), parameter :: search(2) = ["where ","which "]      if (len_trim(command)<=0) then         call fatal_error(error,'empty command provided in find_command_location')         return     end if      tmp_file = get_temp_filename()      ! On Windows, we try both commands because we may be on WSL     do try=merge(1,2,get_os_type()==OS_WINDOWS),2        search_command = search(try)//command        call run(search_command, echo=echo, exitstat=stat, verbose=verbose, redirect=tmp_file)        if (stat==0) exit     end do     if (stat/=0) then         call fatal_error(error,'find_command_location failed for '//command)         return     end if      ! Only read first instance (first line)     allocate(character(len=0) :: screen_output)     open(newunit=iunit,file=tmp_file,status='old',iostat=stat)     if (stat == 0)then        do            call getline(iunit, line, stat)            if (stat /= 0) exit            if (len(screen_output)>0) then                 screen_output = screen_output//new_line('a')//line            else                 screen_output = line            endif        end do        ! Close and delete file        close(iunit,status='delete')     else        call fatal_error(error,'cannot read temporary file from successful find_command_location')        return     endif      ! Only use the first instance     length = index(screen_output,new_line('a'))      multiline: if (length>1) then         fullpath = screen_output(1:length-1)     else         fullpath = screen_output     endif multiline     if (len_trim(fullpath)<1) then         call fatal_error(error,'no paths found to command ('//command//')')         return     end if      ! Extract path only     length = index(fullpath,command,BACK=.true.)     if (length<=0) then         call fatal_error(error,'full path to command ('//command//') does not include command name')         return     elseif (length==1) then         ! Compiler is in the current folder         path = '.'     else         path = fullpath(1:length-1)     end if     if (allocated(error)) return      ! On Windows, be sure to return a path with no spaces     if (get_os_type()==OS_WINDOWS) path = get_dos_path(path,error)      if (allocated(error) .or. .not.is_dir(path)) then         call fatal_error(error,'full path ('//path//') to command ('//command//') is not a directory')         return     end if  end subroutine find_command_location  !> Get MPI runner in $PATH subroutine get_mpi_runner(command,verbose,error)     type(string_t), intent(out) :: command     logical, intent(in) :: verbose     type(error_t), allocatable, intent(out) :: error      character(*), parameter :: try(*) = ['mpiexec    ','mpirun     ','mpiexec.exe','mpirun.exe ']     character(:), allocatable :: bindir     integer :: itri     logical :: success      ! Try several commands     do itri=1,size(try)        call find_command_location(trim(try(itri)),command%s,verbose=verbose,error=error)        if (allocated(error)) cycle         ! Success!        success = len_trim(command%s)>0        if (success) then            if (verbose) print *, '+ runner folder found: '//command%s            command%s = join_path(command%s,trim(try(itri)))            return        endif     end do      ! On windows, also search in %MSMPI_BIN%     if (get_os_type()==OS_WINDOWS) then         ! Check that the runtime is installed         bindir = ""         call get_absolute_path(get_env('MSMPI_BIN'),bindir,error)         if (verbose) print *, '+ %MSMPI_BIN%=',bindir         ! In some environments, variable %MSMPI_BIN% is missing (i.e. in GitHub Action images).         ! Do a second attempt: search for the default location         if (len_trim(bindir)<=0 .or. allocated(error)) then             if (verbose) print *, '+ %MSMPI_BIN% empty, searching C:\Program Files\Microsoft MPI\Bin\ ...'             call get_absolute_path('C:\Program Files\Microsoft MPI\Bin\mpiexec.exe',bindir,error)         endif         if (len_trim(bindir)>0 .and. .not.allocated(error)) then             ! MSMPI_BIN directory found             command%s = join_path(bindir,'mpiexec.exe')             return         endif     endif      ! No valid command found     call fatal_error(error,'cannot find a valid mpi runner command')     return  end subroutine get_mpi_runner  !> Return compiler path subroutine compiler_get_path(self,path,error)     type(compiler_t), intent(in) :: self     type(string_t), intent(out) :: path     type(error_t), allocatable, intent(out) :: error      call find_command_location(self%fc,path%s,self%echo,self%verbose,error)  end subroutine compiler_get_path  !> Return compiler version subroutine compiler_get_version(self,version,is_msys2,error)     type(compiler_t), intent(in) :: self     type(version_t), intent(out) :: version     logical, intent(out) :: is_msys2     type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: tmp_file,screen_output,line     type(string_t) :: ver     integer :: stat,iunit,ire,length      is_msys2 = .false.      select case (self%id)        case (id_gcc)              tmp_file = get_temp_filename()              call run(self%fc // " --version ", echo=self%echo, verbose=self%verbose, redirect=tmp_file, exitstat=stat)             if (stat/=0) then                 call fatal_error(error,'compiler_get_version failed for '//self%fc)                 return             end if              allocate(character(len=0) :: screen_output)             open(newunit=iunit,file=tmp_file,status='old',iostat=stat)             if (stat == 0)then                do                    call getline(iunit, line, stat)                    if (stat /= 0) exit                    screen_output = screen_output//' '//line//' '                end do                ! Close and delete file                close(iunit,status='delete')             else                call fatal_error(error,'cannot read temporary file from successful compiler_get_version')                return             endif              ! Check if this gcc is from the MSYS2 project             is_msys2 = index(screen_output,'MSYS2')>0              ver = regex_version_from_text(screen_output,self%fc//' compiler',error)             if (allocated(error)) return              ! Extract version             call new_version(version,ver%s,error)          case default             call fatal_error(error,'compiler_get_version not yet implemented for compiler '//self%fc)             return     end select  end subroutine compiler_get_version  !> Initialize an MPI metapackage from a valid wrapper command ('mpif90', etc...) subroutine init_mpi_from_wrappers(this,compiler,mpilib,fort_wrapper,c_wrapper,cxx_wrapper,error)     class(metapackage_t), intent(inout) :: this     type(compiler_t), intent(in) :: compiler     integer, intent(in) :: mpilib     type(string_t), intent(in) :: fort_wrapper,c_wrapper,cxx_wrapper     type(error_t), allocatable, intent(out) :: error      type(version_t) :: version     type(error_t), allocatable :: runner_error      ! Cleanup structure     call destroy(this)      ! Get linking flags     this%link_flags = mpi_wrapper_query(mpilib,fort_wrapper,'link',verbose,error)     if (allocated(error)) return      ! Remove useless/dangerous flags     call filter_link_arguments(compiler,this%link_flags)      this%has_link_flags = len_trim(this%link_flags)>0      ! Request to use libs in arbitrary order     if (this%has_link_flags .and. compiler%is_gnu() .and. os_is_unix() .and. get_os_type()/=OS_MACOS) then         this%link_flags = string_t(' -Wl,--start-group '//this%link_flags%s)     end if      ! Add language-specific flags     call set_language_flags(compiler,mpilib,fort_wrapper,this%has_fortran_flags,this%fflags,verbose,error)     if (allocated(error)) return     call set_language_flags(compiler,mpilib,c_wrapper,this%has_c_flags,this%cflags,verbose,error)     if (allocated(error)) return     call set_language_flags(compiler,mpilib,cxx_wrapper,this%has_cxx_flags,this%cxxflags,verbose,error)     if (allocated(error)) return      ! Get library version     version = mpi_version_get(mpilib,fort_wrapper,error)     if (allocated(error)) then        return     else        allocate(this%version,source=version)     end if      !> Add default run command, if present     this%run_command = mpi_wrapper_query(mpilib,fort_wrapper,'runner',verbose,runner_error)     this%has_run_command = (len_trim(this%run_command)>0) .and. .not.allocated(runner_error)      contains      subroutine set_language_flags(compiler,mpilib,wrapper,has_flags,flags,verbose,error)         type(compiler_t), intent(in) :: compiler         integer, intent(in) :: mpilib         type(string_t), intent(in) :: wrapper         logical, intent(inout) :: has_flags         type(string_t), intent(inout) :: flags         logical, intent(in) :: verbose         type(error_t), allocatable, intent(out) :: error          ! Get build flags for each language         if (len_trim(wrapper)>0) then             flags = mpi_wrapper_query(mpilib,wrapper,'flags',verbose,error)              if (allocated(error)) return             has_flags = len_trim(flags)>0              ! Add heading space             flags = string_t(' '//flags%s)              if (verbose) print *, '+ MPI language flags from wrapper <',wrapper%s,'>: flags=',flags%s              call filter_build_arguments(compiler,flags)          endif      end subroutine set_language_flags  end subroutine init_mpi_from_wrappers  !> Match one of the available compiler wrappers with the current compiler subroutine mpi_compiler_match(language,wrappers,compiler,which_one,mpilib,error)     integer, intent(in) :: language     type(string_t), intent(in) :: wrappers(:)     type(compiler_t), intent(in) :: compiler     integer, intent(out) :: which_one, mpilib     type(error_t), allocatable, intent(out) :: error      integer :: i, same_vendor, vendor_mpilib     type(string_t) :: screen     character(128) :: msg_out     type(compiler_t) :: mpi_compiler      which_one   = 0     same_vendor = 0     mpilib      = MPI_TYPE_NONE      if (verbose) print *, '+ Trying to match available ',LANG_NAME(language),' MPI wrappers to ',compiler%fc,'...'      do i=1,size(wrappers)          mpilib = which_mpi_library(wrappers(i),compiler,verbose=.false.)          screen = mpi_wrapper_query(mpilib,wrappers(i),'compiler',verbose=.false.,error=error)         if (allocated(error)) return          if (verbose) print *, '  Wrapper ',wrappers(i)%s,' lib=',MPI_TYPE_NAME(mpilib),' uses ',screen%s          select case (language)            case (LANG_FORTRAN)                ! Build compiler type. The ID is created based on the Fortran name                call new_compiler(mpi_compiler,screen%s,'','',echo=.true.,verbose=.false.)                 ! Fortran match found!                if (mpi_compiler%id == compiler%id) then                    which_one = i                    return                end if            case (LANG_C)                ! For other languages, we can only hope that the name matches the expected one                if (screen%s==compiler%cc .or. screen%s==compiler%fc) then                    which_one = i                    return                end if            case (LANG_CXX)                if (screen%s==compiler%cxx .or. screen%s==compiler%fc) then                    which_one = i                    return                end if         end select          ! Because the intel mpi library does not support llvm_ compiler wrappers yet,         ! we must check for that manually         if (is_intel_classic_option(language,same_vendor,screen,compiler,mpi_compiler)) then             same_vendor = i             vendor_mpilib = mpilib         end if     end do      ! Intel compiler: if an exact match is not found, attempt closest wrapper     if (which_one==0 .and. same_vendor>0) then         which_one = same_vendor         mpilib    = vendor_mpilib     end if      ! None of the available wrappers matched the current Fortran compiler     write(msg_out,1) size(wrappers),compiler%fc     call fatal_error(error,trim(msg_out))     1 format('<ERROR> None out of ',i0,' valid MPI wrappers matches compiler ',a)  end subroutine mpi_compiler_match  !> Because the Intel mpi library does not support llvm_ compiler wrappers yet, !> we must save the Intel-classic option and later manually replace it logical function is_intel_classic_option(language,same_vendor_ID,screen_out,compiler,mpi_compiler)     integer, intent(in) :: language,same_vendor_ID     type(string_t), intent(in) :: screen_out     type(compiler_t), intent(in) :: compiler,mpi_compiler      if (same_vendor_ID/=0) then         is_intel_classic_option = .false.     else         select case (language)            case (LANG_FORTRAN)                is_intel_classic_option = mpi_compiler%is_intel() .and. compiler%is_intel()            case (LANG_C)                is_intel_classic_option = screen_out%s=='icc' .and. compiler%cc=='icx'            case (LANG_CXX)                is_intel_classic_option = screen_out%s=='icpc' .and. compiler%cc=='icpx'         end select     end if  end function is_intel_classic_option  !> Return library version from the MPI wrapper command type(version_t) function mpi_version_get(mpilib,wrapper,error)    integer, intent(in) :: mpilib    type(string_t), intent(in) :: wrapper    type(error_t), allocatable, intent(out) :: error     type(string_t) :: version_line     ! Get version string    version_line = mpi_wrapper_query(mpilib,wrapper,'version',error=error)    if (allocated(error)) return     ! Wrap to object    call new_version(mpi_version_get,version_line%s,error)  end function mpi_version_get  !> Return several mpi wrappers, and return subroutine mpi_wrappers(compiler,fort_wrappers,c_wrappers,cpp_wrappers)     type(compiler_t), intent(in) :: compiler     type(string_t), allocatable, intent(out) :: c_wrappers(:),cpp_wrappers(:),fort_wrappers(:)      character(len=:), allocatable :: mpi_root,intel_wrap     type(error_t), allocatable :: error      ! Attempt gathering MPI wrapper names from the environment variables     c_wrappers    = [string_t(get_env('MPICC' ,'mpicc'))]     cpp_wrappers  = [string_t(get_env('MPICXX','mpic++'))]     fort_wrappers = [string_t(get_env('MPIFC' ,'mpifc' )),&                      string_t(get_env('MPIf90','mpif90')),&                      string_t(get_env('MPIf77','mpif77'))]      if (get_os_type()==OS_WINDOWS) then         c_wrappers = [c_wrappers,string_t('mpicc.bat')]         cpp_wrappers = [cpp_wrappers,string_t('mpicxx.bat')]         fort_wrappers = [fort_wrappers,string_t('mpifc.bat')]     endif      ! Add compiler-specific wrappers     compiler_specific: select case (compiler%id)        case (id_gcc,id_f95)              c_wrappers = [c_wrappers,string_t('mpigcc'),string_t('mpgcc')]           cpp_wrappers = [cpp_wrappers,string_t('mpig++'),string_t('mpg++')]          fort_wrappers = [fort_wrappers,string_t('mpigfortran'),string_t('mpgfortran'),&                           string_t('mpig77'),string_t('mpg77')]         case (id_intel_classic_windows,id_intel_llvm_windows, &              id_intel_classic_nix,id_intel_classic_mac,id_intel_llvm_nix,id_intel_llvm_unknown)              c_wrappers = [string_t(get_env('I_MPI_CC','mpiicc'))]           cpp_wrappers = [string_t(get_env('I_MPI_CXX','mpiicpc'))]          fort_wrappers = [string_t(get_env('I_MPI_F90','mpiifort'))]           ! Also search MPI wrappers via the base MPI folder          mpi_root = get_env('I_MPI_ROOT')          if (mpi_root/="") then               mpi_root = join_path(mpi_root,'bin')               intel_wrap = join_path(mpi_root,'mpiifort')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") fort_wrappers = [fort_wrappers,string_t(intel_wrap)]               intel_wrap = join_path(mpi_root,'mpiicc')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") c_wrappers = [c_wrappers,string_t(intel_wrap)]               intel_wrap = join_path(mpi_root,'mpiicpc')              if (get_os_type()==OS_WINDOWS) intel_wrap = get_dos_path(intel_wrap,error)              if (intel_wrap/="") cpp_wrappers = [cpp_wrappers,string_t(intel_wrap)]           end if         case (id_pgi,id_nvhpc)              c_wrappers = [c_wrappers,string_t('mpipgicc'),string_t('mpgcc')]           cpp_wrappers = [cpp_wrappers,string_t('mpipgic++')]          fort_wrappers = [fort_wrappers,string_t('mpipgifort'),string_t('mpipgf90')]         case (id_cray)              c_wrappers = [c_wrappers,string_t('cc')]           cpp_wrappers = [cpp_wrappers,string_t('CC')]          fort_wrappers = [fort_wrappers,string_t('ftn')]      end select compiler_specific      call assert_mpi_wrappers(fort_wrappers,compiler)     call assert_mpi_wrappers(c_wrappers,compiler)     call assert_mpi_wrappers(cpp_wrappers,compiler)  end subroutine mpi_wrappers  !> Filter out invalid/unavailable mpi wrappers subroutine assert_mpi_wrappers(wrappers,compiler,verbose)     type(string_t), allocatable, intent(inout) :: wrappers(:)     type(compiler_t), intent(in) :: compiler     logical, optional, intent(in) :: verbose      integer :: i     integer, allocatable :: works(:)      allocate(works(size(wrappers)))      do i=1,size(wrappers)         if (present(verbose)) then             if (verbose) print *, '+ MPI test wrapper <',wrappers(i)%s,'>'         endif         works(i) = which_mpi_library(wrappers(i),compiler,verbose)     end do      ! Filter out non-working wrappers     wrappers = pack(wrappers,works/=MPI_TYPE_NONE)  end subroutine assert_mpi_wrappers  !> Simple call to execute_command_line involving one mpi* wrapper subroutine run_mpi_wrapper(wrapper,args,verbose,exitcode,cmd_success,screen_output)     type(string_t), intent(in) :: wrapper     type(string_t), intent(in), optional :: args(:)     logical, intent(in), optional :: verbose     integer, intent(out), optional :: exitcode     logical, intent(out), optional :: cmd_success     type(string_t), intent(out), optional :: screen_output      logical :: echo_local     character(:), allocatable :: redirect_str,command,redirect,line     integer :: iunit,iarg,stat,cmdstat       if(present(verbose))then        echo_local=verbose     else        echo_local=.false.     end if      ! No redirection and non-verbose output     if (present(screen_output)) then         redirect = get_temp_filename()         redirect_str =  ">"//redirect//" 2>&1"     else         if (os_is_unix()) then             redirect_str = " >/dev/null 2>&1"         else             redirect_str = " >NUL 2>&1"         end if     end if      ! Empty command     if (len_trim(wrapper)<=0) then         if (echo_local) print *, '+ <EMPTY COMMAND>'         if (present(exitcode)) exitcode = 0         if (present(cmd_success)) cmd_success = .true.         if (present(screen_output)) screen_output = string_t("")         return     end if      ! Init command     command = trim(wrapper%s)      add_arguments: if (present(args)) then         do iarg=1,size(args)             if (len_trim(args(iarg))<=0) cycle             command = trim(command)//' '//args(iarg)%s         end do     endif add_arguments      if (echo_local) print *, '+ ', command      ! Test command     call execute_command_line(command//redirect_str,exitstat=stat,cmdstat=cmdstat)      ! Command successful?     if (present(cmd_success)) cmd_success = cmdstat==0      ! Program exit code?     if (present(exitcode)) exitcode = stat      ! Want screen output?     if (present(screen_output) .and. cmdstat==0) then          allocate(character(len=0) :: screen_output%s)          open(newunit=iunit,file=redirect,status='old',iostat=stat)         if (stat == 0)then            do                call getline(iunit, line, stat)                if (stat /= 0) exit                 screen_output%s = screen_output%s//new_line('a')//line                 if (echo_local) write(*,'(A)') trim(line)            end do             ! Close and delete file            close(iunit,status='delete')          else            call fpm_stop(1,'cannot read temporary file from successful MPI wrapper')         endif      end if  end subroutine run_mpi_wrapper  !> Get MPI library type from the wrapper command. Currently, only OpenMPI is supported integer function which_mpi_library(wrapper,compiler,verbose)     type(string_t), intent(in) :: wrapper     type(compiler_t), intent(in) :: compiler     logical, intent(in), optional :: verbose      logical :: is_mpi_wrapper     integer :: stat      ! Init as currently unsupported library     which_mpi_library = MPI_TYPE_NONE      if (len_trim(wrapper)<=0) return      ! Run mpi wrapper first     call run_mpi_wrapper(wrapper,verbose=verbose,cmd_success=is_mpi_wrapper)      if (is_mpi_wrapper) then          if (compiler%is_intel()) then             which_mpi_library = MPI_TYPE_INTEL             return         end if          ! Attempt to decipher which library this wrapper comes from.          ! OpenMPI responds to '--showme' calls         call run_mpi_wrapper(wrapper,[string_t('--showme')],verbose,&                              exitcode=stat,cmd_success=is_mpi_wrapper)         if (stat==0 .and. is_mpi_wrapper) then             which_mpi_library = MPI_TYPE_OPENMPI             return         endif          ! MPICH responds to '-show' calls         call run_mpi_wrapper(wrapper,[string_t('-show')],verbose,&                              exitcode=stat,cmd_success=is_mpi_wrapper)         if (stat==0 .and. is_mpi_wrapper) then             which_mpi_library = MPI_TYPE_MPICH             return         endif      end if  end function which_mpi_library  !> Test if an MPI wrapper works type(string_t) function mpi_wrapper_query(mpilib,wrapper,command,verbose,error) result(screen)     integer, intent(in) :: mpilib     type(string_t), intent(in) :: wrapper     character(*), intent(in) :: command     logical, intent(in), optional :: verbose     type(error_t), allocatable, intent(out) :: error      logical :: success     character(:), allocatable :: redirect_str,tokens(:),unsupported_msg     type(string_t) :: cmdstr     type(compiler_t) :: mpi_compiler     integer :: stat,cmdstat,ire,length      unsupported_msg = 'the MPI library of wrapper '//wrapper%s//' does not support task '//trim(command)      select case (command)         ! Get MPI compiler name        case ('compiler')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:command')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-compile-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if             ! Take out the first command from the whole line            call remove_newline_characters(screen)            call split(screen%s,tokens,delimiters=' ')            screen%s = trim(adjustl(tokens(1)))         ! Get a list of additional compiler flags        case ('flags')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:compile')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-compile-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if             ! Post-process output            select case (mpilib)               case (MPI_TYPE_OPENMPI)                  ! This library reports the compiler name only                  call remove_newline_characters(screen)               case (MPI_TYPE_MPICH,MPI_TYPE_INTEL)                  ! These libraries report the full command including the compiler name. Remove it if so                  call remove_newline_characters(screen)                  call split(screen%s,tokens)                  ! Remove trailing compiler name                  screen%s = screen%s(len_trim(tokens(1))+1:)               case default                  call fatal_error(error,'invalid MPI library type')                  return            end select         ! Get a list of additional linker flags        case ('link')             select case (mpilib)               case (MPI_TYPE_OPENMPI); cmdstr = string_t('--showme:link')               case (MPI_TYPE_MPICH);   cmdstr = string_t('-link-info')               case (MPI_TYPE_INTEL);   cmdstr = string_t('-show')               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call run_mpi_wrapper(wrapper,[cmdstr],verbose=verbose, &                                 exitcode=stat,cmd_success=success,screen_output=screen)             if (stat/=0 .or. .not.success) then               call syntax_error(error,'local '//MPI_TYPE_NAME(mpilib)//&                                       ' library wrapper does not support flag '//cmdstr%s)               return            end if             select case (mpilib)               case (MPI_TYPE_OPENMPI)                  call remove_newline_characters(screen)               case (MPI_TYPE_MPICH,MPI_TYPE_INTEL)                  ! MPICH reports the full command including the compiler name. Remove it if so                  call remove_newline_characters(screen)                  call split(screen%s,tokens)                  ! Remove trailing compiler name                  screen%s = screen%s(len_trim(tokens(1))+1:)               case default                  call fatal_error(error,unsupported_msg)                  return            end select         ! Get a list of MPI library directories        case ('link_dirs')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                   ! --showme:command returns the build command of this wrapper                  call run_mpi_wrapper(wrapper,[string_t('--showme:libdirs')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:libdirs')                     return                  end if                case default                   call fatal_error(error,unsupported_msg)                  return             end select         ! Get a list of include directories for the MPI headers/modules        case ('incl_dirs')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                  ! --showme:command returns the build command of this wrapper                  call run_mpi_wrapper(wrapper,[string_t('--showme:incdirs')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                  if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:incdirs')                     return                  end if               case default                  call fatal_error(error,unsupported_msg)                  return            end select             call remove_newline_characters(screen)         ! Retrieve library version        case ('version')             select case (mpilib)               case (MPI_TYPE_OPENMPI)                   ! --showme:command returns the build command of this wrapper                  call run_mpi_wrapper(wrapper,[string_t('--showme:version')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local OpenMPI library does not support --showme:version')                     return                  else                     call remove_newline_characters(screen)                  end if                case (MPI_TYPE_MPICH)                   !> MPICH offers command "mpichversion" in the same system folder as the MPI wrappers.                  !> So, attempt to run that first                  cmdstr = string_t('mpichversion')                  call run_mpi_wrapper(cmdstr,verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   ! Second option: run mpich wrapper + "-v"                  if (stat/=0 .or. .not.success) then                     call run_mpi_wrapper(wrapper,[string_t('-v')],verbose=verbose, &                                          exitcode=stat,cmd_success=success,screen_output=screen)                     call remove_newline_characters(screen)                  endif                   ! Third option: mpiexec --version                  if (stat/=0 .or. .not.success) then                      cmdstr = string_t('mpiexec --version')                      call run_mpi_wrapper(cmdstr,verbose=verbose, &                                           exitcode=stat,cmd_success=success,screen_output=screen)                  endif                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'cannot retrieve MPICH library version from <mpichversion, '//wrapper%s//', mpiexec>')                     return                  end if                case (MPI_TYPE_INTEL)                   ! --showme:command returns the build command of this wrapper                  call run_mpi_wrapper(wrapper,[string_t('-v')],verbose=verbose, &                                       exitcode=stat,cmd_success=success,screen_output=screen)                   if (stat/=0 .or. .not.success) then                     call syntax_error(error,'local INTEL MPI library does not support -v')                     return                  else                     call remove_newline_characters(screen)                  end if                case default                   call fatal_error(error,unsupported_msg)                  return             end select             ! Extract version            screen = regex_version_from_text(screen%s,MPI_TYPE_NAME(mpilib)//' library',error)            if (allocated(error)) return         ! Get path to the MPI runner command        case ('runner')             select case (mpilib)               case (MPI_TYPE_OPENMPI,MPI_TYPE_MPICH,MPI_TYPE_MSMPI,MPI_TYPE_INTEL)                  call get_mpi_runner(screen,verbose,error)               case default                  call fatal_error(error,unsupported_msg)                  return            end select         case default;            call fatal_error(error,'an invalid MPI wrapper command ('//command//&                                   ') was invoked for wrapper <'//wrapper%s//'>.')            return     end select   end function mpi_wrapper_query  !> Check if input is a useful linker argument logical function is_link_argument(compiler,string)    type(compiler_t), intent(in) :: compiler    character(*), intent(in) :: string     select case (compiler%id)       case (id_intel_classic_windows,id_intel_llvm_windows)           is_link_argument = string=='/link' &                              .or. str_begins_with_str(string,'/LIBPATH')&                              .or. str_ends_with(string,'.lib') ! always .lib whether static or dynamic       case default            ! fix OpenMPI's Fortran wrapper bug (https://github.com/open-mpi/ompi/issues/11636) here           is_link_argument = (    str_begins_with_str(string,'-L') &                              .or. str_begins_with_str(string,'-l') &                              .or. str_begins_with_str(string,'-Xlinker') &                              .or. string=='-pthread' &                              .or. (str_begins_with_str(string,'-W') .and. &                                    (string/='-Wall') .and. (.not.str_begins_with_str(string,'-Werror'))) ) &                              .and. .not. ( &                                  (get_os_type()==OS_MACOS .and. index(string,'-commons,use_dylibs')>0) )    end select  end function is_link_argument  !> From build, remove optimization and other unnecessary flags subroutine filter_build_arguments(compiler,command)     type(compiler_t), intent(in) :: compiler     type(string_t), intent(inout) :: command     character(len=:), allocatable :: tokens(:)      integer :: i,n,re_i,re_l     logical, allocatable :: keep(:)     logical :: keep_next     character(len=:), allocatable :: module_flag,include_flag      if (len_trim(command)<=0) return      ! Split command into arguments     tokens = shlex_split(command%s)      module_flag  = get_module_flag(compiler,"")     include_flag = get_include_flag(compiler,"")      n = size(tokens)     allocate(keep(n),source=.false.)     keep_next = .false.      do i=1,n          if (get_os_type()==OS_MACOS .and. index(tokens(i),'-commons,use_dylibs')>0) then             keep(i) = .false.             keep_next = .false.         elseif (str_begins_with_str(tokens(i),'-D') .or. &                 str_begins_with_str(tokens(i),'-f') .or. &                 str_begins_with_str(tokens(i),'-I') .or. &                 str_begins_with_str(tokens(i),module_flag) .or. &                 str_begins_with_str(tokens(i),include_flag) .or. &                 tokens(i)=='-pthread' .or. &                 (str_begins_with_str(tokens(i),'-W') .and. tokens(i)/='-Wall' .and. .not.str_begins_with_str(tokens(i),'-Werror')) &                 ) then                    keep(i) = .true.                    if (tokens(i)==module_flag .or. tokens(i)==include_flag .or. tokens(i)=='-I') keep_next = .true.         elseif (keep_next) then             keep(i) = .true.             keep_next = .false.         end if     end do      ! Backfill     command = string_t("")     do i=1,n         if (.not.keep(i)) cycle          command%s = command%s//' '//trim(tokens(i))     end do   end subroutine filter_build_arguments  !> From the linker flags, remove optimization and other unnecessary flags subroutine filter_link_arguments(compiler,command)     type(compiler_t), intent(in) :: compiler     type(string_t), intent(inout) :: command     character(len=:), allocatable :: tokens(:)      integer :: i,n     logical, allocatable :: keep(:)     logical :: keep_next      if (len_trim(command)<=0) return      ! Split command into arguments     tokens = shlex_split(command%s)      n = size(tokens)     allocate(keep(n),source=.false.)     keep_next = .false.      do i=1,n        if (is_link_argument(compiler,tokens(i))) then            keep(i) = .true.            if (tokens(i)=='-L' .or. tokens(i)=='-Xlinker') keep_next = .true.        elseif (keep_next) then            keep(i) = .true.            keep_next = .false.        end if     end do      ! Backfill     command = string_t("")     do i=1,n         if (.not.keep(i)) cycle         command%s = command%s//' '//trim(tokens(i))     end do  end subroutine filter_link_arguments   end module fpm_meta 
fpm_model.f90_stripped                                     module fpm_model use iso_fortran_env, only: int64 use fpm_compiler, only: compiler_t, archiver_t, debug use fpm_dependency, only: dependency_tree_t use fpm_strings, only: string_t, str, len_trim use fpm_manifest_preprocess, only: preprocess_config_t implicit none  private public :: fpm_model_t, srcfile_t, show_model, fortran_features_t  public :: FPM_UNIT_UNKNOWN, FPM_UNIT_PROGRAM, FPM_UNIT_MODULE, &           FPM_UNIT_SUBMODULE, FPM_UNIT_SUBPROGRAM, FPM_UNIT_CSOURCE, &           FPM_UNIT_CHEADER, FPM_SCOPE_UNKNOWN, FPM_SCOPE_LIB, &           FPM_SCOPE_DEP, FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST, &           FPM_UNIT_CPPSOURCE   integer, parameter :: FPM_UNIT_UNKNOWN = -1  integer, parameter :: FPM_UNIT_PROGRAM = 1  integer, parameter :: FPM_UNIT_MODULE = 2  integer, parameter :: FPM_UNIT_SUBMODULE = 3  integer, parameter :: FPM_UNIT_SUBPROGRAM = 4  integer, parameter :: FPM_UNIT_CSOURCE = 5  integer, parameter :: FPM_UNIT_CHEADER = 6  integer, parameter :: FPM_UNIT_CPPSOURCE = 7   integer, parameter :: FPM_SCOPE_UNKNOWN = -1  integer, parameter :: FPM_SCOPE_LIB = 1  integer, parameter :: FPM_SCOPE_DEP = 2  integer, parameter :: FPM_SCOPE_APP = 3  integer, parameter :: FPM_SCOPE_TEST = 4 integer, parameter :: FPM_SCOPE_EXAMPLE = 5   type :: fortran_features_t           logical :: implicit_typing = .false.           logical :: implicit_external = .false.           character(:), allocatable :: source_form end type fortran_features_t   type srcfile_t          character(:), allocatable :: file_name           character(:), allocatable :: exe_name           integer :: unit_scope = FPM_SCOPE_UNKNOWN           type(string_t), allocatable :: modules_provided(:)           integer :: unit_type = FPM_UNIT_UNKNOWN           type(string_t), allocatable :: parent_modules(:)           type(string_t), allocatable :: modules_used(:)           type(string_t), allocatable :: include_dependencies(:)           type(string_t), allocatable :: link_libraries(:)           integer(int64) :: digest  end type srcfile_t    type package_t           character(:), allocatable :: name           type(srcfile_t), allocatable :: sources(:)           type(preprocess_config_t) :: preprocess           character(:), allocatable :: version           logical :: enforce_module_names           type(string_t) :: module_prefix           type(fortran_features_t) :: features  end type package_t     type :: fpm_model_t           character(:), allocatable :: package_name           type(package_t), allocatable :: packages(:)           type(compiler_t) :: compiler           type(archiver_t) :: archiver           character(:), allocatable :: fortran_compile_flags           character(:), allocatable :: c_compile_flags           character(:), allocatable :: cxx_compile_flags           character(:), allocatable :: link_flags           character(:), allocatable :: build_prefix           type(string_t), allocatable :: include_dirs(:)           type(string_t), allocatable :: link_libraries(:)           type(string_t), allocatable :: external_modules(:)           type(dependency_tree_t) :: deps           logical :: include_tests = .true.           logical :: enforce_module_names = .false.           type(string_t) :: module_prefix  end type fpm_model_t  contains   function info_package(p) result(s)          type(package_t), intent(in) :: p     character(:), allocatable :: s      integer :: i      s = s // 'package_t('     s = s // 'name="' // p%name //'"'     s = s // ', sources=['     do i = 1, size(p%sources)         s = s // info_srcfile(p%sources(i))         if (i < size(p%sources)) s = s // ", "     end do     s = s // "]"           s = s // ', enforce_module_names="' // merge('T','F',p%enforce_module_names) // '"'           if (p%enforce_module_names .and. len_trim(p%module_prefix)>0) &     s = s // ', custom_prefix="' // p%module_prefix%s // '"'      s = s // ")"  end function info_package  function info_srcfile(source) result(s)     type(srcfile_t), intent(in) :: source     character(:), allocatable :: s     integer :: i          s = "srcfile_t("          s = s // 'file_name="' // source%file_name // '"'          s = s // ', exe_name="' // source%exe_name // '"'          s = s // ", unit_scope="     select case(source%unit_scope)     case (FPM_SCOPE_UNKNOWN)         s = s // "FPM_SCOPE_UNKNOWN"     case (FPM_SCOPE_LIB)         s = s // "FPM_SCOPE_LIB"     case (FPM_SCOPE_DEP)         s = s // "FPM_SCOPE_DEP"     case (FPM_SCOPE_APP)         s = s // "FPM_SCOPE_APP"     case (FPM_SCOPE_TEST)         s = s // "FPM_SCOPE_TEST"     case (FPM_SCOPE_EXAMPLE)         s = s // "FPM_SCOPE_EXAMPLE"     case default         s = s // "INVALID"     end select          s = s // ", modules_provided=["     do i = 1, size(source%modules_provided)         s = s // '"' // source%modules_provided(i)%s // '"'         if (i < size(source%modules_provided)) s = s // ", "     end do     s = s // "]"     s = s // ", parent_modules=["     do i = 1, size(source%parent_modules)         s = s // '"' // source%parent_modules(i)%s // '"'         if (i < size(source%parent_modules)) s = s // ", "     end do     s = s // "]"          s = s // ", unit_type="     select case(source%unit_type)     case (FPM_UNIT_UNKNOWN)         s = s // "FPM_UNIT_UNKNOWN"     case (FPM_UNIT_PROGRAM)         s = s // "FPM_UNIT_PROGRAM"     case (FPM_UNIT_MODULE)         s = s // "FPM_UNIT_MODULE"     case (FPM_UNIT_SUBMODULE)         s = s // "FPM_UNIT_SUBMODULE"     case (FPM_UNIT_SUBPROGRAM)         s = s // "FPM_UNIT_SUBPROGRAM"     case (FPM_UNIT_CSOURCE)         s = s // "FPM_UNIT_CSOURCE"     case (FPM_UNIT_CPPSOURCE)         s = s // "FPM_UNIT_CPPSOURCE"     case (FPM_UNIT_CHEADER)         s = s // "FPM_UNIT_CHEADER"     case default         s = s // "INVALID"     end select          s = s // ", modules_used=["     do i = 1, size(source%modules_used)         s = s // '"' // source%modules_used(i)%s // '"'         if (i < size(source%modules_used)) s = s // ", "     end do     s = s // "]"          s = s // ", include_dependencies=["     do i = 1, size(source%include_dependencies)         s = s // '"' // source%include_dependencies(i)%s // '"'         if (i < size(source%include_dependencies)) s = s // ", "     end do     s = s // "]"          s = s // ", link_libraries=["     do i = 1, size(source%link_libraries)         s = s // '"' // source%link_libraries(i)%s // '"'         if (i < size(source%link_libraries)) s = s // ", "     end do     s = s // "]"          s = s // ", digest=" // str(source%digest)          s = s // ")" end function info_srcfile  function info_srcfile_short(source) result(s)          type(srcfile_t), intent(in) :: source     character(:), allocatable :: s     s = "srcfile_t("     s = s // 'file_name="' // source%file_name // '"'     s = s // ", ...)" end function info_srcfile_short  function info_model(model) result(s)     type(fpm_model_t), intent(in) :: model     character(:), allocatable :: s     integer :: i          s = "fpm_model_t("          s = s // 'package_name="' // model%package_name // '"'          s = s // ", packages=["     do i = 1, size(model%packages)         s = s // info_package(model%packages(i))         if (i < size(model%packages)) s = s // ", "     end do     s = s // "]"     s = s // ', compiler=(' // debug(model%compiler) // ')'     s = s // ', archiver=(' // debug(model%archiver) // ')'          s = s // ', fortran_compile_flags="' // model%fortran_compile_flags // '"'     s = s // ', c_compile_flags="' // model%c_compile_flags // '"'     s = s // ', cxx_compile_flags="' // model%cxx_compile_flags // '"'     s = s // ', link_flags="' // model%link_flags // '"'     s = s // ', build_prefix="' // model%build_prefix // '"'          s = s // ", link_libraries=["     do i = 1, size(model%link_libraries)         s = s // '"' // model%link_libraries(i)%s // '"'         if (i < size(model%link_libraries)) s = s // ", "     end do     s = s // "]"          s = s // ", external_modules=["     do i = 1, size(model%external_modules)         s = s // '"' // model%external_modules(i)%s // '"'         if (i < size(model%external_modules)) s = s // ", "     end do     s = s // "]"                    s = s // ", deps=dependency_tree_t(...)"           s = s // ', enforce_module_names="' // merge('T','F',model%enforce_module_names) // '"'           if (model%enforce_module_names .and. len_trim(model%module_prefix)>0) &     s = s // ', custom_prefix="' // model%module_prefix%s // '"'           s = s // ")" end function info_model  subroutine show_model(model)          type(fpm_model_t), intent(in) :: model     print *, info_model(model) end subroutine show_model  end module fpm_model 
fpm_model.f90_comments !># The fpm package model !> !> Defines the fpm model data types which encapsulate all information !> required to correctly build a package and its dependencies. !> !> The process (see `[[build_model(subroutine)]]`) for generating a valid `[[fpm_model]]` involves !>  source files discovery ([[fpm_sources]]) and parsing ([[fpm_source_parsing]]). !> !> Once a valid `[[fpm_model]]` has been constructed, it may be passed to `[[fpm_targets:targets_from_sources]]` to !> generate a list of build targets for the backend. !> !>### Enumerations !> !> __Source type:__ `FPM_UNIT_*` !> Describes the type of source file  determines build target generation !> !> The logical order of precedence for assigning `unit_type` is as follows: !> !>``` !> if source-file contains program then !>   unit_type = FPM_UNIT_PROGRAM !> else if source-file contains non-module subroutine/function then !>   unit_type = FPM_UNIT_SUBPROGRAM !> else if source-file contains submodule then !>   unit_type = FPM_UNIT_SUBMODULE !> else if source-file contains module then !>   unit_type = FPM_UNIT_MODULE !> end if !>``` !> !> @note A source file is only designated `FPM_UNIT_MODULE` if it **only** contains modules - no non-module subprograms. !> (This allows tree-shaking/pruning of build targets based on unused module dependencies.) !> !> __Source scope:__ `FPM_SCOPE_*` !> Describes the scoping rules for using modules  controls module dependency resolution !> module fpm_model use iso_fortran_env, only: int64 use fpm_compiler, only: compiler_t, archiver_t, debug use fpm_dependency, only: dependency_tree_t use fpm_strings, only: string_t, str, len_trim use fpm_manifest_preprocess, only: preprocess_config_t implicit none  private public :: fpm_model_t, srcfile_t, show_model, fortran_features_t  public :: FPM_UNIT_UNKNOWN, FPM_UNIT_PROGRAM, FPM_UNIT_MODULE, &           FPM_UNIT_SUBMODULE, FPM_UNIT_SUBPROGRAM, FPM_UNIT_CSOURCE, &           FPM_UNIT_CHEADER, FPM_SCOPE_UNKNOWN, FPM_SCOPE_LIB, &           FPM_SCOPE_DEP, FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST, &           FPM_UNIT_CPPSOURCE  !> Source type unknown integer, parameter :: FPM_UNIT_UNKNOWN = -1 !> Source contains a fortran program integer, parameter :: FPM_UNIT_PROGRAM = 1 !> Source **only** contains one or more fortran modules integer, parameter :: FPM_UNIT_MODULE = 2 !> Source contains one or more fortran submodules integer, parameter :: FPM_UNIT_SUBMODULE = 3 !> Source contains one or more fortran subprogram not within modules integer, parameter :: FPM_UNIT_SUBPROGRAM = 4 !> Source type is c source file integer, parameter :: FPM_UNIT_CSOURCE = 5 !> Source type is c header file integer, parameter :: FPM_UNIT_CHEADER = 6 !> Souce type is c++ source file. integer, parameter :: FPM_UNIT_CPPSOURCE = 7  !> Source has no module-use scope integer, parameter :: FPM_SCOPE_UNKNOWN = -1 !> Module-use scope is library/dependency modules only integer, parameter :: FPM_SCOPE_LIB = 1 !> Module-use scope is library/dependency modules only integer, parameter :: FPM_SCOPE_DEP = 2 !> Module-use scope is library/dependency and app modules integer, parameter :: FPM_SCOPE_APP = 3 !> Module-use scope is library/dependency and test modules integer, parameter :: FPM_SCOPE_TEST = 4 integer, parameter :: FPM_SCOPE_EXAMPLE = 5  !> Enabled Fortran language features type :: fortran_features_t      !> Use default implicit typing     logical :: implicit_typing = .false.      !> Use implicit external interface     logical :: implicit_external = .false.      !> Form to use for all Fortran sources     character(:), allocatable :: source_form end type fortran_features_t  !> Type for describing a source file type srcfile_t     !> File path relative to cwd     character(:), allocatable :: file_name      !> Name of executable for FPM_UNIT_PROGRAM     character(:), allocatable :: exe_name      !> Target module-use scope     integer :: unit_scope = FPM_SCOPE_UNKNOWN      !> Modules provided by this source file (lowerstring)     type(string_t), allocatable :: modules_provided(:)      !> Type of source unit     integer :: unit_type = FPM_UNIT_UNKNOWN      !> Parent modules (submodules only)     type(string_t), allocatable :: parent_modules(:)      !>  Modules USEd by this source file (lowerstring)     type(string_t), allocatable :: modules_used(:)      !> Files INCLUDEd by this source file     type(string_t), allocatable :: include_dependencies(:)      !> Native libraries to link against     type(string_t), allocatable :: link_libraries(:)      !> Current hash     integer(int64) :: digest  end type srcfile_t   !> Type for describing a single package type package_t      !> Name of package     character(:), allocatable :: name      !> Array of sources     type(srcfile_t), allocatable :: sources(:)      !> List of macros.     type(preprocess_config_t) :: preprocess      !> Package version number.     character(:), allocatable :: version      !> Module naming conventions     logical :: enforce_module_names      !> Prefix for all module names     type(string_t) :: module_prefix      !> Language features     type(fortran_features_t) :: features  end type package_t   !> Type describing everything required to build !>  the root package and its dependencies. type :: fpm_model_t      !> Name of root package     character(:), allocatable :: package_name      !> Array of packages (including the root package)     type(package_t), allocatable :: packages(:)      !> Compiler object     type(compiler_t) :: compiler      !> Archiver object     type(archiver_t) :: archiver      !> Command line flags passed to fortran for compilation     character(:), allocatable :: fortran_compile_flags      !> Command line flags passed to C for compilation     character(:), allocatable :: c_compile_flags      !> Command line flags passed to C++ for compilation     character(:), allocatable :: cxx_compile_flags      !> Command line flags passed to the linker     character(:), allocatable :: link_flags      !> Base directory for build     character(:), allocatable :: build_prefix      !> Include directories     type(string_t), allocatable :: include_dirs(:)      !> Native libraries to link against     type(string_t), allocatable :: link_libraries(:)      !> External modules used     type(string_t), allocatable :: external_modules(:)      !> Project dependencies     type(dependency_tree_t) :: deps      !> Whether tests should be added to the build list     logical :: include_tests = .true.      !> Whether module names should be prefixed with the package name     logical :: enforce_module_names = .false.      !> Prefix for all module names     type(string_t) :: module_prefix  end type fpm_model_t  contains   function info_package(p) result(s)     ! Returns representation of package_t     type(package_t), intent(in) :: p     character(:), allocatable :: s      integer :: i      s = s // 'package_t('     s = s // 'name="' // p%name //'"'     s = s // ', sources=['     do i = 1, size(p%sources)         s = s // info_srcfile(p%sources(i))         if (i < size(p%sources)) s = s // ", "     end do     s = s // "]"      ! Print module naming convention     s = s // ', enforce_module_names="' // merge('T','F',p%enforce_module_names) // '"'      ! Print custom prefix     if (p%enforce_module_names .and. len_trim(p%module_prefix)>0) &     s = s // ', custom_prefix="' // p%module_prefix%s // '"'      s = s // ")"  end function info_package  function info_srcfile(source) result(s)     type(srcfile_t), intent(in) :: source     character(:), allocatable :: s     integer :: i     !type srcfile_t     s = "srcfile_t("     !    character(:), allocatable :: file_name     s = s // 'file_name="' // source%file_name // '"'     !    character(:), allocatable :: exe_name     s = s // ', exe_name="' // source%exe_name // '"'     !    integer :: unit_scope = FPM_SCOPE_UNKNOWN     s = s // ", unit_scope="     select case(source%unit_scope)     case (FPM_SCOPE_UNKNOWN)         s = s // "FPM_SCOPE_UNKNOWN"     case (FPM_SCOPE_LIB)         s = s // "FPM_SCOPE_LIB"     case (FPM_SCOPE_DEP)         s = s // "FPM_SCOPE_DEP"     case (FPM_SCOPE_APP)         s = s // "FPM_SCOPE_APP"     case (FPM_SCOPE_TEST)         s = s // "FPM_SCOPE_TEST"     case (FPM_SCOPE_EXAMPLE)         s = s // "FPM_SCOPE_EXAMPLE"     case default         s = s // "INVALID"     end select     !    type(string_t), allocatable :: modules_provided(:)     s = s // ", modules_provided=["     do i = 1, size(source%modules_provided)         s = s // '"' // source%modules_provided(i)%s // '"'         if (i < size(source%modules_provided)) s = s // ", "     end do     s = s // "]"     s = s // ", parent_modules=["     do i = 1, size(source%parent_modules)         s = s // '"' // source%parent_modules(i)%s // '"'         if (i < size(source%parent_modules)) s = s // ", "     end do     s = s // "]"     !    integer :: unit_type = FPM_UNIT_UNKNOWN     s = s // ", unit_type="     select case(source%unit_type)     case (FPM_UNIT_UNKNOWN)         s = s // "FPM_UNIT_UNKNOWN"     case (FPM_UNIT_PROGRAM)         s = s // "FPM_UNIT_PROGRAM"     case (FPM_UNIT_MODULE)         s = s // "FPM_UNIT_MODULE"     case (FPM_UNIT_SUBMODULE)         s = s // "FPM_UNIT_SUBMODULE"     case (FPM_UNIT_SUBPROGRAM)         s = s // "FPM_UNIT_SUBPROGRAM"     case (FPM_UNIT_CSOURCE)         s = s // "FPM_UNIT_CSOURCE"     case (FPM_UNIT_CPPSOURCE)         s = s // "FPM_UNIT_CPPSOURCE"     case (FPM_UNIT_CHEADER)         s = s // "FPM_UNIT_CHEADER"     case default         s = s // "INVALID"     end select     !    type(string_t), allocatable :: modules_used(:)     s = s // ", modules_used=["     do i = 1, size(source%modules_used)         s = s // '"' // source%modules_used(i)%s // '"'         if (i < size(source%modules_used)) s = s // ", "     end do     s = s // "]"     !    type(string_t), allocatable :: include_dependencies(:)     s = s // ", include_dependencies=["     do i = 1, size(source%include_dependencies)         s = s // '"' // source%include_dependencies(i)%s // '"'         if (i < size(source%include_dependencies)) s = s // ", "     end do     s = s // "]"     !    type(string_t), allocatable :: link_libraries(:)     s = s // ", link_libraries=["     do i = 1, size(source%link_libraries)         s = s // '"' // source%link_libraries(i)%s // '"'         if (i < size(source%link_libraries)) s = s // ", "     end do     s = s // "]"     !    integer(int64) :: digest     s = s // ", digest=" // str(source%digest)     !end type srcfile_t     s = s // ")" end function info_srcfile  function info_srcfile_short(source) result(s)     ! Prints a shortened version of srcfile_t     type(srcfile_t), intent(in) :: source     character(:), allocatable :: s     s = "srcfile_t("     s = s // 'file_name="' // source%file_name // '"'     s = s // ", ...)" end function info_srcfile_short  function info_model(model) result(s)     type(fpm_model_t), intent(in) :: model     character(:), allocatable :: s     integer :: i     !type :: fpm_model_t     s = "fpm_model_t("     !    character(:), allocatable :: package_name     s = s // 'package_name="' // model%package_name // '"'     !    type(srcfile_t), allocatable :: sources(:)     s = s // ", packages=["     do i = 1, size(model%packages)         s = s // info_package(model%packages(i))         if (i < size(model%packages)) s = s // ", "     end do     s = s // "]"     s = s // ', compiler=(' // debug(model%compiler) // ')'     s = s // ', archiver=(' // debug(model%archiver) // ')'     !    character(:), allocatable :: fortran_compile_flags     s = s // ', fortran_compile_flags="' // model%fortran_compile_flags // '"'     s = s // ', c_compile_flags="' // model%c_compile_flags // '"'     s = s // ', cxx_compile_flags="' // model%cxx_compile_flags // '"'     s = s // ', link_flags="' // model%link_flags // '"'     s = s // ', build_prefix="' // model%build_prefix // '"'     !    type(string_t), allocatable :: link_libraries(:)     s = s // ", link_libraries=["     do i = 1, size(model%link_libraries)         s = s // '"' // model%link_libraries(i)%s // '"'         if (i < size(model%link_libraries)) s = s // ", "     end do     s = s // "]"     !    type(string_t), allocatable :: external_modules(:)     s = s // ", external_modules=["     do i = 1, size(model%external_modules)         s = s // '"' // model%external_modules(i)%s // '"'         if (i < size(model%external_modules)) s = s // ", "     end do     s = s // "]"     !    type(dependency_tree_t) :: deps     ! TODO: print `dependency_tree_t` properly, which should become part of the     !       model, not imported from another file     s = s // ", deps=dependency_tree_t(...)"      ! Print module naming convention     s = s // ', enforce_module_names="' // merge('T','F',model%enforce_module_names) // '"'      ! Print custom prefix     if (model%enforce_module_names .and. len_trim(model%module_prefix)>0) &     s = s // ', custom_prefix="' // model%module_prefix%s // '"'      !end type fpm_model_t     s = s // ")" end function info_model  subroutine show_model(model)     ! Prints a human readable representation of the Model     type(fpm_model_t), intent(in) :: model     print *, info_model(model) end subroutine show_model  end module fpm_model 
fpm_settings.f90_stripped  module fpm_settings   use fpm_filesystem, only: exists, join_path, get_local_prefix, is_absolute_path, mkdir   use fpm_environment, only: os_is_unix   use fpm_error, only: error_t, fatal_error   use fpm_toml, only: toml_table, toml_error, toml_stat, get_value, toml_load, check_keys   use fpm_os, only: get_current_directory, change_directory, get_absolute_path, convert_to_absolute_path    implicit none   private   public :: fpm_global_settings, get_global_settings, get_registry_settings, official_registry_base_url    character(*), parameter :: official_registry_base_url = 'https://registry-apis.vercel.app'   character(*), parameter :: default_config_file_name = 'config.toml'    type :: fpm_global_settings          character(len=:), allocatable :: path_to_config_folder          character(len=:), allocatable :: config_file_name          type(fpm_registry_settings), allocatable :: registry_settings   contains     procedure :: has_custom_location, full_path, path_to_config_folder_or_empty   end type    type :: fpm_registry_settings                    character(len=:), allocatable :: path               character(len=:), allocatable :: url                         character(len=:), allocatable :: cache_path   end type  contains      subroutine get_global_settings(global_settings, error)          type(fpm_global_settings), intent(inout) :: global_settings          type(error_t), allocatable, intent(out) :: error          type(toml_table), allocatable :: table          type(toml_error), allocatable :: parse_error      type(toml_table), pointer :: registry_table     integer :: stat           if (global_settings%has_custom_location()) then              if (.not. exists(global_settings%path_to_config_folder)) then         call fatal_error(error, "Folder not found: '"//global_settings%path_to_config_folder//"'."); return       end if               if (.not. exists(global_settings%full_path())) then         call fatal_error(error, "File not found: '"//global_settings%full_path()//"'."); return       end if               call convert_to_absolute_path(global_settings%path_to_config_folder, error)       if (allocated(error)) return     else              if (os_is_unix()) then         global_settings%path_to_config_folder = join_path(get_local_prefix(), 'share', 'fpm')       else         global_settings%path_to_config_folder = join_path(get_local_prefix(), 'fpm')       end if               global_settings%config_file_name = default_config_file_name               if (.not. exists(global_settings%full_path())) then         call use_default_registry_settings(global_settings); return       end if     end if           call toml_load(table, global_settings%full_path(), error=parse_error)      if (allocated(parse_error)) then       allocate (error); call move_alloc(parse_error%message, error%message); return     end if      call get_value(table, 'registry', registry_table, requested=.false., stat=stat)      if (stat /= toml_stat%success) then       call fatal_error(error, "Error reading registry from config file '"// &       & global_settings%full_path()//"'."); return     end if           if (associated(registry_table)) then       call get_registry_settings(registry_table, global_settings, error)     else       call use_default_registry_settings(global_settings)     end if   end          subroutine use_default_registry_settings(global_settings)     type(fpm_global_settings), intent(inout) :: global_settings      allocate (global_settings%registry_settings)     global_settings%registry_settings%url = official_registry_base_url     global_settings%registry_settings%cache_path = join_path(global_settings%path_to_config_folder_or_empty(), &     & 'dependencies')   end       subroutine get_registry_settings(table, global_settings, error)          type(toml_table), target, intent(inout) :: table          type(fpm_global_settings), intent(inout) :: global_settings          type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: path, url, cache_path     integer :: stat           character(*), dimension(*), parameter :: valid_keys = [character(10) :: &         & 'path', &         & 'url', &         & 'cache_path' &         & ]      call check_keys(table, valid_keys, error)     if (allocated(error)) return      allocate (global_settings%registry_settings)      if (table%has_key('path')) then       call get_value(table, 'path', path, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading registry path: '"//path//"'."); return       end if     end if      if (allocated(path)) then       if (is_absolute_path(path)) then         global_settings%registry_settings%path = path       else                  call get_absolute_path(join_path(global_settings%path_to_config_folder_or_empty(), path), &         & global_settings%registry_settings%path, error)         if (allocated(error)) return                   if (.not. exists(global_settings%registry_settings%path)) then           call fatal_error(error, "           & "' doesn't exist."); return         end if       end if     end if      if (table%has_key('url')) then       call get_value(table, 'url', url, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading registry url: '"//url//"'."); return       end if     end if      if (allocated(url)) then              if (allocated(path)) then         call fatal_error(error, '       end if       global_settings%registry_settings%url = url     else if (.not. allocated(path)) then       global_settings%registry_settings%url = official_registry_base_url     end if      if (table%has_key('cache_path')) then       call get_value(table, 'cache_path', cache_path, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading path to registry cache: '"//cache_path//"'."); return       end if     end if      if (allocated(cache_path)) then              if (allocated(path)) then         call fatal_error(error, "       end if        if (is_absolute_path(cache_path)) then         if (.not. exists(cache_path)) call mkdir(cache_path)         global_settings%registry_settings%cache_path = cache_path       else         cache_path = join_path(global_settings%path_to_config_folder_or_empty(), cache_path)         if (.not. exists(cache_path)) call mkdir(cache_path)                  call get_absolute_path(cache_path, global_settings%registry_settings%cache_path, error)         if (allocated(error)) return       end if     else if (.not. allocated(path)) then       global_settings%registry_settings%cache_path = &         join_path(global_settings%path_to_config_folder_or_empty(), 'dependencies')     end if   end       elemental logical function has_custom_location(self)     class(fpm_global_settings), intent(in) :: self      has_custom_location = allocated(self%path_to_config_folder) .and. allocated(self%config_file_name)     if (.not. has_custom_location) return     has_custom_location = len_trim(self%path_to_config_folder) > 0 .and. len_trim(self%config_file_name) > 0   end       function full_path(self) result(result)     class(fpm_global_settings), intent(in) :: self     character(len=:), allocatable :: result      result = join_path(self%path_to_config_folder_or_empty(), self%config_file_name)   end       pure function path_to_config_folder_or_empty(self)     class(fpm_global_settings), intent(in) :: self     character(len=:), allocatable :: path_to_config_folder_or_empty      if (allocated(self%path_to_config_folder)) then       path_to_config_folder_or_empty = self%path_to_config_folder     else       path_to_config_folder_or_empty = ""     end if   end end 
fpm_settings.f90_comments !> Manages global settings which are defined in the global config file. module fpm_settings   use fpm_filesystem, only: exists, join_path, get_local_prefix, is_absolute_path, mkdir   use fpm_environment, only: os_is_unix   use fpm_error, only: error_t, fatal_error   use fpm_toml, only: toml_table, toml_error, toml_stat, get_value, toml_load, check_keys   use fpm_os, only: get_current_directory, change_directory, get_absolute_path, convert_to_absolute_path    implicit none   private   public :: fpm_global_settings, get_global_settings, get_registry_settings, official_registry_base_url    character(*), parameter :: official_registry_base_url = 'https://registry-apis.vercel.app'   character(*), parameter :: default_config_file_name = 'config.toml'    type :: fpm_global_settings     !> Path to the global config file excluding the file name.     character(len=:), allocatable :: path_to_config_folder     !> Name of the global config file. The default is `config.toml`.     character(len=:), allocatable :: config_file_name     !> Registry configs.     type(fpm_registry_settings), allocatable :: registry_settings   contains     procedure :: has_custom_location, full_path, path_to_config_folder_or_empty   end type    type :: fpm_registry_settings     !> The path to the local registry. If allocated, the local registry     !> will be used instead of the remote registry and replaces the     !> local cache.     character(len=:), allocatable :: path     !> The URL to the remote registry. Can be used to get packages     !> from the official or a custom registry.     character(len=:), allocatable :: url     !> The path to the cache folder. If not specified, the default cache     !> folders are `~/.local/share/fpm/dependencies` on Unix and     !> `%APPDATA%\local\fpm\dependencies` on Windows.     !> Cannot be used together with `path`.     character(len=:), allocatable :: cache_path   end type  contains   !> Obtain global settings from the global config file.   subroutine get_global_settings(global_settings, error)     !> Global settings to be obtained.     type(fpm_global_settings), intent(inout) :: global_settings     !> Error reading config file.     type(error_t), allocatable, intent(out) :: error     !> TOML table to be filled with global config settings.     type(toml_table), allocatable :: table     !> Error parsing to TOML table.     type(toml_error), allocatable :: parse_error      type(toml_table), pointer :: registry_table     integer :: stat      ! Use custom path to the config file if it was specified.     if (global_settings%has_custom_location()) then       ! Throw error if folder doesn't exist.       if (.not. exists(global_settings%path_to_config_folder)) then         call fatal_error(error, "Folder not found: '"//global_settings%path_to_config_folder//"'."); return       end if        ! Throw error if the file doesn't exist.       if (.not. exists(global_settings%full_path())) then         call fatal_error(error, "File not found: '"//global_settings%full_path()//"'."); return       end if        ! Make sure that the path to the global config file is absolute.       call convert_to_absolute_path(global_settings%path_to_config_folder, error)       if (allocated(error)) return     else       ! Use default path if it wasn't specified.       if (os_is_unix()) then         global_settings%path_to_config_folder = join_path(get_local_prefix(), 'share', 'fpm')       else         global_settings%path_to_config_folder = join_path(get_local_prefix(), 'fpm')       end if        ! Use default file name.       global_settings%config_file_name = default_config_file_name        ! Apply default registry settings and return if config file doesn't exist.       if (.not. exists(global_settings%full_path())) then         call use_default_registry_settings(global_settings); return       end if     end if      ! Load into TOML table.     call toml_load(table, global_settings%full_path(), error=parse_error)      if (allocated(parse_error)) then       allocate (error); call move_alloc(parse_error%message, error%message); return     end if      call get_value(table, 'registry', registry_table, requested=.false., stat=stat)      if (stat /= toml_stat%success) then       call fatal_error(error, "Error reading registry from config file '"// &       & global_settings%full_path()//"'."); return     end if      ! A registry table was found.     if (associated(registry_table)) then       call get_registry_settings(registry_table, global_settings, error)     else       call use_default_registry_settings(global_settings)     end if   end    !> Default registry settings are typically applied if the config file doesn't exist or no registry table was found in   !> the global config file.   subroutine use_default_registry_settings(global_settings)     type(fpm_global_settings), intent(inout) :: global_settings      allocate (global_settings%registry_settings)     global_settings%registry_settings%url = official_registry_base_url     global_settings%registry_settings%cache_path = join_path(global_settings%path_to_config_folder_or_empty(), &     & 'dependencies')   end    !> Read registry settings from the global config file.   subroutine get_registry_settings(table, global_settings, error)     !> The [registry] subtable from the global config file.     type(toml_table), target, intent(inout) :: table     !> The global settings which can be filled with the registry settings.     type(fpm_global_settings), intent(inout) :: global_settings     !> Error handling.     type(error_t), allocatable, intent(out) :: error      character(:), allocatable :: path, url, cache_path     integer :: stat      !> List of valid keys for the dependency table.     character(*), dimension(*), parameter :: valid_keys = [character(10) :: &         & 'path', &         & 'url', &         & 'cache_path' &         & ]      call check_keys(table, valid_keys, error)     if (allocated(error)) return      allocate (global_settings%registry_settings)      if (table%has_key('path')) then       call get_value(table, 'path', path, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading registry path: '"//path//"'."); return       end if     end if      if (allocated(path)) then       if (is_absolute_path(path)) then         global_settings%registry_settings%path = path       else         ! Get canonical, absolute path on both Unix and Windows.         call get_absolute_path(join_path(global_settings%path_to_config_folder_or_empty(), path), &         & global_settings%registry_settings%path, error)         if (allocated(error)) return          ! Check if the path to the registry exists.         if (.not. exists(global_settings%registry_settings%path)) then           call fatal_error(error, "Directory '"//global_settings%registry_settings%path// &           & "' doesn't exist."); return         end if       end if     end if      if (table%has_key('url')) then       call get_value(table, 'url', url, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading registry url: '"//url//"'."); return       end if     end if      if (allocated(url)) then       ! Throw error when both path and url were provided.       if (allocated(path)) then         call fatal_error(error, 'Do not provide both path and url to the registry.'); return       end if       global_settings%registry_settings%url = url     else if (.not. allocated(path)) then       global_settings%registry_settings%url = official_registry_base_url     end if      if (table%has_key('cache_path')) then       call get_value(table, 'cache_path', cache_path, stat=stat)       if (stat /= toml_stat%success) then         call fatal_error(error, "Error reading path to registry cache: '"//cache_path//"'."); return       end if     end if      if (allocated(cache_path)) then       ! Throw error when both path and cache_path were provided.       if (allocated(path)) then         call fatal_error(error, "Do not provide both 'path' and 'cache_path'."); return       end if        if (is_absolute_path(cache_path)) then         if (.not. exists(cache_path)) call mkdir(cache_path)         global_settings%registry_settings%cache_path = cache_path       else         cache_path = join_path(global_settings%path_to_config_folder_or_empty(), cache_path)         if (.not. exists(cache_path)) call mkdir(cache_path)         ! Get canonical, absolute path on both Unix and Windows.         call get_absolute_path(cache_path, global_settings%registry_settings%cache_path, error)         if (allocated(error)) return       end if     else if (.not. allocated(path)) then       global_settings%registry_settings%cache_path = &         join_path(global_settings%path_to_config_folder_or_empty(), 'dependencies')     end if   end    !> True if the global config file is not at the default location.   elemental logical function has_custom_location(self)     class(fpm_global_settings), intent(in) :: self      has_custom_location = allocated(self%path_to_config_folder) .and. allocated(self%config_file_name)     if (.not. has_custom_location) return     has_custom_location = len_trim(self%path_to_config_folder) > 0 .and. len_trim(self%config_file_name) > 0   end    !> The full path to the global config file.   function full_path(self) result(result)     class(fpm_global_settings), intent(in) :: self     character(len=:), allocatable :: result      result = join_path(self%path_to_config_folder_or_empty(), self%config_file_name)   end    !> The path to the global config directory.   pure function path_to_config_folder_or_empty(self)     class(fpm_global_settings), intent(in) :: self     character(len=:), allocatable :: path_to_config_folder_or_empty      if (allocated(self%path_to_config_folder)) then       path_to_config_folder_or_empty = self%path_to_config_folder     else       path_to_config_folder_or_empty = ""     end if   end end 
fpm_source_parsing.f90_stripped                 module fpm_source_parsing use fpm_error, only: error_t, file_parse_error, fatal_error, file_not_found_error use fpm_strings, only: string_t, string_cat, len_trim, split, lower, str_ends_with, fnv_1a, is_fortran_name use fpm_model, only: srcfile_t, &                     FPM_UNIT_UNKNOWN, FPM_UNIT_PROGRAM, FPM_UNIT_MODULE, &                     FPM_UNIT_SUBMODULE, FPM_UNIT_SUBPROGRAM, &                     FPM_UNIT_CSOURCE, FPM_UNIT_CHEADER, FPM_SCOPE_UNKNOWN, &                     FPM_SCOPE_LIB, FPM_SCOPE_DEP, FPM_SCOPE_APP, FPM_SCOPE_TEST, &                     FPM_UNIT_CPPSOURCE use fpm_filesystem, only: read_lines, read_lines_expanded, exists implicit none  private public :: parse_f_source, parse_c_source, parse_use_statement  contains                                   function parse_f_source(f_filename,error) result(f_source)     character(*), intent(in) :: f_filename     type(srcfile_t) :: f_source     type(error_t), allocatable, intent(out) :: error      logical :: inside_module, inside_interface, using, intrinsic_module     integer :: stat     integer :: fh, n_use, n_include, n_mod, n_parent, i, j, ic, pass     type(string_t), allocatable :: file_lines(:), file_lines_lower(:)     character(:), allocatable :: temp_string, mod_name, string_parts(:)      if (.not. exists(f_filename)) then         call file_not_found_error(error, f_filename)         return     end if      f_source%file_name = f_filename      open(newunit=fh,file=f_filename,status='old')     file_lines = read_lines_expanded(fh)     close(fh)                file_lines_lower=file_lines     do i=1,size(file_lines_lower)        file_lines_lower(i)%s=adjustl(lower(file_lines_lower(i)%s))     enddo           if (len_trim(file_lines_lower) > 0) f_source%digest = fnv_1a(file_lines)      do pass = 1,2         n_use = 0         n_include = 0         n_mod = 0         n_parent = 0         inside_module = .false.         inside_interface = .false.         file_loop: do i=1,size(file_lines_lower)                           if (index(file_lines_lower(i)%s,'                 index(file_lines_lower(i)%s,'#') == 1 .or. &                 len_trim(file_lines_lower(i)%s) < 1) then                 cycle             end if                           if (.not.inside_interface .and. &                 parse_subsequence(file_lines_lower(i)%s,'bind','(','c')) then                  do j=i,1,-1                      if (index(file_lines_lower(j)%s,'function') > 0 .or. &                         index(file_lines_lower(j)%s,'subroutine') > 0) then                         f_source%unit_type = FPM_UNIT_SUBPROGRAM                         exit                     end if                      if (j>1) then                          ic = index(file_lines_lower(j-1)%s,'                         if (ic < 1) then                             ic = len(file_lines_lower(j-1)%s)                         end if                          temp_string = trim(file_lines_lower(j-1)%s(1:ic))                         if (index(temp_string,'&') /= len(temp_string)) then                             exit                         end if                      end if                  end do              end if                           if (i > 1) then                 ic = index(file_lines_lower(i-1)%s,'                 if (ic < 1) then                     ic = len(file_lines_lower(i-1)%s)                 end if                 temp_string = trim(file_lines_lower(i-1)%s(1:ic))                 if (len(temp_string) > 0 .and. index(temp_string,'&') == len(temp_string)) then                     cycle                 end if             end if                           if (index(file_lines_lower(i)%s,'interface') == 1) then                  inside_interface = .true.                 cycle              end if                           if (parse_sequence(file_lines_lower(i)%s,'end','interface')) then                  inside_interface = .false.                 cycle              end if                           call parse_use_statement(f_filename,i,file_lines_lower(i)%s,using,intrinsic_module,mod_name,error)             if (allocated(error)) return              if (using) then                                   if (.not.is_fortran_name(mod_name)) cycle                                   if (intrinsic_module) cycle                  n_use = n_use + 1                  if (pass == 2) f_source%modules_used(n_use)%s = mod_name                  cycle              endif                           ic = index(file_lines_lower(i)%s,'include')             if ( ic == 1 ) then                 ic = index(lower(file_lines(i)%s),'include')                 if (index(adjustl(file_lines(i)%s(ic+7:)),'"') == 1 .or. &                     index(adjustl(file_lines(i)%s(ic+7:)),"'") == 1 ) then                      n_include = n_include + 1                      if (pass == 2) then                         f_source%include_dependencies(n_include)%s = &                          & split_n(file_lines(i)%s,n=2,delims="'"//'"',stat=stat)                         if (stat /= 0) then                             call file_parse_error(error,f_filename, &                                   'unable to find include file name',i, &                                   file_lines(i)%s)                             return                         end if                     end if                      cycle                  end if             end if                           if (index(file_lines_lower(i)%s,'module ') == 1) then                                   ic = index(file_lines_lower(i)%s,'                 if (ic < 1) then                     ic = len(file_lines_lower(i)%s)                 end if                 temp_string = trim(file_lines_lower(i)%s(1:ic))                                                                     call split(temp_string,string_parts,' ')                 if (size(string_parts) /= 2) then                     cycle                 end if                  mod_name = trim(adjustl(string_parts(2)))                 if (scan(mod_name,'=(&')>0 ) then                                                                                                         cycle                 end if                  if (.not.is_fortran_name(mod_name)) then                     call file_parse_error(error,f_filename, &                           'empty or invalid name for module',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,mod_name))                     return                 end if                  n_mod = n_mod + 1                  if (pass == 2) then                     f_source%modules_provided(n_mod) = string_t(mod_name)                 end if                  if (f_source%unit_type == FPM_UNIT_UNKNOWN) then                     f_source%unit_type = FPM_UNIT_MODULE                 end if                  if (.not.inside_module) then                     inside_module = .true.                 else                                          if (f_source%unit_type /= FPM_UNIT_PROGRAM) then                         f_source%unit_type = FPM_UNIT_SUBPROGRAM                     end if                 end if                  cycle              end if                           if (index(file_lines_lower(i)%s,'submodule') == 1) then                  mod_name = split_n(file_lines_lower(i)%s,n=3,delims='()',stat=stat)                 if (stat /= 0) then                     call file_parse_error(error,f_filename, &                           'unable to get submodule name',i, &                           file_lines_lower(i)%s)                     return                 end if                 if (.not.is_fortran_name(mod_name)) then                     call file_parse_error(error,f_filename, &                           'empty or invalid name for submodule',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,mod_name))                     return                 end if                  n_mod = n_mod + 1                  temp_string = split_n(file_lines_lower(i)%s,n=2,delims='()',stat=stat)                 if (stat /= 0) then                     call file_parse_error(error,f_filename, &                           'unable to get submodule ancestry',i, &                           file_lines_lower(i)%s)                     return                 end if                  if (f_source%unit_type /= FPM_UNIT_PROGRAM) then                     f_source%unit_type = FPM_UNIT_SUBMODULE                 end if                  n_use = n_use + 1                  inside_module = .true.                  n_parent = n_parent + 1                  if (pass == 2) then                      if (index(temp_string,':') > 0) then                          temp_string = temp_string(index(temp_string,':')+1:)                      end if                      if (.not.is_fortran_name(temp_string)) then                         call file_parse_error(error,f_filename, &                           'empty or invalid name for submodule parent',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,temp_string))                         return                     end if                      f_source%modules_used(n_use)%s = temp_string                     f_source%parent_modules(n_parent)%s = temp_string                     f_source%modules_provided(n_mod)%s = mod_name                  end if                  cycle              end if                                        if (index(file_lines_lower(i)%s,'program ') == 1) then                  temp_string = split_n(file_lines_lower(i)%s,n=2,delims=' ',stat=stat)                 if (stat == 0) then                      if (scan(temp_string,'=(')>0 ) then                                                                                                    cycle                     end if                  end if                  f_source%unit_type = FPM_UNIT_PROGRAM                  cycle              end if                                        if (parse_sequence(file_lines_lower(i)%s,'end','module') .or. &                 parse_sequence(file_lines_lower(i)%s,'end','submodule')) then                  inside_module = .false.                 cycle              end if                           if (.not.inside_module .and. f_source%unit_type /= FPM_UNIT_PROGRAM) then                  f_source%unit_type = FPM_UNIT_SUBPROGRAM              end if          end do file_loop                            if (inside_module .and. f_source%unit_type == FPM_UNIT_MODULE) then             f_source%unit_type = FPM_UNIT_SUBPROGRAM         end if          if (pass == 1) then             allocate(f_source%modules_used(n_use))             allocate(f_source%include_dependencies(n_include))             allocate(f_source%modules_provided(n_mod))             allocate(f_source%parent_modules(n_parent))         end if      end do  end function parse_f_source         function parse_c_source(c_filename,error) result(c_source)     character(*), intent(in) :: c_filename     type(srcfile_t) :: c_source     type(error_t), allocatable, intent(out) :: error      integer :: fh, n_include, i, pass, stat     type(string_t), allocatable :: file_lines(:)      c_source%file_name = c_filename      if (str_ends_with(lower(c_filename), ".c")) then          c_source%unit_type = FPM_UNIT_CSOURCE      else if (str_ends_with(lower(c_filename), ".h")) then          c_source%unit_type = FPM_UNIT_CHEADER      else if (str_ends_with(lower(c_filename), ".cpp")) then          c_source%unit_type = FPM_UNIT_CPPSOURCE      end if      allocate(c_source%modules_used(0))     allocate(c_source%modules_provided(0))     allocate(c_source%parent_modules(0))      open(newunit=fh,file=c_filename,status='old')     file_lines = read_lines(fh)     close(fh)           if (len_trim(file_lines) < 1) then         c_source%unit_type = FPM_UNIT_UNKNOWN         return     end if      c_source%digest = fnv_1a(file_lines)      do pass = 1,2         n_include = 0         file_loop: do i=1,size(file_lines)                           if (index(adjustl(lower(file_lines(i)%s)),'#include') == 1 .and. &                 index(file_lines(i)%s,'"') > 0) then                  n_include = n_include + 1                  if (pass == 2) then                      c_source%include_dependencies(n_include)%s = &                      &   split_n(file_lines(i)%s,n=2,delims='"',stat=stat)                     if (stat /= 0) then                         call file_parse_error(error,c_filename, &                             'unable to get c include file',i, &                             file_lines(i)%s,index(file_lines(i)%s,'"'))                         return                     end if                  end if              end if          end do file_loop          if (pass == 1) then             allocate(c_source%include_dependencies(n_include))         end if      end do  end function parse_c_source           function split_n(string,delims,n,stat) result(substring)      character(*), intent(in) :: string     character(*), intent(in) :: delims     integer, intent(in) :: n     integer, intent(out) :: stat     character(:), allocatable :: substring      integer :: i     character(:), allocatable :: string_parts(:)      call split(string,string_parts,delims)      if (n<1) then         i = size(string_parts) + n         if (i < 1) then             allocate(character(len=0) :: substring)              stat = 1             return         end if     else         i = n     end if      if (i>size(string_parts)) then         allocate(character(len=0) :: substring)          stat = 1         return     end if      substring = trim(adjustl(string_parts(i)))     stat = 0  end function split_n     function parse_subsequence(string,t1,t2,t3,t4) result(found)     character(*), intent(in) :: string     character(*), intent(in) :: t1     character(*), intent(in), optional :: t2, t3, t4     logical :: found      integer :: offset, i      found = .false.     offset = 1      do          i = index(string(offset:),t1)          if (i == 0) return          offset = offset + i - 1          found = parse_sequence(string(offset:),t1,t2,t3,t4)          if (found) return          offset = offset + len(t1)          if (offset > len(string)) return      end do  end function parse_subsequence    function parse_sequence(string,t1,t2,t3,t4) result(found)     character(*), intent(in) :: string     character(*), intent(in) :: t1     character(*), intent(in), optional :: t2, t3, t4     logical :: found      integer :: post, n, incr, pos, token_n     logical :: match      n = len(string)     found = .false.     pos = 1      do token_n=1,4          do while (pos <= n)             if (string(pos:pos) /= ' ') then                 exit             end if             pos = pos + 1         end do          select case(token_n)         case(1)             incr = len(t1)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t1         case(2)             if (.not.present(t2)) exit             incr = len(t2)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t2         case(3)             if (.not.present(t3)) exit             incr = len(t3)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t3         case(4)             if (.not.present(t4)) exit             incr = len(t4)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t4         case default             exit         end select          if (.not.match) then             return         end if          pos = pos + incr      end do      found = .true.  end function parse_sequence    subroutine parse_use_statement(f_filename,i,line,use_stmt,is_intrinsic,module_name,error)           character(*), intent(in) :: f_filename     integer, intent(in) :: i           character(*), intent(in) :: line           logical, intent(out) :: use_stmt           logical, intent(out) :: is_intrinsic           character(:), allocatable, intent(out) :: module_name           type(error_t), allocatable, intent(out) :: error      character(15), parameter :: INTRINSIC_NAMES(*) =  &                                  ['iso_c_binding  ', &                                   'iso_fortran_env', &                                   'ieee_arithmetic', &                                   'ieee_exceptions', &                                   'ieee_features  ', &                                   'omp_lib        ']      character(len=:), allocatable :: temp_string     integer :: colons,intr,nonintr,j,stat     logical :: has_intrinsic_name      use_stmt      = .false.     is_intrinsic  = .false.     if (len_trim(line)<=0) return           if (line(1:1)==' ') then         call fatal_error(error,'internal_error: source file line is not trim(adjustl()) on input to parse_use_statement')         return     end if           use_stmt = index(line,'use ')==1 .or. index(line,'use::')==1 .or. index(line,'use,')==1     if (.not.use_stmt) return     colons   = index(line,'::')     nonintr  = 0     intr     = 0      have_colons: if (colons>3) then                   nonintr = index(line(1:colons-1),'non_intrinsic')         if (nonintr==0) intr = index(line(1:colons-1),'intrinsic')           temp_string = split_n(line,delims=':',n=2,stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                     'unable to find used module name',i, &                     line,colons)             return         end if          module_name = split_n(temp_string,delims=' ,',n=1,stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                      'unable to find used module name',i, &                      line)             return         end if      else          module_name = split_n(line,n=2,delims=' ,',stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                     'unable to find used module name',i, &                     line)             return         end if      end if have_colons           has_intrinsic_name = any([(index(module_name,trim(INTRINSIC_NAMES(j)))>0, &                              j=1,size(INTRINSIC_NAMES))])     if (intr>0 .and. .not.has_intrinsic_name) then                                      if (index(module_name,'&')<=0) then             call file_parse_error(error,f_filename, &                                   'module '//module_name//' is declared intrinsic but it is not ',i, &                                   line)             return         endif     endif           is_intrinsic = nonintr==0 .and. &                     (intr>0 .or. has_intrinsic_name)  end subroutine parse_use_statement    end module fpm_source_parsing  
fpm_source_parsing.f90_comments !># Parsing of package source files !> !> This module exposes two functions, `[[parse_f_source]]` and `[[parse_c_source]]`, !> which perform a rudimentary parsing of fortran and c source files !> in order to extract information required for module dependency tracking. !> !> Both functions additionally calculate and store a file digest (hash) which !> is used by the backend ([[fpm_backend]]) to skip compilation of unmodified sources. !> !> Both functions return an instance of the [[srcfile_t]] type. !> !> For more information, please read the documentation for each function: !> !> - `[[parse_f_source]]` !> - `[[parse_c_source]]` !> module fpm_source_parsing use fpm_error, only: error_t, file_parse_error, fatal_error, file_not_found_error use fpm_strings, only: string_t, string_cat, len_trim, split, lower, str_ends_with, fnv_1a, is_fortran_name use fpm_model, only: srcfile_t, &                     FPM_UNIT_UNKNOWN, FPM_UNIT_PROGRAM, FPM_UNIT_MODULE, &                     FPM_UNIT_SUBMODULE, FPM_UNIT_SUBPROGRAM, &                     FPM_UNIT_CSOURCE, FPM_UNIT_CHEADER, FPM_SCOPE_UNKNOWN, &                     FPM_SCOPE_LIB, FPM_SCOPE_DEP, FPM_SCOPE_APP, FPM_SCOPE_TEST, &                     FPM_UNIT_CPPSOURCE use fpm_filesystem, only: read_lines, read_lines_expanded, exists implicit none  private public :: parse_f_source, parse_c_source, parse_use_statement  contains  !> Parsing of free-form fortran source files !> !> The following statements are recognised and parsed: !> !> - `Module`/`submodule`/`program` declaration !> - Module `use` statement !> - `include` statement !> !> @note Intrinsic modules used by sources are not listed in !> the `modules_used` field of source objects. !> !> @note Submodules are treated as normal modules which `use` their !> corresponding parent modules. !> !>### Parsing limitations !> !> __Statements must not continued onto another line !>  except for an `only:` list in the `use` statement.__ !> !> This is supported: !> !>```fortran !> use my_module, only: & !>      my_var, my_function, my_subroutine !>``` !> !> This is __NOT supported:__ !> !>```fortran !> use & !>    my_module !>``` !> function parse_f_source(f_filename,error) result(f_source)     character(*), intent(in) :: f_filename     type(srcfile_t) :: f_source     type(error_t), allocatable, intent(out) :: error      logical :: inside_module, inside_interface, using, intrinsic_module     integer :: stat     integer :: fh, n_use, n_include, n_mod, n_parent, i, j, ic, pass     type(string_t), allocatable :: file_lines(:), file_lines_lower(:)     character(:), allocatable :: temp_string, mod_name, string_parts(:)      if (.not. exists(f_filename)) then         call file_not_found_error(error, f_filename)         return     end if      f_source%file_name = f_filename      open(newunit=fh,file=f_filename,status='old')     file_lines = read_lines_expanded(fh)     close(fh)      ! for efficiency in parsing make a lowercase left-adjusted copy of the file     ! Need a copy because INCLUDE (and #include) file arguments are case-sensitive     file_lines_lower=file_lines     do i=1,size(file_lines_lower)        file_lines_lower(i)%s=adjustl(lower(file_lines_lower(i)%s))     enddo      ! fnv_1a can only be applied to non-zero-length arrays     if (len_trim(file_lines_lower) > 0) f_source%digest = fnv_1a(file_lines)      do pass = 1,2         n_use = 0         n_include = 0         n_mod = 0         n_parent = 0         inside_module = .false.         inside_interface = .false.         file_loop: do i=1,size(file_lines_lower)              ! Skip comment lines and preprocessor directives             if (index(file_lines_lower(i)%s,'!') == 1 .or. &                 index(file_lines_lower(i)%s,'#') == 1 .or. &                 len_trim(file_lines_lower(i)%s) < 1) then                 cycle             end if              ! Detect exported C-API via bind(C)             if (.not.inside_interface .and. &                 parse_subsequence(file_lines_lower(i)%s,'bind','(','c')) then                  do j=i,1,-1                      if (index(file_lines_lower(j)%s,'function') > 0 .or. &                         index(file_lines_lower(j)%s,'subroutine') > 0) then                         f_source%unit_type = FPM_UNIT_SUBPROGRAM                         exit                     end if                      if (j>1) then                          ic = index(file_lines_lower(j-1)%s,'!')                         if (ic < 1) then                             ic = len(file_lines_lower(j-1)%s)                         end if                          temp_string = trim(file_lines_lower(j-1)%s(1:ic))                         if (index(temp_string,'&') /= len(temp_string)) then                             exit                         end if                      end if                  end do              end if              ! Skip lines that are continued: not statements             if (i > 1) then                 ic = index(file_lines_lower(i-1)%s,'!')                 if (ic < 1) then                     ic = len(file_lines_lower(i-1)%s)                 end if                 temp_string = trim(file_lines_lower(i-1)%s(1:ic))                 if (len(temp_string) > 0 .and. index(temp_string,'&') == len(temp_string)) then                     cycle                 end if             end if              ! Detect beginning of interface block             if (index(file_lines_lower(i)%s,'interface') == 1) then                  inside_interface = .true.                 cycle              end if              ! Detect end of interface block             if (parse_sequence(file_lines_lower(i)%s,'end','interface')) then                  inside_interface = .false.                 cycle              end if              ! Process 'USE' statements             call parse_use_statement(f_filename,i,file_lines_lower(i)%s,using,intrinsic_module,mod_name,error)             if (allocated(error)) return              if (using) then                  ! Not a valid module name?                 if (.not.is_fortran_name(mod_name)) cycle                  ! Valid intrinsic module: not a dependency                 if (intrinsic_module) cycle                  n_use = n_use + 1                  if (pass == 2) f_source%modules_used(n_use)%s = mod_name                  cycle              endif              ! Process 'INCLUDE' statements             ic = index(file_lines_lower(i)%s,'include')             if ( ic == 1 ) then                 ic = index(lower(file_lines(i)%s),'include')                 if (index(adjustl(file_lines(i)%s(ic+7:)),'"') == 1 .or. &                     index(adjustl(file_lines(i)%s(ic+7:)),"'") == 1 ) then                      n_include = n_include + 1                      if (pass == 2) then                         f_source%include_dependencies(n_include)%s = &                          & split_n(file_lines(i)%s,n=2,delims="'"//'"',stat=stat)                         if (stat /= 0) then                             call file_parse_error(error,f_filename, &                                   'unable to find include file name',i, &                                   file_lines(i)%s)                             return                         end if                     end if                      cycle                  end if             end if              ! Extract name of module if is module             if (index(file_lines_lower(i)%s,'module ') == 1) then                  ! Remove any trailing comments                 ic = index(file_lines_lower(i)%s,'!')-1                 if (ic < 1) then                     ic = len(file_lines_lower(i)%s)                 end if                 temp_string = trim(file_lines_lower(i)%s(1:ic))                  ! R1405 module-stmt := "MODULE" module-name                 ! module-stmt has two space-delimited parts only                 ! (no line continuations)                 call split(temp_string,string_parts,' ')                 if (size(string_parts) /= 2) then                     cycle                 end if                  mod_name = trim(adjustl(string_parts(2)))                 if (scan(mod_name,'=(&')>0 ) then                     ! Ignore these cases:                     ! module <something>&                     ! module =*                     ! module (i)                     cycle                 end if                  if (.not.is_fortran_name(mod_name)) then                     call file_parse_error(error,f_filename, &                           'empty or invalid name for module',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,mod_name))                     return                 end if                  n_mod = n_mod + 1                  if (pass == 2) then                     f_source%modules_provided(n_mod) = string_t(mod_name)                 end if                  if (f_source%unit_type == FPM_UNIT_UNKNOWN) then                     f_source%unit_type = FPM_UNIT_MODULE                 end if                  if (.not.inside_module) then                     inside_module = .true.                 else                     ! Must have missed an end module statement (can't assume a pure module)                     if (f_source%unit_type /= FPM_UNIT_PROGRAM) then                         f_source%unit_type = FPM_UNIT_SUBPROGRAM                     end if                 end if                  cycle              end if              ! Extract name of submodule if is submodule             if (index(file_lines_lower(i)%s,'submodule') == 1) then                  mod_name = split_n(file_lines_lower(i)%s,n=3,delims='()',stat=stat)                 if (stat /= 0) then                     call file_parse_error(error,f_filename, &                           'unable to get submodule name',i, &                           file_lines_lower(i)%s)                     return                 end if                 if (.not.is_fortran_name(mod_name)) then                     call file_parse_error(error,f_filename, &                           'empty or invalid name for submodule',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,mod_name))                     return                 end if                  n_mod = n_mod + 1                  temp_string = split_n(file_lines_lower(i)%s,n=2,delims='()',stat=stat)                 if (stat /= 0) then                     call file_parse_error(error,f_filename, &                           'unable to get submodule ancestry',i, &                           file_lines_lower(i)%s)                     return                 end if                  if (f_source%unit_type /= FPM_UNIT_PROGRAM) then                     f_source%unit_type = FPM_UNIT_SUBMODULE                 end if                  n_use = n_use + 1                  inside_module = .true.                  n_parent = n_parent + 1                  if (pass == 2) then                      if (index(temp_string,':') > 0) then                          temp_string = temp_string(index(temp_string,':')+1:)                      end if                      if (.not.is_fortran_name(temp_string)) then                         call file_parse_error(error,f_filename, &                           'empty or invalid name for submodule parent',i, &                           file_lines_lower(i)%s, index(file_lines_lower(i)%s,temp_string))                         return                     end if                      f_source%modules_used(n_use)%s = temp_string                     f_source%parent_modules(n_parent)%s = temp_string                     f_source%modules_provided(n_mod)%s = mod_name                  end if                  cycle              end if              ! Detect if contains a program             !  (no modules allowed after program def)             if (index(file_lines_lower(i)%s,'program ') == 1) then                  temp_string = split_n(file_lines_lower(i)%s,n=2,delims=' ',stat=stat)                 if (stat == 0) then                      if (scan(temp_string,'=(')>0 ) then                         ! Ignore:                         ! program =*                         ! program (i) =*                         cycle                     end if                  end if                  f_source%unit_type = FPM_UNIT_PROGRAM                  cycle              end if              ! Parse end module statement             !  (to check for code outside of modules)             if (parse_sequence(file_lines_lower(i)%s,'end','module') .or. &                 parse_sequence(file_lines_lower(i)%s,'end','submodule')) then                  inside_module = .false.                 cycle              end if              ! Any statements not yet parsed are assumed to be other code statements             if (.not.inside_module .and. f_source%unit_type /= FPM_UNIT_PROGRAM) then                  f_source%unit_type = FPM_UNIT_SUBPROGRAM              end if          end do file_loop          ! If unable to parse end of module statement, then can't assume pure module         !  (there could be non-module subprograms present)         if (inside_module .and. f_source%unit_type == FPM_UNIT_MODULE) then             f_source%unit_type = FPM_UNIT_SUBPROGRAM         end if          if (pass == 1) then             allocate(f_source%modules_used(n_use))             allocate(f_source%include_dependencies(n_include))             allocate(f_source%modules_provided(n_mod))             allocate(f_source%parent_modules(n_parent))         end if      end do  end function parse_f_source   !> Parsing of c, cpp source files !> !> The following statements are recognised and parsed: !> !> - `#include` preprocessor statement !> function parse_c_source(c_filename,error) result(c_source)     character(*), intent(in) :: c_filename     type(srcfile_t) :: c_source     type(error_t), allocatable, intent(out) :: error      integer :: fh, n_include, i, pass, stat     type(string_t), allocatable :: file_lines(:)      c_source%file_name = c_filename      if (str_ends_with(lower(c_filename), ".c")) then          c_source%unit_type = FPM_UNIT_CSOURCE      else if (str_ends_with(lower(c_filename), ".h")) then          c_source%unit_type = FPM_UNIT_CHEADER      else if (str_ends_with(lower(c_filename), ".cpp")) then          c_source%unit_type = FPM_UNIT_CPPSOURCE      end if      allocate(c_source%modules_used(0))     allocate(c_source%modules_provided(0))     allocate(c_source%parent_modules(0))      open(newunit=fh,file=c_filename,status='old')     file_lines = read_lines(fh)     close(fh)      ! Ignore empty files, returned as FPM_UNIT_UNKNOWN     if (len_trim(file_lines) < 1) then         c_source%unit_type = FPM_UNIT_UNKNOWN         return     end if      c_source%digest = fnv_1a(file_lines)      do pass = 1,2         n_include = 0         file_loop: do i=1,size(file_lines)              ! Process 'INCLUDE' statements             if (index(adjustl(lower(file_lines(i)%s)),'#include') == 1 .and. &                 index(file_lines(i)%s,'"') > 0) then                  n_include = n_include + 1                  if (pass == 2) then                      c_source%include_dependencies(n_include)%s = &                      &   split_n(file_lines(i)%s,n=2,delims='"',stat=stat)                     if (stat /= 0) then                         call file_parse_error(error,c_filename, &                             'unable to get c include file',i, &                             file_lines(i)%s,index(file_lines(i)%s,'"'))                         return                     end if                  end if              end if          end do file_loop          if (pass == 1) then             allocate(c_source%include_dependencies(n_include))         end if      end do  end function parse_c_source  !> Split a string on one or more delimeters !>  and return the nth substring if it exists !> !> n=0  will return the last item !> n=-1 will return the penultimate item etc. !> !> stat = 1 on return if the index !>  is not found !> function split_n(string,delims,n,stat) result(substring)      character(*), intent(in) :: string     character(*), intent(in) :: delims     integer, intent(in) :: n     integer, intent(out) :: stat     character(:), allocatable :: substring      integer :: i     character(:), allocatable :: string_parts(:)      call split(string,string_parts,delims)      if (n<1) then         i = size(string_parts) + n         if (i < 1) then             allocate(character(len=0) :: substring) ! ifort bus error otherwise             stat = 1             return         end if     else         i = n     end if      if (i>size(string_parts)) then         allocate(character(len=0) :: substring) ! ifort bus error otherwise         stat = 1         return     end if      substring = trim(adjustl(string_parts(i)))     stat = 0  end function split_n   !> Parse a subsequence of blank-separated tokens within a string !>  (see parse_sequence) function parse_subsequence(string,t1,t2,t3,t4) result(found)     character(*), intent(in) :: string     character(*), intent(in) :: t1     character(*), intent(in), optional :: t2, t3, t4     logical :: found      integer :: offset, i      found = .false.     offset = 1      do          i = index(string(offset:),t1)          if (i == 0) return          offset = offset + i - 1          found = parse_sequence(string(offset:),t1,t2,t3,t4)          if (found) return          offset = offset + len(t1)          if (offset > len(string)) return      end do  end function parse_subsequence  !> Helper utility to parse sequences of tokens !> that may be optionally separated by zero or more spaces function parse_sequence(string,t1,t2,t3,t4) result(found)     character(*), intent(in) :: string     character(*), intent(in) :: t1     character(*), intent(in), optional :: t2, t3, t4     logical :: found      integer :: post, n, incr, pos, token_n     logical :: match      n = len(string)     found = .false.     pos = 1      do token_n=1,4          do while (pos <= n)             if (string(pos:pos) /= ' ') then                 exit             end if             pos = pos + 1         end do          select case(token_n)         case(1)             incr = len(t1)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t1         case(2)             if (.not.present(t2)) exit             incr = len(t2)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t2         case(3)             if (.not.present(t3)) exit             incr = len(t3)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t3         case(4)             if (.not.present(t4)) exit             incr = len(t4)             if (pos+incr-1>n) return             match = string(pos:pos+incr-1) == t4         case default             exit         end select          if (.not.match) then             return         end if          pos = pos + incr      end do      found = .true.  end function parse_sequence  ! USE [, intrinsic] :: module_name [, only: only_list] ! USE [, non_intrinsic] :: module_name [, only: only_list] subroutine parse_use_statement(f_filename,i,line,use_stmt,is_intrinsic,module_name,error)      !> Current file name and line number (for error messaging)     character(*), intent(in) :: f_filename     integer, intent(in) :: i      !> The line being parsed. MUST BE preprocessed with trim(adjustl()     character(*), intent(in) :: line      !> Does this line contain a `use` statement?     logical, intent(out) :: use_stmt      !> Is the module in this statement intrinsic?     logical, intent(out) :: is_intrinsic      !> used module name     character(:), allocatable, intent(out) :: module_name      !> Error handling     type(error_t), allocatable, intent(out) :: error      character(15), parameter :: INTRINSIC_NAMES(*) =  &                                  ['iso_c_binding  ', &                                   'iso_fortran_env', &                                   'ieee_arithmetic', &                                   'ieee_exceptions', &                                   'ieee_features  ', &                                   'omp_lib        ']      character(len=:), allocatable :: temp_string     integer :: colons,intr,nonintr,j,stat     logical :: has_intrinsic_name      use_stmt      = .false.     is_intrinsic  = .false.     if (len_trim(line)<=0) return      ! Quick check that the line is preprocessed     if (line(1:1)==' ') then         call fatal_error(error,'internal_error: source file line is not trim(adjustl()) on input to parse_use_statement')         return     end if      ! 'use' should be the first string in the adjustl line     use_stmt = index(line,'use ')==1 .or. index(line,'use::')==1 .or. index(line,'use,')==1     if (.not.use_stmt) return     colons   = index(line,'::')     nonintr  = 0     intr     = 0      have_colons: if (colons>3) then          ! there may be an intrinsic/non-intrinsic spec         nonintr = index(line(1:colons-1),'non_intrinsic')         if (nonintr==0) intr = index(line(1:colons-1),'intrinsic')           temp_string = split_n(line,delims=':',n=2,stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                     'unable to find used module name',i, &                     line,colons)             return         end if          module_name = split_n(temp_string,delims=' ,',n=1,stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                      'unable to find used module name',i, &                      line)             return         end if      else          module_name = split_n(line,n=2,delims=' ,',stat=stat)         if (stat /= 0) then             call file_parse_error(error,f_filename, &                     'unable to find used module name',i, &                     line)             return         end if      end if have_colons      ! If declared intrinsic, check that it is true     has_intrinsic_name = any([(index(module_name,trim(INTRINSIC_NAMES(j)))>0, &                              j=1,size(INTRINSIC_NAMES))])     if (intr>0 .and. .not.has_intrinsic_name) then          ! An intrinsic module was not found. Its name could be in the next line,         ! in which case, we just skip this check. The compiler will do the job if the name is invalid.          ! Module name was not read: it's in the next line         if (index(module_name,'&')<=0) then             call file_parse_error(error,f_filename, &                                   'module '//module_name//' is declared intrinsic but it is not ',i, &                                   line)             return         endif     endif      ! Should we treat this as an intrinsic module     is_intrinsic = nonintr==0 .and. & ! not declared non-intrinsic                    (intr>0 .or. has_intrinsic_name)  end subroutine parse_use_statement    end module fpm_source_parsing  
fpm_sources.f90_stripped      module fpm_sources use fpm_error, only: error_t use fpm_model, only: srcfile_t, FPM_UNIT_PROGRAM use fpm_filesystem, only: basename, canon_path, dirname, join_path, list_files, is_hidden_file use fpm_environment, only: get_os_type,OS_WINDOWS use fpm_strings, only: lower, str_ends_with, string_t, operator(.in.) use fpm_source_parsing, only: parse_f_source, parse_c_source use fpm_manifest_executable, only: executable_config_t implicit none  private public :: add_sources_from_dir, add_executable_sources public :: get_exe_name_with_suffix  character(4), parameter :: fortran_suffixes(2) = [".f90", &                                                   ".f  "] character(4), parameter :: c_suffixes(4) = [".c  ", ".h  ", ".cpp", ".hpp"]  contains    function parse_source(source_file_path,custom_f_ext,error) result(source)     character(*), intent(in) :: source_file_path     type(string_t), optional, intent(in) :: custom_f_ext(:)     type(error_t), allocatable, intent(out) :: error     type(srcfile_t)  :: source     type(string_t), allocatable :: f_ext(:)      call list_fortran_suffixes(f_ext,custom_f_ext)      if (str_ends_with(lower(source_file_path), f_ext)) then          source = parse_f_source(source_file_path, error)          if (source%unit_type == FPM_UNIT_PROGRAM) then             source%exe_name = basename(source_file_path,suffix=.false.)         end if      else if (str_ends_with(lower(source_file_path), c_suffixes)) then          source = parse_c_source(source_file_path,error)      endif      if (allocated(error)) then         return     end if  end function parse_source   subroutine list_fortran_suffixes(suffixes,with_f_ext)     type(string_t), allocatable, intent(out) :: suffixes(:)          type(string_t), intent(in), optional :: with_f_ext(:)      integer :: ndefault,nuser,i      ndefault = size(fortran_suffixes)     nuser    = 0; if (present(with_f_ext)) nuser = size(with_f_ext)      allocate(suffixes(ndefault + nuser))     do i=1,ndefault         suffixes(i) = string_t(fortran_suffixes(i))     end do     if (present(with_f_ext)) then         do i=1,nuser             suffixes(ndefault+i) = string_t(with_f_ext(i)%s)         end do     endif  end subroutine list_fortran_suffixes   subroutine add_sources_from_dir(sources,directory,scope,with_executables,with_f_ext,recurse,error)          type(srcfile_t), allocatable, intent(inout), target :: sources(:)          character(*), intent(in) :: directory          integer, intent(in) :: scope          logical, intent(in), optional :: with_executables          type(string_t), intent(in), optional :: with_f_ext(:)          logical, intent(in), optional :: recurse          type(error_t), allocatable, intent(out) :: error      integer :: i     logical, allocatable :: is_source(:), exclude_source(:)     logical :: recurse_     type(string_t), allocatable :: file_names(:)     type(string_t), allocatable :: src_file_names(:),f_ext(:)     type(string_t), allocatable :: existing_src_files(:)     type(srcfile_t), allocatable :: dir_sources(:)      recurse_ = .true.     if (present(recurse)) recurse_ = recurse          call list_files(directory, file_names,recurse=recurse_)      if (allocated(sources)) then         allocate(existing_src_files(size(sources)))         do i=1,size(sources)             existing_src_files(i)%s = canon_path(sources(i)%file_name)         end do     else         allocate(existing_src_files(0))     end if           call list_fortran_suffixes(f_ext,with_f_ext)      is_source = [(.not.(is_hidden_file(basename(file_names(i)%s))) .and. &                  .not.(canon_path(file_names(i)%s) .in. existing_src_files) .and. &                  (str_ends_with(lower(file_names(i)%s), f_ext) .or. &                  str_ends_with(lower(file_names(i)%s), c_suffixes) ),i=1,size(file_names))]       src_file_names = pack(file_names,is_source)      allocate(dir_sources(size(src_file_names)))     allocate(exclude_source(size(src_file_names)))      do i = 1, size(src_file_names)          dir_sources(i) = parse_source(src_file_names(i)%s,with_f_ext,error)         if (allocated(error)) return          dir_sources(i)%unit_scope = scope         allocate(dir_sources(i)%link_libraries(0))                   exclude_source(i) = (dir_sources(i)%unit_type == FPM_UNIT_PROGRAM)         if (dir_sources(i)%unit_type == FPM_UNIT_PROGRAM .and. &             & present(with_executables)) then             if (with_executables) then                  exclude_source(i) = .false.              end if         end if      end do      if (.not.allocated(sources)) then         sources = pack(dir_sources,.not.exclude_source)     else         sources = [sources, pack(dir_sources,.not.exclude_source)]     end if  end subroutine add_sources_from_dir      subroutine add_executable_sources(sources,executables,scope,auto_discover,with_f_ext,error)          type(srcfile_t), allocatable, intent(inout), target :: sources(:)          class(executable_config_t), intent(in) :: executables(:)          integer, intent(in) :: scope          logical, intent(in) :: auto_discover          type(string_t), intent(in), optional :: with_f_ext(:)          type(error_t), allocatable, intent(out) :: error      integer :: i, j      type(string_t), allocatable :: exe_dirs(:)     type(srcfile_t) :: exe_source      call get_executable_source_dirs(exe_dirs,executables)      do i=1,size(exe_dirs)         call add_sources_from_dir(sources,exe_dirs(i)%s, scope, &                      with_executables=auto_discover, with_f_ext=with_f_ext,recurse=.false., error=error)          if (allocated(error)) then             return         end if     end do      exe_loop: do i=1,size(executables)                            do j=1,size(sources)              if (basename(sources(j)%file_name,suffix=.true.) == executables(i)%main .and.&                  canon_path(dirname(sources(j)%file_name)) == &                  canon_path(executables(i)%source_dir) ) then                  sources(j)%exe_name = executables(i)%name                 if (allocated(executables(i)%link)) then                     sources(j)%link_libraries = executables(i)%link                 end if                 sources(j)%unit_type = FPM_UNIT_PROGRAM                 cycle exe_loop              end if          end do                   associate(exe => executables(i))             exe_source = parse_source(join_path(exe%source_dir,exe%main),with_f_ext,error)             exe_source%exe_name = exe%name             if (allocated(exe%link)) then                 exe_source%link_libraries = exe%link             end if             exe_source%unit_type = FPM_UNIT_PROGRAM             exe_source%unit_scope = scope         end associate          if (allocated(error)) return          if (.not.allocated(sources)) then             sources = [exe_source]         else             sources = [sources, exe_source]         end if      end do exe_loop  end subroutine add_executable_sources    subroutine get_executable_source_dirs(exe_dirs,executables)     type(string_t), allocatable, intent(inout) :: exe_dirs(:)     class(executable_config_t), intent(in) :: executables(:)      type(string_t) :: dirs_temp(size(executables))      integer :: i, n      n = 0      do i=1,size(executables)        dirs_temp(i)%s=' '     enddo      do i=1,size(executables)         if (.not.(executables(i)%source_dir .in. dirs_temp)) then              n = n + 1             dirs_temp(n)%s = executables(i)%source_dir          end if     end do      if (.not.allocated(exe_dirs)) then         exe_dirs = dirs_temp(1:n)     else         exe_dirs = [exe_dirs,dirs_temp(1:n)]     end if  end subroutine get_executable_source_dirs   function get_exe_name_with_suffix(source) result(suffixed)     type(srcfile_t), intent(in) :: source     character(len=:), allocatable :: suffixed      if (allocated(source%exe_name)) then        if (get_os_type() == OS_WINDOWS) then            suffixed = source%exe_name//'.exe'        else            suffixed = source%exe_name        end if     else        suffixed = ""     endif  end function get_exe_name_with_suffix  end module fpm_sources 
fpm_sources.f90_comments !># Discovery of sources !> !> This module implements subroutines for building a list of !> `[[srcfile_t]]` objects by looking for source files in the filesystem. !> module fpm_sources use fpm_error, only: error_t use fpm_model, only: srcfile_t, FPM_UNIT_PROGRAM use fpm_filesystem, only: basename, canon_path, dirname, join_path, list_files, is_hidden_file use fpm_environment, only: get_os_type,OS_WINDOWS use fpm_strings, only: lower, str_ends_with, string_t, operator(.in.) use fpm_source_parsing, only: parse_f_source, parse_c_source use fpm_manifest_executable, only: executable_config_t implicit none  private public :: add_sources_from_dir, add_executable_sources public :: get_exe_name_with_suffix  character(4), parameter :: fortran_suffixes(2) = [".f90", &                                                   ".f  "] character(4), parameter :: c_suffixes(4) = [".c  ", ".h  ", ".cpp", ".hpp"]  contains  !> Wrapper to source parsing routines. !> Selects parsing routine based on source file name extension function parse_source(source_file_path,custom_f_ext,error) result(source)     character(*), intent(in) :: source_file_path     type(string_t), optional, intent(in) :: custom_f_ext(:)     type(error_t), allocatable, intent(out) :: error     type(srcfile_t)  :: source     type(string_t), allocatable :: f_ext(:)      call list_fortran_suffixes(f_ext,custom_f_ext)      if (str_ends_with(lower(source_file_path), f_ext)) then          source = parse_f_source(source_file_path, error)          if (source%unit_type == FPM_UNIT_PROGRAM) then             source%exe_name = basename(source_file_path,suffix=.false.)         end if      else if (str_ends_with(lower(source_file_path), c_suffixes)) then          source = parse_c_source(source_file_path,error)      endif      if (allocated(error)) then         return     end if  end function parse_source  !> List fortran suffixes, including optional ones subroutine list_fortran_suffixes(suffixes,with_f_ext)     type(string_t), allocatable, intent(out) :: suffixes(:)     !> Additional user-defined (preprocessor) extensions that should be treated as Fortran sources     type(string_t), intent(in), optional :: with_f_ext(:)      integer :: ndefault,nuser,i      ndefault = size(fortran_suffixes)     nuser    = 0; if (present(with_f_ext)) nuser = size(with_f_ext)      allocate(suffixes(ndefault + nuser))     do i=1,ndefault         suffixes(i) = string_t(fortran_suffixes(i))     end do     if (present(with_f_ext)) then         do i=1,nuser             suffixes(ndefault+i) = string_t(with_f_ext(i)%s)         end do     endif  end subroutine list_fortran_suffixes  !> Add to `sources` by looking for source files in `directory` subroutine add_sources_from_dir(sources,directory,scope,with_executables,with_f_ext,recurse,error)     !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated     type(srcfile_t), allocatable, intent(inout), target :: sources(:)     !> Directory in which to search for source files     character(*), intent(in) :: directory     !> Scope to apply to the discovered sources, see [[fpm_model]] for enumeration     integer, intent(in) :: scope     !> Executable sources (fortran `program`s) are ignored unless `with_executables=.true.`     logical, intent(in), optional :: with_executables     !> Additional user-defined (preprocessor) extensions that should be treated as Fortran sources     type(string_t), intent(in), optional :: with_f_ext(:)     !> Whether to recursively search subdirectories, default is `.true.`     logical, intent(in), optional :: recurse     !> Error handling     type(error_t), allocatable, intent(out) :: error      integer :: i     logical, allocatable :: is_source(:), exclude_source(:)     logical :: recurse_     type(string_t), allocatable :: file_names(:)     type(string_t), allocatable :: src_file_names(:),f_ext(:)     type(string_t), allocatable :: existing_src_files(:)     type(srcfile_t), allocatable :: dir_sources(:)      recurse_ = .true.     if (present(recurse)) recurse_ = recurse     ! Scan directory for sources     call list_files(directory, file_names,recurse=recurse_)      if (allocated(sources)) then         allocate(existing_src_files(size(sources)))         do i=1,size(sources)             existing_src_files(i)%s = canon_path(sources(i)%file_name)         end do     else         allocate(existing_src_files(0))     end if      ! Get legal fortran suffixes     call list_fortran_suffixes(f_ext,with_f_ext)      is_source = [(.not.(is_hidden_file(basename(file_names(i)%s))) .and. &                  .not.(canon_path(file_names(i)%s) .in. existing_src_files) .and. &                  (str_ends_with(lower(file_names(i)%s), f_ext) .or. &                  str_ends_with(lower(file_names(i)%s), c_suffixes) ),i=1,size(file_names))]       src_file_names = pack(file_names,is_source)      allocate(dir_sources(size(src_file_names)))     allocate(exclude_source(size(src_file_names)))      do i = 1, size(src_file_names)          dir_sources(i) = parse_source(src_file_names(i)%s,with_f_ext,error)         if (allocated(error)) return          dir_sources(i)%unit_scope = scope         allocate(dir_sources(i)%link_libraries(0))          ! Exclude executables unless specified otherwise         exclude_source(i) = (dir_sources(i)%unit_type == FPM_UNIT_PROGRAM)         if (dir_sources(i)%unit_type == FPM_UNIT_PROGRAM .and. &             & present(with_executables)) then             if (with_executables) then                  exclude_source(i) = .false.              end if         end if      end do      if (.not.allocated(sources)) then         sources = pack(dir_sources,.not.exclude_source)     else         sources = [sources, pack(dir_sources,.not.exclude_source)]     end if  end subroutine add_sources_from_dir   !> Add to `sources` using the executable and test entries in the manifest and !> applies any executable-specific overrides such as `executable%name`. !> Adds all sources (including modules) from each `executable%source_dir` subroutine add_executable_sources(sources,executables,scope,auto_discover,with_f_ext,error)     !> List of `[[srcfile_t]]` objects to append to. Allocated if not allocated     type(srcfile_t), allocatable, intent(inout), target :: sources(:)     !> List of `[[executable_config_t]]` entries from manifest     class(executable_config_t), intent(in) :: executables(:)     !> Scope to apply to the discovered sources: either `FPM_SCOPE_APP` or `FPM_SCOPE_TEST`, see [[fpm_model]]     integer, intent(in) :: scope     !> If `.false.` only executables and tests specified in the manifest are added to `sources`     logical, intent(in) :: auto_discover     !> Additional user-defined (preprocessor) extensions that should be treated as Fortran sources     type(string_t), intent(in), optional :: with_f_ext(:)     !> Error handling     type(error_t), allocatable, intent(out) :: error      integer :: i, j      type(string_t), allocatable :: exe_dirs(:)     type(srcfile_t) :: exe_source      call get_executable_source_dirs(exe_dirs,executables)      do i=1,size(exe_dirs)         call add_sources_from_dir(sources,exe_dirs(i)%s, scope, &                      with_executables=auto_discover, with_f_ext=with_f_ext,recurse=.false., error=error)          if (allocated(error)) then             return         end if     end do      exe_loop: do i=1,size(executables)          ! Check if executable already discovered automatically         !  and apply any overrides         do j=1,size(sources)              if (basename(sources(j)%file_name,suffix=.true.) == executables(i)%main .and.&                  canon_path(dirname(sources(j)%file_name)) == &                  canon_path(executables(i)%source_dir) ) then                  sources(j)%exe_name = executables(i)%name                 if (allocated(executables(i)%link)) then                     sources(j)%link_libraries = executables(i)%link                 end if                 sources(j)%unit_type = FPM_UNIT_PROGRAM                 cycle exe_loop              end if          end do          ! Add if not already discovered (auto_discovery off)         associate(exe => executables(i))             exe_source = parse_source(join_path(exe%source_dir,exe%main),with_f_ext,error)             exe_source%exe_name = exe%name             if (allocated(exe%link)) then                 exe_source%link_libraries = exe%link             end if             exe_source%unit_type = FPM_UNIT_PROGRAM             exe_source%unit_scope = scope         end associate          if (allocated(error)) return          if (.not.allocated(sources)) then             sources = [exe_source]         else             sources = [sources, exe_source]         end if      end do exe_loop  end subroutine add_executable_sources  !> Build a list of unique source directories !>  from executables specified in manifest subroutine get_executable_source_dirs(exe_dirs,executables)     type(string_t), allocatable, intent(inout) :: exe_dirs(:)     class(executable_config_t), intent(in) :: executables(:)      type(string_t) :: dirs_temp(size(executables))      integer :: i, n      n = 0      do i=1,size(executables)        dirs_temp(i)%s=' '     enddo      do i=1,size(executables)         if (.not.(executables(i)%source_dir .in. dirs_temp)) then              n = n + 1             dirs_temp(n)%s = executables(i)%source_dir          end if     end do      if (.not.allocated(exe_dirs)) then         exe_dirs = dirs_temp(1:n)     else         exe_dirs = [exe_dirs,dirs_temp(1:n)]     end if  end subroutine get_executable_source_dirs  !> Build an executable name with suffix. Safe routine that always returns an allocated string function get_exe_name_with_suffix(source) result(suffixed)     type(srcfile_t), intent(in) :: source     character(len=:), allocatable :: suffixed      if (allocated(source%exe_name)) then        if (get_os_type() == OS_WINDOWS) then            suffixed = source%exe_name//'.exe'        else            suffixed = source%exe_name        end if     else        suffixed = ""     endif  end function get_exe_name_with_suffix  end module fpm_sources 
fpm_strings.f90_stripped                                  module fpm_strings use iso_fortran_env, only: int64 use,intrinsic :: iso_fortran_env, only : stdin=>input_unit,   &                                        & stdout=>output_unit, &                                        & stderr=>error_unit use iso_c_binding, only: c_char, c_ptr, c_int, c_null_char, c_associated, c_f_pointer, c_size_t implicit none  private public :: f_string, lower, split, str_ends_with, string_t, str_begins_with_str public :: to_fortran_name, is_fortran_name public :: string_array_contains, string_cat, len_trim, operator(.in.), fnv_1a public :: replace, resize, str, join, glob public :: notabs, dilate, remove_newline_characters, remove_characters_in_set   public :: is_valid_module_name, is_valid_module_prefix, &           has_valid_custom_prefix, has_valid_standard_prefix, &           module_prefix_template, module_prefix_type  type string_t     character(len=:), allocatable :: s end type  interface len_trim     module procedure :: string_len_trim     module procedure :: strings_len_trim end interface len_trim  interface resize   module procedure :: resize_string end interface  interface operator(.in.)     module procedure string_array_contains end interface  interface fnv_1a     procedure :: fnv_1a_char     procedure :: fnv_1a_string_t end interface fnv_1a  interface str_ends_with     procedure :: str_ends_with_str     procedure :: str_ends_with_any     procedure :: str_ends_with_any_string end interface str_ends_with  interface str     module procedure str_int, str_int64, str_logical end interface  interface string_t     module procedure new_string_t end interface string_t  interface f_string     module procedure f_string, f_string_cptr, f_string_cptr_n end interface f_string  contains   pure logical function str_ends_with_str(s, e) result(r)     character(*), intent(in) :: s, e     integer :: n1, n2     n1 = len(s)-len(e)+1     n2 = len(s)     if (n1 < 1) then         r = .false.     else         r = (s(n1:n2) == e)     end if end function str_ends_with_str   pure logical function str_ends_with_any(s, e) result(r)     character(*), intent(in) :: s     character(*), intent(in) :: e(:)      integer :: i      r = .true.     do i=1,size(e)          if (str_ends_with(s,trim(e(i)))) return      end do     r = .false.  end function str_ends_with_any   pure logical function str_ends_with_any_string(s, e) result(r)     character(*), intent(in) :: s     type(string_t), intent(in) :: e(:)      integer :: i      r = .true.     do i=1,size(e)          if (str_ends_with(s,trim(e(i)%s))) return      end do     r = .false.  end function str_ends_with_any_string   pure logical function str_begins_with_str(s, e, case_sensitive) result(r)     character(*), intent(in) :: s, e     logical, optional, intent(in) :: case_sensitive      integer :: n1, n2     logical :: lower_case           if (present(case_sensitive)) then         lower_case = .not.case_sensitive     else         lower_case = .false.     end if      n1 = 1     n2 = 1 + len(e)-1     if (n2 > len(s)) then         r = .false.     elseif (lower_case) then         r = lower(s(n1:n2)) == lower(e)     else         r = (s(n1:n2) == e)     end if end function str_begins_with_str    function f_string(c_string)     use iso_c_binding     character(len=1), intent(in) :: c_string(:)     character(:), allocatable :: f_string      integer :: i, n      i = 0     do while(c_string(i+1) /=        i = i + 1     end do     n = i      allocate(character(n) :: f_string)     do i=1,n       f_string(i:i) = c_string(i)     end do  end function f_string    function f_string_cptr(cptr) result(s)     type(c_ptr), intent(in), value :: cptr     character(len=:,kind=c_char), allocatable :: s      interface         function c_strlen(s) result(r) bind(c, name="strlen")             import c_size_t, c_ptr             type(c_ptr), intent(in), value :: s             integer(kind=c_size_t) :: r         end function     end interface      s = f_string_cptr_n(cptr, c_strlen(cptr)) end function   function f_string_cptr_n(cptr, n) result(s)     type(c_ptr), intent(in), value :: cptr     integer(kind=c_size_t), intent(in) :: n     character(len=n,kind=c_char) :: s     character(len=n,kind=c_char), pointer :: sptr      call c_f_pointer(cptr, sptr)     s = sptr end function   pure function fnv_1a_char(input, seed) result(hash)     character(*), intent(in) :: input     integer(int64), intent(in), optional :: seed     integer(int64) :: hash      integer :: i     integer(int64), parameter :: FNV_OFFSET_32 = 2166136261_int64     integer(int64), parameter :: FNV_PRIME_32 = 16777619_int64      if (present(seed)) then         hash = seed     else         hash = FNV_OFFSET_32     end if      do i=1,len(input)         hash = ieor(hash,iachar(input(i:i),int64)) * FNV_PRIME_32     end do  end function fnv_1a_char    pure function fnv_1a_string_t(input, seed) result(hash)     type(string_t), intent(in) :: input(:)     integer(int64), intent(in), optional :: seed     integer(int64) :: hash      integer :: i      hash = fnv_1a(input(1)%s,seed)      do i=2,size(input)         hash = fnv_1a(input(i)%s,hash)     end do  end function fnv_1a_string_t      elemental pure function lower(str,begin,end) result (string)      character(*), intent(In)     :: str     character(len(str))          :: string     integer,intent(in),optional  :: begin, end     integer                      :: i     integer                      :: ibegin, iend     string = str      ibegin = 1     if (present(begin))then         ibegin = max(ibegin,begin)     endif      iend = len_trim(str)     if (present(end))then         iend= min(iend,end)     endif      do i = ibegin, iend                                        select case (str(i:i))         case ('A':'Z')             string(i:i) = char(iachar(str(i:i))+32)              case default         end select     end do  end function lower    function new_string_t(s) result(string)     character(*), intent(in) :: s     type(string_t) :: string      string%s = s  end function new_string_t    logical function string_array_contains(search_string,array)     character(*), intent(in) :: search_string     type(string_t), intent(in) :: array(:)      integer :: i      string_array_contains = any([(array(i)%s==search_string, &                                    i=1,size(array))])  end function string_array_contains    function string_cat(strings,delim) result(cat)     type(string_t), intent(in) :: strings(:)     character(*), intent(in), optional :: delim     character(:), allocatable :: cat      integer :: i     character(:), allocatable :: delim_str      if (size(strings) < 1) then         cat = ''         return     end if      if (present(delim)) then         delim_str = delim     else         delim_str = ''     end if      cat = strings(1)%s     do i=2,size(strings)          cat = cat//delim_str//strings(i)%s      end do  end function string_cat   pure function strings_len_trim(strings) result(n)     type(string_t), intent(in) :: strings(:)     integer :: i, n      n = 0     do i=1,size(strings)         n = n + len_trim(strings(i)%s)     end do  end function strings_len_trim   elemental integer function string_len_trim(string) result(n)     type(string_t), intent(in) :: string      if (allocated(string%s)) then         n = len_trim(string%s)     else         n = 0     end if  end function string_len_trim     subroutine split(input_line,array,delimiters,order,nulls)                         character(len=*),intent(in)              :: input_line       character(len=*),optional,intent(in)     :: delimiters       character(len=*),optional,intent(in)     :: order            character(len=*),optional,intent(in)     :: nulls            character(len=:),allocatable,intent(out) :: array(:)          integer                       :: n                           integer,allocatable           :: ibegin(:)                   integer,allocatable           :: iterm(:)                    character(len=:),allocatable  :: dlim                        character(len=:),allocatable  :: ordr                        character(len=:),allocatable  :: nlls                        integer                       :: ii,iiii                     integer                       :: icount                      integer                       :: ilen                        integer                       :: i10,i20,i30                 integer                       :: icol                        integer                       :: idlim                       integer                       :: ifound                      integer                       :: inotnull                    integer                       :: ireturn                     integer                       :: imax                              if (present(delimiters)) then                                              if(delimiters/='')then                                                    dlim=delimiters         else                                                                        dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)          endif     else                                                                       dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)         endif     idlim=len(dlim)                                                         if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif      if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif       n=len(input_line)+1                             allocate(ibegin(n))                             allocate(iterm(n))                              ibegin(:)=1     iterm(:)=1      ilen=len(input_line)                                                icount=0                                                            inotnull=0                                                          imax=0                                                               select case (ilen)      case (0)                                                            case default                                                            icol=1                                                               INFINITE: do i30=1,ilen,1                                                ibegin(i30)=icol                                                      if(index(dlim(1:idlim),input_line(icol:icol))==0)then               iterm(i30)=ilen                                                    do i10=1,idlim                                                         ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))                 IF(ifound>0)then                     iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)                 endif             enddo             icol=iterm(i30)+2                                                  inotnull=inotnull+1                                                else                                                                  iterm(i30)=icol-1                                                  icol=icol+1                                                        endif             imax=max(imax,iterm(i30)-ibegin(i30)+1)             icount=i30                                                            if(icol>ilen)then                                                  exit INFINITE             endif         enddo INFINITE      end select      select case (trim(adjustl(nlls)))     case ('ignore','','ignoreend')         ireturn=inotnull     case default         ireturn=icount     end select     allocate(character(len=imax) :: array(ireturn))                           select case (trim(adjustl(ordr)))                                   case ('reverse','right') ; ii=ireturn ; iiii=-1                     case default             ; ii=1       ; iiii=1                      end select      do i20=1,icount                                                         if(iterm(i20)<ibegin(i20))then             select case (trim(adjustl(nlls)))             case ('ignore','','ignoreend')             case default             array(ii)=' '             ii=ii+iiii             end select         else             array(ii)=input_line(ibegin(i20):iterm(i20))             ii=ii+iiii         endif     enddo end subroutine split   pure function replace(string, charset, target_char) result(res)     character(*), intent(in) :: string     character, intent(in) :: charset(:), target_char     character(len(string)) :: res     integer :: n     res = string     do n = 1, len(string)         if (any(string(n:n) == charset)) then             res(n:n) = target_char         end if     end do end function replace   subroutine resize_string(list, n)      type(string_t), allocatable, intent(inout) :: list(:)      integer, intent(in), optional :: n    type(string_t), allocatable :: tmp(:)   integer :: this_size, new_size, i   integer, parameter :: initial_size = 16    if (allocated(list)) then     this_size = size(list, 1)     call move_alloc(list, tmp)   else     this_size = initial_size   end if    if (present(n)) then     new_size = n   else     new_size = this_size + this_size/2 + 1   end if    allocate(list(new_size))    if (allocated(tmp)) then     this_size = min(size(tmp, 1), size(list, 1))     do i = 1, this_size       call move_alloc(tmp(i)%s, list(i)%s)     end do     deallocate(tmp)   end if  end subroutine resize_string                                                                              pure function join(str,sep,trm,left,right,start,end) result (string)    character(len=*),intent(in)          :: str(:) character(len=*),intent(in),optional :: sep, right, left, start, end logical,intent(in),optional          :: trm character(len=:),allocatable         :: sep_local, left_local, right_local character(len=:),allocatable         :: string logical                              :: trm_local integer                              :: i    if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif    if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif    if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif    if(present(right))then ; right_local=right ; else ; right_local=''   ; endif    string=''    if(size(str)==0)then       string=string//left_local//right_local    else       do i = 1,size(str)-1          if(trm_local)then             string=string//left_local//trim(str(i))//right_local//sep_local          else             string=string//left_local//str(i)//right_local//sep_local          endif       enddo       if(trm_local)then          string=string//left_local//trim(str(i))//right_local       else          string=string//left_local//str(i)//right_local       endif    endif    if(present(start))string=start//string    if(present(end))string=string//end end function join                                                                                                                                                                                                                                          function glob(tame,wild)    logical                    :: glob        character(len=*)           :: tame        character(len=*)           :: wild        character(len=len(tame)+1) :: tametext character(len=len(wild)+1) :: wildtext character(len=1),parameter :: NULL=char(0) integer                    :: wlen integer                    :: ti, wi integer                    :: i character(len=:),allocatable :: tbookmark, wbookmark      tametext=tame//NULL    wildtext=wild//NULL    tbookmark = NULL    wbookmark = NULL    wlen=len(wild)    wi=1    ti=1    do                                                   if(wildtext(wi:wi) == '*')then                       do i=wi,wlen                                         if(wildtext(wi:wi)=='*')then                wi=wi+1             else                exit             endif          enddo          if(wildtext(wi:wi)==NULL) then                     glob=.true.             return          endif          if(wildtext(wi:wi) /= '?') then                          do while (tametext(ti:ti) /= wildtext(wi:wi))                ti=ti+1                if (tametext(ti:ti)==NULL)then                   glob=.false.                   return                                         endif             enddo          endif          wbookmark = wildtext(wi:)          tbookmark = tametext(ti:)       elseif(tametext(ti:ti) /= wildtext(wi:wi) .and. wildtext(wi:wi) /= '?') then                    if(wbookmark/=NULL) then             if(wildtext(wi:)/= wbookmark) then                wildtext = wbookmark;                wlen=len_trim(wbookmark)                wi=1                                if (tametext(ti:ti) /= wildtext(wi:wi)) then                   tbookmark=tbookmark(2:)                   tametext = tbookmark                   ti=1                   cycle                                          else                   wi=wi+1                endif             endif             if (tametext(ti:ti)/=NULL) then                ti=ti+1                cycle                                          endif          endif          glob=.false.          return                                         endif       ti=ti+1       wi=wi+1       if (tametext(ti:ti)==NULL) then                    if(wildtext(wi:wi)/=NULL)then             do while (wildtext(wi:wi) == '*')                    wi=wi+1                                           if(wildtext(wi:wi)==NULL)exit             enddo          endif          if (wildtext(wi:wi)==NULL)then             glob=.true.             return                                         endif          glob=.false.          return                                         endif    enddo end function glob   pure integer function str_int_len(i) result(sz) integer, intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s   write(s, '(i0)') i sz = len_trim(s) end function   pure function str_int(i) result(s) integer, intent(in) :: i character(len=str_int_len(i)) :: s write(s, '(i0)') i end function   pure integer function str_int64_len(i) result(sz) integer(int64), intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s   write(s, '(i0)') i sz = len_trim(s) end function   pure function str_int64(i) result(s) integer(int64), intent(in) :: i character(len=str_int64_len(i)) :: s write(s, '(i0)') i end function   pure integer function str_logical_len(l) result(sz) logical, intent(in) :: l if (l) then     sz = 6 else     sz = 7 end if end function   pure function str_logical(l) result(s) logical, intent(in) :: l character(len=str_logical_len(l)) :: s if (l) then     s = ".true." else     s = ".false." end if end function     pure function to_fortran_name(string) result(res)     character(*), intent(in) :: string     character(len(string)) :: res     character, parameter :: SPECIAL_CHARACTERS(*) = ['-']     res = replace(string, SPECIAL_CHARACTERS, '_') end function to_fortran_name  elemental function is_fortran_name(line) result (lout)       character(len=*),parameter   :: int='0123456789'     character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'     character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'     character(len=*),parameter   :: allowed=upper//lower//int//'_'     character(len=*),intent(in)  :: line     character(len=:),allocatable :: name     logical                      :: lout         name=trim(line)         if(len(name)/=0)then             lout = .true.                                  &              & .and. verify(name(1:1), lower//upper) == 0  &              & .and. verify(name,allowed) == 0             &              & .and. len(name) <= 63         else             lout = .false.         endif end function is_fortran_name      logical function is_valid_module_name(module_name,package_name,custom_prefix,enforce_module_names) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: package_name     type(string_t), intent(in) :: custom_prefix     logical       , intent(in) :: enforce_module_names            valid = is_fortran_name(module_name%s); if (.not.valid) return           if (enforce_module_names) then                   valid = has_valid_standard_prefix(module_name,package_name)                            if (len_trim(custom_prefix)>0 .and. .not.valid) &             valid = has_valid_custom_prefix(module_name,custom_prefix)      end if  end function is_valid_module_name     logical function is_valid_module_prefix(module_prefix) result(valid)      type(string_t), intent(in) :: module_prefix      character(len=*),parameter :: num='0123456789'     character(len=*),parameter :: lower='abcdefghijklmnopqrstuvwxyz'     character(len=*),parameter :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'     character(len=*),parameter :: alpha  =upper//lower     character(len=*),parameter :: allowed=alpha//num      character(len=:),allocatable :: name      name = trim(module_prefix%s)      if (len(name)>0 .and. len(name)<=63) then         valid = verify(name(1:1), alpha) == 0 .and. &                 verify(name,allowed)     == 0     else         valid = .false.     endif  end function is_valid_module_prefix   type(string_t) function module_prefix_template(project_name,custom_prefix) result(prefix)     type(string_t), intent(in) :: project_name     type(string_t), intent(in) :: custom_prefix      if (is_valid_module_prefix(custom_prefix)) then          prefix = string_t(trim(custom_prefix%s)//"_")      else          prefix = string_t(to_fortran_name(project_name%s)//"__")      end if  end function module_prefix_template  type(string_t) function module_prefix_type(project_name,custom_prefix) result(ptype)     type(string_t), intent(in) :: project_name     type(string_t), intent(in) :: custom_prefix      if (is_valid_module_prefix(custom_prefix)) then         ptype = string_t("custom")     else         ptype = string_t("default")     end if  end function module_prefix_type      logical function has_valid_custom_prefix(module_name,custom_prefix) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: custom_prefix           character(*), parameter :: SEP = "_"      logical :: is_same,has_separator,same_beginning     integer :: lpkg,lmod,lsep           valid = is_fortran_name(module_name%s) .and. &             is_valid_module_prefix(custom_prefix)           if (valid) then                   lpkg  = len_trim(custom_prefix)         lmod  = len_trim(module_name)         lsep  = len_trim(SEP)          same_beginning = str_begins_with_str(module_name%s,custom_prefix%s,case_sensitive=.false.)          is_same = lpkg==lmod .and. same_beginning          if (lmod>=lpkg+lsep) then            has_separator = str_begins_with_str(module_name%s(lpkg+1:lpkg+lsep),SEP)         else            has_separator = .false.         endif                                              valid = same_beginning .and. (is_same .or. (lmod>lpkg+lsep .and. has_separator))      end if  end function has_valid_custom_prefix       logical function has_valid_standard_prefix(module_name,package_name) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: package_name           character(*), parameter :: SEP = "__"      character(len=:), allocatable :: fortranized_pkg     logical :: is_same,has_separator,same_beginning     integer :: lpkg,lmod,lsep           valid = is_fortran_name(module_name%s)           if (valid) then          fortranized_pkg = to_fortran_name(package_name%s)                   lpkg  = len_trim(fortranized_pkg)         lmod  = len_trim(module_name)         lsep  = len_trim(SEP)          same_beginning = str_begins_with_str(module_name%s,fortranized_pkg,case_sensitive=.false.)          is_same = lpkg==lmod .and. same_beginning          if (lmod>=lpkg+lsep) then            has_separator = str_begins_with_str(module_name%s(lpkg+1:lpkg+lsep),SEP)         else            has_separator = .false.         endif                                              valid = is_fortran_name(fortranized_pkg) .and. &                 fortranized_pkg(lpkg:lpkg)/='_' .and. &                 (same_beginning .and. (is_same .or. (lmod>lpkg+lsep .and. has_separator)))      end if  end function has_valid_standard_prefix   subroutine remove_characters_in_set(string,set,replace_with)     character(len=:), allocatable, intent(inout) :: string     character(*), intent(in) :: set     character, optional, intent(in) :: replace_with       integer :: feed,length      if (.not.allocated(string)) return     if (len(set)<=0) return      length = len(string)     feed   = scan(string,set)      do while (length>0 .and. feed>0)                   if (length==1) then             string = ""          elseif (feed==1) then             string = string(2:length)                   elseif (feed==length) then             string = string(1:length-1)                   elseif (present(replace_with)) then             string(feed:feed) = replace_with                  else             string = string(1:feed-1)//string(feed+1:length)         end if          length = len(string)         feed   = scan(string,set)      end do  end subroutine remove_characters_in_set   subroutine remove_newline_characters(string)     type(string_t), intent(inout) :: string      integer :: feed,length      character(*), parameter ::      character(*), parameter :: SPACE = ' '      call remove_characters_in_set(string%s,set=  end subroutine remove_newline_characters                                                             elemental impure subroutine notabs(instr,outstr,ilen)    character(len=*),intent(in)   :: instr         character(len=*),intent(out)  :: outstr        integer,intent(out)           :: ilen                                                          integer,parameter             :: tabsize=8     integer                       :: ipos          integer                       :: lenin         integer                       :: lenout        integer                       :: istep         character(len=1)              :: c             integer                       :: iade              ipos=1                                         lenin=len_trim(instr( 1:len(instr) ))          lenout=len(outstr)                             outstr=" "                                         SCAN_LINE: do istep=1,lenin                       c=instr(istep:istep)                           iade=ichar(c)                                  EXPAND_TABS : select case (iade)               case(9)                                           ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))          case(10,13)                                       ipos=ipos+1          case default                                      if(ipos > lenout)then                write(stderr,*)"*notabs* output string overflow"                exit             else                outstr(ipos:ipos)=c                ipos=ipos+1             endif          end select EXPAND_TABS       enddo SCAN_LINE        ipos=min(ipos,lenout)                          ilen=len_trim(outstr(:ipos))              end subroutine notabs                                               function dilate(instr) result(outstr)     character(len=*), intent(in)  :: instr            character(len=:), allocatable :: outstr           integer                       :: i    integer                       :: icount    integer                       :: lgth    icount = 0    do i = 1, len(instr)       if (instr(i:i) == char(9)) icount = icount + 1    end do    allocate (character(len=(len(instr) + 8*icount)) :: outstr)    call notabs(instr, outstr, lgth)    outstr = outstr(:lgth)  end function dilate  end module fpm_strings 
fpm_strings.f90_comments !> This module defines general procedures for **string operations** for both CHARACTER and !! TYPE(STRING_T) variables ! !>## general routines for performing __string operations__ !! !!### Types !! - **TYPE(STRING_T)** define a type to contain strings of variable length !!### Type Conversions !! - [[F_STRING]]  return Fortran **CHARACTER** variable when given a C-like array of !!                 single characters terminated with a C_NULL_CHAR **CHARACTER** !! - [[STR]]  Converts **INTEGER** or** LOGICAL** to **CHARACTER** string !!### Case !! - [[LOWER]]  Changes a string to lowercase over optional specified column range !!### Parsing and joining !! - [[SPLIT]]  parse string on delimiter characters and store tokens into an allocatable array !! - [[STRING_CAT]]  Concatenate an array of **type(string_t)** into a single **CHARACTER** variable !! - [[JOIN]]  append an array of **CHARACTER** variables into a single **CHARACTER** variable !!### Testing !! - [[STR_ENDS_WITH]]  test if a **CHARACTER** string or array ends with a specified suffix !! - [[STRING_ARRAY_CONTAINS]]  Check if array of **TYPE(STRING_T)** matches a particular **CHARACTER** string !! - **OPERATOR(.IN.)**  Check if array of **TYPE(STRING_T)** matches a particular **CHARACTER** string !! - [[GLOB]]  function compares text strings, one of which can have wildcards ('*' or '?'). !! - [[IS_FORTRAN_NAME]]  determine whether a string is an acceptable Fortran entity name !! - [[TO_FORTRAN_NAME]]  replace allowed special but unusuable characters in names with underscore !!### Whitespace !! - [[NOTABS]]  subroutine to expand tab characters assuming a tab space every eight characters !! - [[DILATE]]  function to expand tab characters assuming a tab space every eight characters !! - [[LEN_TRIM]]  Determine total trimmed length of **STRING_T** array !!### Miscellaneous !! - [[FNV_1A]]  Hash a **CHARACTER(*)** string of default kind or a **TYPE(STRING_T)** array !! - [[REPLACE]]  Returns string with characters in charset replaced with target_char. !! - [[RESIZE]]  increase the size of a **TYPE(STRING_T)** array by N elements !! module fpm_strings use iso_fortran_env, only: int64 use,intrinsic :: iso_fortran_env, only : stdin=>input_unit,   &                                        & stdout=>output_unit, &                                        & stderr=>error_unit use iso_c_binding, only: c_char, c_ptr, c_int, c_null_char, c_associated, c_f_pointer, c_size_t implicit none  private public :: f_string, lower, split, str_ends_with, string_t, str_begins_with_str public :: to_fortran_name, is_fortran_name public :: string_array_contains, string_cat, len_trim, operator(.in.), fnv_1a public :: replace, resize, str, join, glob public :: notabs, dilate, remove_newline_characters, remove_characters_in_set  !> Module naming public :: is_valid_module_name, is_valid_module_prefix, &           has_valid_custom_prefix, has_valid_standard_prefix, &           module_prefix_template, module_prefix_type  type string_t     character(len=:), allocatable :: s end type  interface len_trim     module procedure :: string_len_trim     module procedure :: strings_len_trim end interface len_trim  interface resize   module procedure :: resize_string end interface  interface operator(.in.)     module procedure string_array_contains end interface  interface fnv_1a     procedure :: fnv_1a_char     procedure :: fnv_1a_string_t end interface fnv_1a  interface str_ends_with     procedure :: str_ends_with_str     procedure :: str_ends_with_any     procedure :: str_ends_with_any_string end interface str_ends_with  interface str     module procedure str_int, str_int64, str_logical end interface  interface string_t     module procedure new_string_t end interface string_t  interface f_string     module procedure f_string, f_string_cptr, f_string_cptr_n end interface f_string  contains  !> test if a CHARACTER string ends with a specified suffix pure logical function str_ends_with_str(s, e) result(r)     character(*), intent(in) :: s, e     integer :: n1, n2     n1 = len(s)-len(e)+1     n2 = len(s)     if (n1 < 1) then         r = .false.     else         r = (s(n1:n2) == e)     end if end function str_ends_with_str  !> test if a CHARACTER string ends with any of an array of suffixs pure logical function str_ends_with_any(s, e) result(r)     character(*), intent(in) :: s     character(*), intent(in) :: e(:)      integer :: i      r = .true.     do i=1,size(e)          if (str_ends_with(s,trim(e(i)))) return      end do     r = .false.  end function str_ends_with_any  !> Test if a CHARACTER string ends with any of an array of string suffixs pure logical function str_ends_with_any_string(s, e) result(r)     character(*), intent(in) :: s     type(string_t), intent(in) :: e(:)      integer :: i      r = .true.     do i=1,size(e)          if (str_ends_with(s,trim(e(i)%s))) return      end do     r = .false.  end function str_ends_with_any_string  !> test if a CHARACTER string begins with a specified prefix pure logical function str_begins_with_str(s, e, case_sensitive) result(r)     character(*), intent(in) :: s, e     logical, optional, intent(in) :: case_sensitive ! Default option: case sensitive     integer :: n1, n2     logical :: lower_case      ! Check if case sensitive     if (present(case_sensitive)) then         lower_case = .not.case_sensitive     else         lower_case = .false.     end if      n1 = 1     n2 = 1 + len(e)-1     if (n2 > len(s)) then         r = .false.     elseif (lower_case) then         r = lower(s(n1:n2)) == lower(e)     else         r = (s(n1:n2) == e)     end if end function str_begins_with_str  !> return Fortran character variable when given a C-like array of !! single characters terminated with a C_NULL_CHAR character function f_string(c_string)     use iso_c_binding     character(len=1), intent(in) :: c_string(:)     character(:), allocatable :: f_string      integer :: i, n      i = 0     do while(c_string(i+1) /= C_NULL_CHAR)       i = i + 1     end do     n = i      allocate(character(n) :: f_string)     do i=1,n       f_string(i:i) = c_string(i)     end do  end function f_string   !> return Fortran character variable when given a null-terminated c_ptr function f_string_cptr(cptr) result(s)     type(c_ptr), intent(in), value :: cptr     character(len=:,kind=c_char), allocatable :: s      interface         function c_strlen(s) result(r) bind(c, name="strlen")             import c_size_t, c_ptr             type(c_ptr), intent(in), value :: s             integer(kind=c_size_t) :: r         end function     end interface      s = f_string_cptr_n(cptr, c_strlen(cptr)) end function  !> return Fortran character variable when given a null-terminated c_ptr and its length function f_string_cptr_n(cptr, n) result(s)     type(c_ptr), intent(in), value :: cptr     integer(kind=c_size_t), intent(in) :: n     character(len=n,kind=c_char) :: s     character(len=n,kind=c_char), pointer :: sptr      call c_f_pointer(cptr, sptr)     s = sptr end function  !> Hash a character(*) string of default kind pure function fnv_1a_char(input, seed) result(hash)     character(*), intent(in) :: input     integer(int64), intent(in), optional :: seed     integer(int64) :: hash      integer :: i     integer(int64), parameter :: FNV_OFFSET_32 = 2166136261_int64     integer(int64), parameter :: FNV_PRIME_32 = 16777619_int64      if (present(seed)) then         hash = seed     else         hash = FNV_OFFSET_32     end if      do i=1,len(input)         hash = ieor(hash,iachar(input(i:i),int64)) * FNV_PRIME_32     end do  end function fnv_1a_char   !> Hash a string_t array of default kind pure function fnv_1a_string_t(input, seed) result(hash)     type(string_t), intent(in) :: input(:)     integer(int64), intent(in), optional :: seed     integer(int64) :: hash      integer :: i      hash = fnv_1a(input(1)%s,seed)      do i=2,size(input)         hash = fnv_1a(input(i)%s,hash)     end do  end function fnv_1a_string_t   !>Author: John S. Urban !!License: Public Domain !! Changes a string to lowercase over optional specified column range elemental pure function lower(str,begin,end) result (string)      character(*), intent(In)     :: str     character(len(str))          :: string     integer,intent(in),optional  :: begin, end     integer                      :: i     integer                      :: ibegin, iend     string = str      ibegin = 1     if (present(begin))then         ibegin = max(ibegin,begin)     endif      iend = len_trim(str)     if (present(end))then         iend= min(iend,end)     endif      do i = ibegin, iend                               ! step thru each letter in the string in specified range         select case (str(i:i))         case ('A':'Z')             string(i:i) = char(iachar(str(i:i))+32)     ! change letter to miniscule         case default         end select     end do  end function lower  !> Helper function to generate a new string_t instance !>  (Required due to the allocatable component) function new_string_t(s) result(string)     character(*), intent(in) :: s     type(string_t) :: string      string%s = s  end function new_string_t  !> Check if array of TYPE(STRING_T) matches a particular CHARACTER string !! logical function string_array_contains(search_string,array)     character(*), intent(in) :: search_string     type(string_t), intent(in) :: array(:)      integer :: i      string_array_contains = any([(array(i)%s==search_string, &                                    i=1,size(array))])  end function string_array_contains  !> Concatenate an array of type(string_t) into !>  a single CHARACTER variable function string_cat(strings,delim) result(cat)     type(string_t), intent(in) :: strings(:)     character(*), intent(in), optional :: delim     character(:), allocatable :: cat      integer :: i     character(:), allocatable :: delim_str      if (size(strings) < 1) then         cat = ''         return     end if      if (present(delim)) then         delim_str = delim     else         delim_str = ''     end if      cat = strings(1)%s     do i=2,size(strings)          cat = cat//delim_str//strings(i)%s      end do  end function string_cat  !> Determine total trimmed length of `string_t` array pure function strings_len_trim(strings) result(n)     type(string_t), intent(in) :: strings(:)     integer :: i, n      n = 0     do i=1,size(strings)         n = n + len_trim(strings(i)%s)     end do  end function strings_len_trim  !> Determine total trimmed length of `string_t` array elemental integer function string_len_trim(string) result(n)     type(string_t), intent(in) :: string      if (allocated(string%s)) then         n = len_trim(string%s)     else         n = 0     end if  end function string_len_trim  !>Author: John S. Urban !!License: Public Domain !! parse string on delimiter characters and store tokens into an allocatable array subroutine split(input_line,array,delimiters,order,nulls)     !! given a line of structure " par1 par2 par3 ... parn " store each par(n) into a separate variable in array.     !!     !! * by default adjacent delimiters in the input string do not create an empty string in the output array     !! * no quoting of delimiters is supported     character(len=*),intent(in)              :: input_line  !! input string to tokenize     character(len=*),optional,intent(in)     :: delimiters  !! list of delimiter characters     character(len=*),optional,intent(in)     :: order       !! order of output array sequential|[reverse|right]     character(len=*),optional,intent(in)     :: nulls       !! return strings composed of delimiters or not ignore|return|ignoreend     character(len=:),allocatable,intent(out) :: array(:)    !! output array of tokens      integer                       :: n                      ! max number of strings INPUT_LINE could split into if all delimiter     integer,allocatable           :: ibegin(:)              ! positions in input string where tokens start     integer,allocatable           :: iterm(:)               ! positions in input string where tokens end     character(len=:),allocatable  :: dlim                   ! string containing delimiter characters     character(len=:),allocatable  :: ordr                   ! string containing order keyword     character(len=:),allocatable  :: nlls                   ! string containing nulls keyword     integer                       :: ii,iiii                ! loop parameters used to control print order     integer                       :: icount                 ! number of tokens found     integer                       :: ilen                   ! length of input string with trailing spaces trimmed     integer                       :: i10,i20,i30            ! loop counters     integer                       :: icol                   ! pointer into input string as it is being parsed     integer                       :: idlim                  ! number of delimiter characters     integer                       :: ifound                 ! where next delimiter character is found in remaining input string data     integer                       :: inotnull               ! count strings not composed of delimiters     integer                       :: ireturn                ! number of tokens returned     integer                       :: imax                   ! length of longest token      ! decide on value for optional DELIMITERS parameter     if (present(delimiters)) then                                     ! optional delimiter list was present         if(delimiters/='')then                                       ! if DELIMITERS was specified and not null use it             dlim=delimiters         else                                                           ! DELIMITERS was specified on call as empty string             dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0) ! use default delimiter when not specified         endif     else                                                              ! no delimiter value was specified         dlim=' '//char(9)//char(10)//char(11)//char(12)//char(13)//char(0)    ! use default delimiter when not specified     endif     idlim=len(dlim)                                                   ! dlim a lot of blanks on some machines if dlim is a big string      if(present(order))then; ordr=lower(adjustl(order)); else; ordr='sequential'; endif ! decide on value for optional ORDER parameter     if(present(nulls))then; nlls=lower(adjustl(nulls)); else; nlls='ignore'    ; endif ! optional parameter      n=len(input_line)+1                        ! max number of strings INPUT_LINE could split into if all delimiter     allocate(ibegin(n))                        ! allocate enough space to hold starting location of tokens if string all tokens     allocate(iterm(n))                         ! allocate enough space to hold ending location of tokens if string all tokens     ibegin(:)=1     iterm(:)=1      ilen=len(input_line)                                           ! ILEN is the column position of the last non-blank character     icount=0                                                       ! how many tokens found     inotnull=0                                                     ! how many tokens found not composed of delimiters     imax=0                                                         ! length of longest token found      select case (ilen)      case (0)                                                      ! command was totally blank      case default                                                   ! there is at least one non-delimiter in INPUT_LINE if get here         icol=1                                                      ! initialize pointer into input line         INFINITE: do i30=1,ilen,1                                   ! store into each array element             ibegin(i30)=icol                                         ! assume start new token on the character             if(index(dlim(1:idlim),input_line(icol:icol))==0)then  ! if current character is not a delimiter             iterm(i30)=ilen                                       ! initially assume no more tokens             do i10=1,idlim                                        ! search for next delimiter                 ifound=index(input_line(ibegin(i30):ilen),dlim(i10:i10))                 IF(ifound>0)then                     iterm(i30)=min(iterm(i30),ifound+ibegin(i30)-2)                 endif             enddo             icol=iterm(i30)+2                                     ! next place to look as found end of this token             inotnull=inotnull+1                                   ! increment count of number of tokens not composed of delimiters             else                                                     ! character is a delimiter for a null string             iterm(i30)=icol-1                                     ! record assumed end of string. Will be less than beginning             icol=icol+1                                           ! advance pointer into input string             endif             imax=max(imax,iterm(i30)-ibegin(i30)+1)             icount=i30                                               ! increment count of number of tokens found             if(icol>ilen)then                                     ! no text left             exit INFINITE             endif         enddo INFINITE      end select      select case (trim(adjustl(nlls)))     case ('ignore','','ignoreend')         ireturn=inotnull     case default         ireturn=icount     end select     allocate(character(len=imax) :: array(ireturn))                ! allocate the array to return     !allocate(array(ireturn))                                       ! allocate the array to turn      select case (trim(adjustl(ordr)))                              ! decide which order to store tokens     case ('reverse','right') ; ii=ireturn ; iiii=-1                ! last to first     case default             ; ii=1       ; iiii=1                 ! first to last     end select      do i20=1,icount                                                ! fill the array with the tokens that were found         if(iterm(i20)<ibegin(i20))then             select case (trim(adjustl(nlls)))             case ('ignore','','ignoreend')             case default             array(ii)=' '             ii=ii+iiii             end select         else             array(ii)=input_line(ibegin(i20):iterm(i20))             ii=ii+iiii         endif     enddo end subroutine split  !> Returns string with characters in charset replaced with target_char. pure function replace(string, charset, target_char) result(res)     character(*), intent(in) :: string     character, intent(in) :: charset(:), target_char     character(len(string)) :: res     integer :: n     res = string     do n = 1, len(string)         if (any(string(n:n) == charset)) then             res(n:n) = target_char         end if     end do end function replace  !> increase the size of a TYPE(STRING_T) array by N elements subroutine resize_string(list, n)   !> Instance of the array to be resized   type(string_t), allocatable, intent(inout) :: list(:)   !> Dimension of the final array size   integer, intent(in), optional :: n    type(string_t), allocatable :: tmp(:)   integer :: this_size, new_size, i   integer, parameter :: initial_size = 16    if (allocated(list)) then     this_size = size(list, 1)     call move_alloc(list, tmp)   else     this_size = initial_size   end if    if (present(n)) then     new_size = n   else     new_size = this_size + this_size/2 + 1   end if    allocate(list(new_size))    if (allocated(tmp)) then     this_size = min(size(tmp, 1), size(list, 1))     do i = 1, this_size       call move_alloc(tmp(i)%s, list(i)%s)     end do     deallocate(tmp)   end if  end subroutine resize_string  !>AUTHOR: John S. Urban !!LICENSE: Public Domain !> !!##NAME !!    join(3f) - [M_strings:EDITING] append CHARACTER variable array into !!    a single CHARACTER variable with specified separator !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    pure function join(str,sep,trm,left,right,start,end) result (string) !! !!     character(len=*),intent(in)          :: str(:) !!     character(len=*),intent(in),optional :: sep !!     logical,intent(in),optional          :: trm !!     character(len=*),intent(in),optional :: right !!     character(len=*),intent(in),optional :: left !!     character(len=*),intent(in),optional :: start !!     character(len=*),intent(in),optional :: end !!     character(len=:),allocatable         :: string !! !!##DESCRIPTION !!   JOIN(3f) appends the elements of a CHARACTER array into a single !!   CHARACTER variable, with elements 1 to N joined from left to right. !!   By default each element is trimmed of trailing spaces and the !!   default separator is a null string. !! !!##OPTIONS !!      STR(:)  array of CHARACTER variables to be joined !!      SEP     separator string to place between each variable. defaults !!              to a null string. !!      LEFT    string to place at left of each element !!      RIGHT   string to place at right of each element !!      START   prefix string !!      END     suffix string !!      TRM     option to trim each element of STR of trailing !!              spaces. Defaults to .TRUE. !! !!##RESULT !!      STRING  CHARACTER variable composed of all of the elements of STR() !!              appended together with the optional separator SEP placed !!              between the elements. !! !!##EXAMPLE !! !!  Sample program: !! !!   program demo_join !!   use M_strings, only: join !!   implicit none !!   character(len=:),allocatable  :: s(:) !!   character(len=:),allocatable  :: out !!   integer                       :: i !!     s=[character(len=10) :: 'United',' we',' stand,', & !!     & ' divided',' we fall.'] !!     out=join(s) !!     write(*,'(a)') out !!     write(*,'(a)') join(s,trm=.false.) !!     write(*,'(a)') (join(s,trm=.false.,sep='|'),i=1,3) !!     write(*,'(a)') join(s,sep='<>') !!     write(*,'(a)') join(s,sep=';',left='[',right=']') !!     write(*,'(a)') join(s,left='[',right=']') !!     write(*,'(a)') join(s,left='>>') !!   end program demo_join !! !!  Expected output: !! !!   United we stand, divided we fall. !!   United     we        stand,    divided   we fall. !!   United    | we       | stand,   | divided  | we fall. !!   United    | we       | stand,   | divided  | we fall. !!   United    | we       | stand,   | divided  | we fall. !!   United<> we<> stand,<> divided<> we fall. !!   [United];[ we];[ stand,];[ divided];[ we fall.] !!   [United][ we][ stand,][ divided][ we fall.] !!   >>United>> we>> stand,>> divided>> we fall. pure function join(str,sep,trm,left,right,start,end) result (string)  ! @(#)M_strings::join(3f): merge string array into a single CHARACTER value adding specified separators, caps, prefix and suffix  character(len=*),intent(in)          :: str(:) character(len=*),intent(in),optional :: sep, right, left, start, end logical,intent(in),optional          :: trm character(len=:),allocatable         :: sep_local, left_local, right_local character(len=:),allocatable         :: string logical                              :: trm_local integer                              :: i    if(present(sep))then   ; sep_local=sep     ; else ; sep_local=''     ; endif    if(present(trm))then   ; trm_local=trm     ; else ; trm_local=.true. ; endif    if(present(left))then  ; left_local=left   ; else ; left_local=''    ; endif    if(present(right))then ; right_local=right ; else ; right_local=''   ; endif    string=''    if(size(str)==0)then       string=string//left_local//right_local    else       do i = 1,size(str)-1          if(trm_local)then             string=string//left_local//trim(str(i))//right_local//sep_local          else             string=string//left_local//str(i)//right_local//sep_local          endif       enddo       if(trm_local)then          string=string//left_local//trim(str(i))//right_local       else          string=string//left_local//str(i)//right_local       endif    endif    if(present(start))string=start//string    if(present(end))string=string//end end function join  !>AUTHOR: John S. Urban !!LICENSE: Public Domain !> !!## NAME !!    glob(3f) - [fpm_strings:COMPARE] compare given string for match to !!    pattern which may contain wildcard characters !!    (LICENSE:PD) !! !!## SYNOPSIS !! !!    logical function glob(string, pattern ) !! !!     character(len=*),intent(in) :: string !!     character(len=*),intent(in) :: pattern !! !!## DESCRIPTION !!   glob(3f) compares given STRING for match to PATTERN which may !!   contain wildcard characters. !! !!   In this version to get a match the entire string must be described !!   by PATTERN. Trailing whitespace is significant, so trim the input !!   string to have trailing whitespace ignored. !! !!## OPTIONS !!    string   the input string to test to see if it contains the pattern. !!    pattern  the following simple globbing options are available !! !!             o "?" matching any one character !!             o "*" matching zero or more characters. !!               Do NOT use adjacent asterisks. !!             o Both strings may have trailing spaces which !!               are ignored. !!             o There is no escape character, so matching strings with !!               literal question mark and asterisk is problematic. !! !!## EXAMPLES !! !!   Example program !! !!    program demo_glob !!    implicit none !!    ! This main() routine passes a bunch of test strings !!    ! into the above code.  In performance comparison mode, !!    ! it does that over and over. Otherwise, it does it just !!    ! once. Either way, it outputs a passed/failed result. !!    ! !!    integer :: nReps !!    logical :: allpassed !!    integer :: i !!     allpassed = .true. !! !!     nReps = 10000 !!     ! Can choose as many repetitions as you're expecting !!     ! in the real world. !!     nReps = 1 !! !!     do i=1,nReps !!      ! Cases with repeating character sequences. !!      allpassed=allpassed .and. test("a*abab", "a*b", .true.) !!      !!cycle !!      allpassed=allpassed .and. test("ab", "*?", .true.) !!      allpassed=allpassed .and. test("abc", "*?", .true.) !!      allpassed=allpassed .and. test("abcccd", "*ccd", .true.) !!      allpassed=allpassed .and. test("bLah", "bLaH", .false.) !!      allpassed=allpassed .and. test("mississippi", "*sip*", .true.) !!      allpassed=allpassed .and. & !!       & test("xxxx*zzzzzzzzy*f", "xxx*zzy*f", .true.) !!      allpassed=allpassed .and. & !!       & test("xxxx*zzzzzzzzy*f", "xxxx*zzy*fffff", .false.) !!      allpassed=allpassed .and. & !!       & test("mississipissippi", "*issip*ss*", .true.) !!      allpassed=allpassed .and. & !!       & test("xxxxzzzzzzzzyf", "xxxx*zzy*fffff", .false.) !!      allpassed=allpassed .and. & !!       & test("xxxxzzzzzzzzyf", "xxxx*zzy*f", .true.) !!      allpassed=allpassed .and. test("xyxyxyzyxyz", "xy*z*xyz", .true.) !!      allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.) !!      allpassed=allpassed .and. test("mississippi", "mi*sip*", .true.) !!      allpassed=allpassed .and. test("ababac", "*abac*", .true.) !!      allpassed=allpassed .and. test("aaazz", "a*zz*", .true.) !!      allpassed=allpassed .and. test("a12b12", "*12*23", .false.) !!      allpassed=allpassed .and. test("a12b12", "a12b", .false.) !!      allpassed=allpassed .and. test("a12b12", "*12*12*", .true.) !! !!      ! Additional cases where the '*' char appears in the tame string. !!      allpassed=allpassed .and. test("*", "*", .true.) !!      allpassed=allpassed .and. test("a*r", "a*", .true.) !!      allpassed=allpassed .and. test("a*ar", "a*aar", .false.) !! !!      ! More double wildcard scenarios. !!      allpassed=allpassed .and. test("XYXYXYZYXYz", "XY*Z*XYz", .true.) !!      allpassed=allpassed .and. test("missisSIPpi", "*SIP*", .true.) !!      allpassed=allpassed .and. test("mississipPI", "*issip*PI", .true.) !!      allpassed=allpassed .and. test("xyxyxyxyz", "xy*xyz", .true.) !!      allpassed=allpassed .and. test("miSsissippi", "mi*sip*", .true.) !!      allpassed=allpassed .and. test("miSsissippi", "mi*Sip*", .false.) !!      allpassed=allpassed .and. test("abAbac", "*Abac*", .true.) !!      allpassed=allpassed .and. test("aAazz", "a*zz*", .true.) !!      allpassed=allpassed .and. test("A12b12", "*12*23", .false.) !!      allpassed=allpassed .and. test("a12B12", "*12*12*", .true.) !!      allpassed=allpassed .and. test("oWn", "*oWn*", .true.) !! !!      ! Completely tame (no wildcards) cases. !!      allpassed=allpassed .and. test("bLah", "bLah", .true.) !! !!      ! Simple mixed wildcard tests suggested by IBMer Marlin Deckert. !!      allpassed=allpassed .and. test("a", "*?", .true.) !! !!      ! More mixed wildcard tests including coverage for false positives. !!      allpassed=allpassed .and. test("a", "??", .false.) !!      allpassed=allpassed .and. test("ab", "?*?", .true.) !!      allpassed=allpassed .and. test("ab", "*?*?*", .true.) !!      allpassed=allpassed .and. test("abc", "?**?*?", .true.) !!      allpassed=allpassed .and. test("abc", "?**?*&?", .false.) !!      allpassed=allpassed .and. test("abcd", "?b*??", .true.) !!      allpassed=allpassed .and. test("abcd", "?a*??", .false.) !!      allpassed=allpassed .and. test("abcd", "?**?c?", .true.) !!      allpassed=allpassed .and. test("abcd", "?**?d?", .false.) !!      allpassed=allpassed .and. test("abcde", "?*b*?*d*?", .true.) !! !!      ! Single-character-match cases. !!      allpassed=allpassed .and. test("bLah", "bL?h", .true.) !!      allpassed=allpassed .and. test("bLaaa", "bLa?", .false.) !!      allpassed=allpassed .and. test("bLah", "bLa?", .true.) !!      allpassed=allpassed .and. test("bLaH", "?Lah", .false.) !!      allpassed=allpassed .and. test("bLaH", "?LaH", .true.) !! !!      ! Many-wildcard scenarios. !!      allpassed=allpassed .and. test(& !!      &"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa& !!      &aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab",& !!      &"a*a*a*a*a*a*aa*aaa*a*a*b",& !!      &.true.) !!      allpassed=allpassed .and. test(& !!      &"abababababababababababababababababababaacacacacacacac& !!      &adaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",& !!      &"*a*b*ba*ca*a*aa*aaa*fa*ga*b*",& !!      &.true.) !!      allpassed=allpassed .and. test(& !!      &"abababababababababababababababababababaacacacacacaca& !!      &cadaeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",& !!      &"*a*b*ba*ca*a*x*aaa*fa*ga*b*",& !!      &.false.) !!      allpassed=allpassed .and. test(& !!      &"abababababababababababababababababababaacacacacacacacad& !!      &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",& !!      &"*a*b*ba*ca*aaaa*fa*ga*gggg*b*",& !!      &.false.) !!      allpassed=allpassed .and. test(& !!      &"abababababababababababababababababababaacacacacacacacad& !!      &aeafagahaiajakalaaaaaaaaaaaaaaaaaffafagaagggagaaaaaaaab",& !!      &"*a*b*ba*ca*aaaa*fa*ga*ggg*b*",& !!      &.true.) !!      allpassed=allpassed .and. test("aaabbaabbaab", "*aabbaa*a*", .true.) !!      allpassed=allpassed .and. & !!      test("a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*",& !!      &"a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) !!      allpassed=allpassed .and. test("aaaaaaaaaaaaaaaaa",& !!      &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .true.) !!      allpassed=allpassed .and. test("aaaaaaaaaaaaaaaa",& !!      &"*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*a*", .false.) !!      allpassed=allpassed .and. test(& !!      &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij& !!      &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",& !!      & "abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc& !!      &*abc*abc*abc*",& !!      &.false.) !!      allpassed=allpassed .and. test(& !!      &"abc*abcd*abcde*abcdef*abcdefg*abcdefgh*abcdefghi*abcdefghij& !!      &*abcdefghijk*abcdefghijkl*abcdefghijklm*abcdefghijklmn",& !!      &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*",& !!      &.true.) !!      allpassed=allpassed .and. test("abc*abcd*abcd*abc*abcd",& !!      &"abc*abc*abc*abc*abc", .false.) !!      allpassed=allpassed .and. test( "abc*abcd*abcd*abc*abcd*abcd& !!      &*abc*abcd*abc*abc*abcd", & !!      &"abc*abc*abc*abc*abc*abc*abc*abc*abc*abc*abcd",& !!      &.true.) !!      allpassed=allpassed .and. test("abc",& !!      &"********a********b********c********", .true.) !!      allpassed=allpassed .and.& !!      &test("********a********b********c********", "abc", .false.) !!      allpassed=allpassed .and. & !!      &test("abc", "********a********b********b********", .false.) !!      allpassed=allpassed .and. test("*abc*", "***a*b*c***", .true.) !! !!      ! A case-insensitive algorithm test. !!      ! allpassed=allpassed .and. test("mississippi", "*issip*PI", .true.) !!     enddo !! !!     if (allpassed)then !!        write(*,'(a)')"Passed",nReps !!     else !!        write(*,'(a)')"Failed" !!     endif !!    contains !!    ! This is a test program for wildcard matching routines. !!    ! It can be used either to test a single routine for correctness, !!    ! or to compare the timings of two (or more) different wildcard !!    ! matching routines. !!    ! !!    function test(tame, wild, bExpectedResult) result(bpassed) !!    use fpm_strings, only : glob !!       character(len=*) :: tame !!       character(len=*) :: wild !!       logical          :: bExpectedResult !!       logical          :: bResult !!       logical          :: bPassed !!       bResult = .true.    ! We'll do "&=" cumulative checking. !!       bPassed = .false.   ! Assume the worst. !!       write(*,*)repeat('=',79) !!       bResult = glob(tame, wild) ! Call a wildcard matching routine. !! !!       ! To assist correctness checking, output the two strings in any !!       ! failing scenarios. !!       if (bExpectedResult .eqv. bResult) then !!          bPassed = .true. !!          if(nReps == 1) write(*,*)"Passed match on ",tame," vs. ", wild !!       else !!          if(nReps == 1) write(*,*)"Failed match on ",tame," vs. ", wild !!       endif !! !!    end function test !!    end program demo_glob !! !!   Expected output !! !! !!## REFERENCE !!   The article "Matching Wildcards: An Empirical Way to Tame an Algorithm" !!   in Dr Dobb's Journal, By Kirk J. Krauss, October 07, 2014 !! function glob(tame,wild)  ! @(#)fpm_strings::glob(3f): function compares text strings, one of which can have wildcards ('*' or '?').  logical                    :: glob       !! result of test character(len=*)           :: tame       !! A string without wildcards to compare to the globbing expression character(len=*)           :: wild       !! A (potentially) corresponding string with wildcards character(len=len(tame)+1) :: tametext character(len=len(wild)+1) :: wildtext character(len=1),parameter :: NULL=char(0) integer                    :: wlen integer                    :: ti, wi integer                    :: i character(len=:),allocatable :: tbookmark, wbookmark ! These two values are set when we observe a wildcard character. They ! represent the locations, in the two strings, from which we start once we've observed it.    tametext=tame//NULL    wildtext=wild//NULL    tbookmark = NULL    wbookmark = NULL    wlen=len(wild)    wi=1    ti=1    do                                            ! Walk the text strings one character at a time.       if(wildtext(wi:wi) == '*')then             ! How do you match a unique text string?          do i=wi,wlen                            ! Easy: unique up on it!             if(wildtext(wi:wi)=='*')then                wi=wi+1             else                exit             endif          enddo          if(wildtext(wi:wi)==NULL) then        ! "x" matches "*"             glob=.true.             return          endif          if(wildtext(wi:wi) /= '?') then             ! Fast-forward to next possible match.             do while (tametext(ti:ti) /= wildtext(wi:wi))                ti=ti+1                if (tametext(ti:ti)==NULL)then                   glob=.false.                   return                         ! "x" doesn't match "*y*"                endif             enddo          endif          wbookmark = wildtext(wi:)          tbookmark = tametext(ti:)       elseif(tametext(ti:ti) /= wildtext(wi:wi) .and. wildtext(wi:wi) /= '?') then          ! Got a non-match. If we've set our bookmarks, back up to one or both of them and retry.          if(wbookmark/=NULL) then             if(wildtext(wi:)/= wbookmark) then                wildtext = wbookmark;                wlen=len_trim(wbookmark)                wi=1                ! Don't go this far back again.                if (tametext(ti:ti) /= wildtext(wi:wi)) then                   tbookmark=tbookmark(2:)                   tametext = tbookmark                   ti=1                   cycle                          ! "xy" matches "*y"                else                   wi=wi+1                endif             endif             if (tametext(ti:ti)/=NULL) then                ti=ti+1                cycle                             ! "mississippi" matches "*sip*"             endif          endif          glob=.false.          return                                  ! "xy" doesn't match "x"       endif       ti=ti+1       wi=wi+1       if (tametext(ti:ti)==NULL) then          ! How do you match a tame text string?          if(wildtext(wi:wi)/=NULL)then             do while (wildtext(wi:wi) == '*')    ! The tame way: unique up on it!                wi=wi+1                           ! "x" matches "x*"                if(wildtext(wi:wi)==NULL)exit             enddo          endif          if (wildtext(wi:wi)==NULL)then             glob=.true.             return                               ! "x" matches "x"          endif          glob=.false.          return                                  ! "x" doesn't match "xy"       endif    enddo end function glob  !> Returns the length of the string representation of 'i' pure integer function str_int_len(i) result(sz) integer, intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s ! If 's' is too short (MAX_STR too small), Fortran will abort with: ! "Fortran runtime error: End of record" write(s, '(i0)') i sz = len_trim(s) end function  !> Converts integer "i" to string pure function str_int(i) result(s) integer, intent(in) :: i character(len=str_int_len(i)) :: s write(s, '(i0)') i end function  !> Returns the length of the string representation of 'i' pure integer function str_int64_len(i) result(sz) integer(int64), intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s ! If 's' is too short (MAX_STR too small), Fortran will abort with: ! "Fortran runtime error: End of record" write(s, '(i0)') i sz = len_trim(s) end function  !> Converts integer "i" to string pure function str_int64(i) result(s) integer(int64), intent(in) :: i character(len=str_int64_len(i)) :: s write(s, '(i0)') i end function  !> Returns the length of the string representation of 'l' pure integer function str_logical_len(l) result(sz) logical, intent(in) :: l if (l) then     sz = 6 else     sz = 7 end if end function  !> Converts logical "l" to string pure function str_logical(l) result(s) logical, intent(in) :: l character(len=str_logical_len(l)) :: s if (l) then     s = ".true." else     s = ".false." end if end function  !> Returns string with special characters replaced with an underscore. !! For now, only a hyphen is treated as a special character, but this can be !! expanded to other characters if needed. pure function to_fortran_name(string) result(res)     character(*), intent(in) :: string     character(len(string)) :: res     character, parameter :: SPECIAL_CHARACTERS(*) = ['-']     res = replace(string, SPECIAL_CHARACTERS, '_') end function to_fortran_name  elemental function is_fortran_name(line) result (lout) ! determine if a string is a valid Fortran name ignoring trailing spaces ! (but not leading spaces)     character(len=*),parameter   :: int='0123456789'     character(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'     character(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'     character(len=*),parameter   :: allowed=upper//lower//int//'_'     character(len=*),intent(in)  :: line     character(len=:),allocatable :: name     logical                      :: lout         name=trim(line)         if(len(name)/=0)then             lout = .true.                                  &              & .and. verify(name(1:1), lower//upper) == 0  &              & .and. verify(name,allowed) == 0             &              & .and. len(name) <= 63         else             lout = .false.         endif end function is_fortran_name  !> Check that a module name fits the current naming rules: !> 1) It must be a valid FORTRAN name (<=63 chars, begin with letter, "_" is only allowed non-alphanumeric) !> 2) It must begin with the package name !> 3) If longer, package name must be followed by default separator plus at least one char logical function is_valid_module_name(module_name,package_name,custom_prefix,enforce_module_names) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: package_name     type(string_t), intent(in) :: custom_prefix     logical       , intent(in) :: enforce_module_names       !> Basic check: check the name is Fortran-compliant     valid = is_fortran_name(module_name%s); if (.not.valid) return      !> FPM package enforcing: check that the module name begins with the package name     if (enforce_module_names) then          ! Default prefixing is always valid         valid = has_valid_standard_prefix(module_name,package_name)          ! If a custom prefix was validated, it provides additional naming options         ! Because they never overlap with the default prefix, the former is always an option         if (len_trim(custom_prefix)>0 .and. .not.valid) &             valid = has_valid_custom_prefix(module_name,custom_prefix)      end if  end function is_valid_module_name  !> Check that a custom module prefix fits the current naming rules: !> 1) Only alphanumeric characters (no spaces, dashes, underscores or other characters) !> 2) Does not begin with a number (Fortran-compatible syntax) logical function is_valid_module_prefix(module_prefix) result(valid)      type(string_t), intent(in) :: module_prefix      character(len=*),parameter :: num='0123456789'     character(len=*),parameter :: lower='abcdefghijklmnopqrstuvwxyz'     character(len=*),parameter :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'     character(len=*),parameter :: alpha  =upper//lower     character(len=*),parameter :: allowed=alpha//num      character(len=:),allocatable :: name      name = trim(module_prefix%s)      if (len(name)>0 .and. len(name)<=63) then         valid = verify(name(1:1), alpha) == 0 .and. &                 verify(name,allowed)     == 0     else         valid = .false.     endif  end function is_valid_module_prefix   type(string_t) function module_prefix_template(project_name,custom_prefix) result(prefix)     type(string_t), intent(in) :: project_name     type(string_t), intent(in) :: custom_prefix      if (is_valid_module_prefix(custom_prefix)) then          prefix = string_t(trim(custom_prefix%s)//"_")      else          prefix = string_t(to_fortran_name(project_name%s)//"__")      end if  end function module_prefix_template  type(string_t) function module_prefix_type(project_name,custom_prefix) result(ptype)     type(string_t), intent(in) :: project_name     type(string_t), intent(in) :: custom_prefix      if (is_valid_module_prefix(custom_prefix)) then         ptype = string_t("custom")     else         ptype = string_t("default")     end if  end function module_prefix_type  !> Check that a module name is prefixed with a custom prefix: !> 1) It must be a valid FORTRAN name subset (<=63 chars, begin with letter, only alphanumeric allowed) !> 2) It must begin with the prefix !> 3) If longer, package name must be followed by default separator ("_") plus at least one char logical function has_valid_custom_prefix(module_name,custom_prefix) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: custom_prefix      !> custom_module separator: single underscore     character(*), parameter :: SEP = "_"      logical :: is_same,has_separator,same_beginning     integer :: lpkg,lmod,lsep      !> Basic check: check that both names are individually valid     valid = is_fortran_name(module_name%s) .and. &             is_valid_module_prefix(custom_prefix)      !> FPM package enforcing: check that the module name begins with the custom prefix     if (valid) then          !> Query string lengths         lpkg  = len_trim(custom_prefix)         lmod  = len_trim(module_name)         lsep  = len_trim(SEP)          same_beginning = str_begins_with_str(module_name%s,custom_prefix%s,case_sensitive=.false.)          is_same = lpkg==lmod .and. same_beginning          if (lmod>=lpkg+lsep) then            has_separator = str_begins_with_str(module_name%s(lpkg+1:lpkg+lsep),SEP)         else            has_separator = .false.         endif          !> 2) It must begin with the package name.         !> 3) It can be equal to the package name, or, if longer, must be followed by the         !     default separator plus at least one character         !> 4) Package name must not end with an underscore         valid = same_beginning .and. (is_same .or. (lmod>lpkg+lsep .and. has_separator))      end if  end function has_valid_custom_prefix   !> Check that a module name is prefixed with the default package prefix: !> 1) It must be a valid FORTRAN name (<=63 chars, begin with letter, "_" is only allowed non-alphanumeric) !> 2) It must begin with the package name !> 3) If longer, package name must be followed by default separator plus at least one char logical function has_valid_standard_prefix(module_name,package_name) result(valid)      type(string_t), intent(in) :: module_name     type(string_t), intent(in) :: package_name      !> Default package__module separator: two underscores     character(*), parameter :: SEP = "__"      character(len=:), allocatable :: fortranized_pkg     logical :: is_same,has_separator,same_beginning     integer :: lpkg,lmod,lsep      !> Basic check: check the name is Fortran-compliant     valid = is_fortran_name(module_name%s)      !> FPM package enforcing: check that the module name begins with the package name     if (valid) then          fortranized_pkg = to_fortran_name(package_name%s)          !> Query string lengths         lpkg  = len_trim(fortranized_pkg)         lmod  = len_trim(module_name)         lsep  = len_trim(SEP)          same_beginning = str_begins_with_str(module_name%s,fortranized_pkg,case_sensitive=.false.)          is_same = lpkg==lmod .and. same_beginning          if (lmod>=lpkg+lsep) then            has_separator = str_begins_with_str(module_name%s(lpkg+1:lpkg+lsep),SEP)         else            has_separator = .false.         endif          !> 2) It must begin with the package name.         !> 3) It can be equal to the package name, or, if longer, must be followed by the         !     default separator plus at least one character         !> 4) Package name must not end with an underscore         valid = is_fortran_name(fortranized_pkg) .and. &                 fortranized_pkg(lpkg:lpkg)/='_' .and. &                 (same_beginning .and. (is_same .or. (lmod>lpkg+lsep .and. has_separator)))      end if  end function has_valid_standard_prefix  ! Remove all characters from a set from a string subroutine remove_characters_in_set(string,set,replace_with)     character(len=:), allocatable, intent(inout) :: string     character(*), intent(in) :: set     character, optional, intent(in) :: replace_with ! Replace with this character instead of removing      integer :: feed,length      if (.not.allocated(string)) return     if (len(set)<=0) return      length = len(string)     feed   = scan(string,set)      do while (length>0 .and. feed>0)          ! Remove heading         if (length==1) then             string = ""          elseif (feed==1) then             string = string(2:length)          ! Remove trailing         elseif (feed==length) then             string = string(1:length-1)          ! In between: replace with given character         elseif (present(replace_with)) then             string(feed:feed) = replace_with         ! Or just remove         else             string = string(1:feed-1)//string(feed+1:length)         end if          length = len(string)         feed   = scan(string,set)      end do  end subroutine remove_characters_in_set  ! Remove all new line characters from the current string, replace them with spaces subroutine remove_newline_characters(string)     type(string_t), intent(inout) :: string      integer :: feed,length      character(*), parameter :: CRLF  = new_line('a')//achar(13)     character(*), parameter :: SPACE = ' '      call remove_characters_in_set(string%s,set=CRLF,replace_with=SPACE)  end subroutine remove_newline_characters  !>AUTHOR: John S. Urban !!LICENSE: Public Domain !> !!### NAME !!   notabs(3f) - [fpm_strings:NONALPHA] expand tab characters !!   (LICENSE:PD) !! !!### SYNOPSIS !! !!    subroutine notabs(INSTR,OUTSTR,ILEN) !! !!     character(len=*),intent=(in)  :: INSTR !!     character(len=*),intent=(out) :: OUTSTR !!     integer,intent=(out)          :: ILEN !! !!### DESCRIPTION !!   NOTABS() converts tabs in INSTR to spaces in OUTSTR while maintaining !!   columns. It assumes a tab is set every 8 characters. Trailing spaces !!   are removed. !! !!   In addition, trailing carriage returns and line feeds are removed !!   (they are usually a problem created by going to and from MSWindows). !! !!   What are some reasons for removing tab characters from an input line? !!   Some Fortran compilers have problems with tabs, as tabs are not !!   part of the Fortran character set. Some editors and printers will !!   have problems with tabs. It is often useful to expand tabs in input !!   files to simplify further processing such as tokenizing an input line. !! !!### OPTIONS !!     instr     Input line to remove tabs from !! !!### RESULTS !!     outstr    Output string with tabs expanded. Assumed to be of sufficient !!               length !!     ilen      Significant length of returned string !! !!### EXAMPLES !! !!   Sample program: !! !!    program demo_notabs !! !!    !  test filter to remove tabs and trailing white space from input !!    !  on files up to 1024 characters wide !!    use fpm_strings, only : notabs !!    character(len=1024) :: in,out !!    integer             :: ios,iout !!       do !!          read(*,'(A)',iostat=ios)in !!          if(ios /= 0) exit !!          call notabs(in,out,iout) !!          write(*,'(a)')out(:iout) !!       enddo !!    end program demo_notabs !! !!### SEE ALSO !!   GNU/Unix commands expand(1) and unexpand(1) !! elemental impure subroutine notabs(instr,outstr,ilen)  ! ident_31="@(#)fpm_strings::notabs(3f): convert tabs to spaces while maintaining columns, remove CRLF chars"  character(len=*),intent(in)   :: instr        ! input line to scan for tab characters character(len=*),intent(out)  :: outstr       ! tab-expanded version of INSTR produced integer,intent(out)           :: ilen         ! column position of last character put into output string                                               ! that is, ILEN holds the position of the last non-blank character in OUTSTR  integer,parameter             :: tabsize=8    ! assume a tab stop is set every 8th column integer                       :: ipos         ! position in OUTSTR to put next character of INSTR integer                       :: lenin        ! length of input string trimmed of trailing spaces integer                       :: lenout       ! number of characters output string can hold integer                       :: istep        ! counter that advances thru input string INSTR one character at a time character(len=1)              :: c            ! character in input line being processed integer                       :: iade         ! ADE (ASCII Decimal Equivalent) of character being tested     ipos=1                                     ! where to put next character in output string OUTSTR    lenin=len_trim(instr( 1:len(instr) ))      ! length of INSTR trimmed of trailing spaces    lenout=len(outstr)                         ! number of characters output string OUTSTR can hold    outstr=" "                                 ! this SHOULD blank-fill string, a buggy machine required a loop to set all characters        SCAN_LINE: do istep=1,lenin             ! look through input string one character at a time          c=instr(istep:istep)                 ! get next character          iade=ichar(c)                        ! get ADE of the character          EXPAND_TABS : select case (iade)     ! take different actions depending on which character was found          case(9)                              ! test if character is a tab and move pointer out to appropriate column             ipos = ipos + (tabsize - (mod(ipos-1,tabsize)))          case(10,13)                          ! convert carriage-return and new-line to space ,typically to handle DOS-format files             ipos=ipos+1          case default                         ! c is anything else other than a tab,newline,or return  insert it in output string             if(ipos > lenout)then                write(stderr,*)"*notabs* output string overflow"                exit             else                outstr(ipos:ipos)=c                ipos=ipos+1             endif          end select EXPAND_TABS       enddo SCAN_LINE        ipos=min(ipos,lenout)                   ! tabs or newline or return characters or last character might have gone too far       ilen=len_trim(outstr(:ipos))            ! trim trailing spaces  end subroutine notabs  !>AUTHOR: John S. Urban !!LICENSE: Public Domain !> !!##NAME !!    dilate(3f) - [M_strings:NONALPHA] expand tab characters !!    (LICENSE:PD) !! !!##SYNOPSIS !! !!    function dilate(INSTR) result(OUTSTR) !! !!     character(len=*),intent=(in)  :: INSTR !!     character(len=:),allocatable  :: OUTSTR !! !!##DESCRIPTION !!     dilate() converts tabs in INSTR to spaces in OUTSTR.  It assumes a !!     tab is set every 8 characters. Trailing spaces are removed. !! !!     In addition, trailing carriage returns and line feeds are removed !!     (they are usually a problem created by going to and from MSWindows). !! !!##OPTIONS !!     instr     Input line to remove tabs from !! !!##RESULTS !!     outstr    Output string with tabs expanded. !! !!##EXAMPLES !! !!   Sample program: !! !!    program demo_dilate !! !!    use M_strings, only : dilate !!    implicit none !!    character(len=:),allocatable :: in !!    integer                      :: i !!       in='  this is my string  ' !!       ! change spaces to tabs to make a sample input !!       do i=1,len(in) !!          if(in(i:i) == ' ')in(i:i)=char(9) !!       enddo !!       write(*,'(a)')in,dilate(in) !!    end program demo_dilate !! function dilate(instr) result(outstr)     character(len=*), intent(in)  :: instr        ! input line to scan for tab characters    character(len=:), allocatable :: outstr       ! tab-expanded version of INSTR produced    integer                       :: i    integer                       :: icount    integer                       :: lgth    icount = 0    do i = 1, len(instr)       if (instr(i:i) == char(9)) icount = icount + 1    end do    allocate (character(len=(len(instr) + 8*icount)) :: outstr)    call notabs(instr, outstr, lgth)    outstr = outstr(:lgth)  end function dilate  end module fpm_strings 
fpm_targets.f90_stripped                          module fpm_targets use iso_fortran_env, only: int64 use fpm_error, only: error_t, fatal_error, fpm_stop use fpm_model use fpm_compiler, only : compiler_t use fpm_environment, only: get_os_type, OS_WINDOWS, OS_MACOS use fpm_filesystem, only: dirname, join_path, canon_path use fpm_strings, only: string_t, operator(.in.), string_cat, fnv_1a, resize, lower, str_ends_with use fpm_compiler, only: get_macros use fpm_sources, only: get_exe_name_with_suffix use fpm_manifest_preprocess, only: preprocess_config_t implicit none  private  public FPM_TARGET_UNKNOWN, FPM_TARGET_EXECUTABLE, &        FPM_TARGET_ARCHIVE, FPM_TARGET_OBJECT, &        FPM_TARGET_C_OBJECT, FPM_TARGET_CPP_OBJECT public build_target_t, build_target_ptr public targets_from_sources, resolve_module_dependencies public add_target, add_dependency public filter_library_targets, filter_executable_targets, filter_modules     integer, parameter :: FPM_TARGET_UNKNOWN = -1  integer, parameter :: FPM_TARGET_EXECUTABLE = 1  integer, parameter :: FPM_TARGET_ARCHIVE = 2  integer, parameter :: FPM_TARGET_OBJECT = 3  integer, parameter :: FPM_TARGET_C_OBJECT = 4  integer, parameter :: FPM_TARGET_CPP_OBJECT = 5   type build_target_ptr      type(build_target_t), pointer :: ptr => null()  end type build_target_ptr    type build_target_t           character(:), allocatable :: output_file           character(:), allocatable :: output_name           character(:), allocatable :: output_dir           character(:), allocatable :: output_log_file           character(:), allocatable :: package_name           type(srcfile_t), allocatable :: source           type(build_target_ptr), allocatable :: dependencies(:)           integer :: target_type = FPM_TARGET_UNKNOWN           type(string_t), allocatable :: link_libraries(:)           type(string_t), allocatable :: link_objects(:)           character(:), allocatable :: link_flags           character(:), allocatable :: compile_flags           logical :: touched = .false.           logical :: sorted = .false.           logical :: skip = .false.           type(fortran_features_t) :: features           integer :: schedule = -1           integer(int64), allocatable :: digest_cached           type(string_t), allocatable :: macros(:)           character(:), allocatable :: version  end type build_target_t   contains   subroutine targets_from_sources(targets,model,prune,error)           type(build_target_ptr), intent(out), allocatable :: targets(:)           type(fpm_model_t), intent(inout), target :: model           logical, intent(in) :: prune           type(error_t), intent(out), allocatable :: error      call build_target_list(targets,model)      call collect_exe_link_dependencies(targets)      call resolve_module_dependencies(targets,model%external_modules,error)     if (allocated(error)) return      if (prune) then         call prune_build_targets(targets,root_package=model%package_name)     end if      call resolve_target_linking(targets,model)  end subroutine targets_from_sources                      subroutine build_target_list(targets,model)           type(build_target_ptr), intent(out), allocatable :: targets(:)           type(fpm_model_t), intent(inout), target :: model      integer :: i, j, n_source, exe_type     character(:), allocatable :: exe_dir, compile_flags     logical :: with_lib           allocate(targets(0))           n_source = sum([(size(model%packages(j)%sources), &                       j=1,size(model%packages))])      if (n_source < 1) return      with_lib = any([((model%packages(j)%sources(i)%unit_scope == FPM_SCOPE_LIB, &                       i=1,size(model%packages(j)%sources)), &                       j=1,size(model%packages))])      if (with_lib) call add_target(targets,package=model%package_name,type = FPM_TARGET_ARCHIVE,&                             output_name = join_path(&                                    model%package_name,'lib'//model%package_name//'.a'))      do j=1,size(model%packages)          associate(sources=>model%packages(j)%sources)              do i=1,size(sources)                  if (.not. model%include_tests) then                     if (sources(i)%unit_scope == FPM_SCOPE_TEST) cycle                 end if                  select case (sources(i)%unit_type)                 case (FPM_UNIT_MODULE,FPM_UNIT_SUBMODULE,FPM_UNIT_SUBPROGRAM,FPM_UNIT_CSOURCE)                      call add_target(targets,package=model%packages(j)%name,source = sources(i), &                                 type = merge(FPM_TARGET_C_OBJECT,FPM_TARGET_OBJECT,&                                                sources(i)%unit_type==FPM_UNIT_CSOURCE), &                                 output_name = get_object_name(sources(i)), &                                 features = model%packages(j)%features, &                                 preprocess = model%packages(j)%preprocess, &                                 version = model%packages(j)%version)                       if (with_lib .and. sources(i)%unit_scope == FPM_SCOPE_LIB) then                                                  call add_dependency(targets(1)%ptr, targets(size(targets))%ptr)                     end if                  case (FPM_UNIT_CPPSOURCE)                      call add_target(targets,package=model%packages(j)%name,source = sources(i), &                                 type = FPM_TARGET_CPP_OBJECT, &                                 output_name = get_object_name(sources(i)), &                                 preprocess = model%packages(j)%preprocess, &                                 version = model%packages(j)%version)                      if (with_lib .and. sources(i)%unit_scope == FPM_SCOPE_LIB) then                                                  call add_dependency(targets(1)%ptr, targets(size(targets))%ptr)                     end if                                           if (.not. ("stdc++" .in. model%link_libraries)) then                          if (get_os_type() == OS_MACOS) then                             model%link_libraries = [model%link_libraries, string_t("c++")]                         else                             model%link_libraries = [model%link_libraries, string_t("stdc++")]                         end if                      end if                  case (FPM_UNIT_PROGRAM)                      if (str_ends_with(lower(sources(i)%file_name), [".c"])) then                         exe_type = FPM_TARGET_C_OBJECT                     else if (str_ends_with(lower(sources(i)%file_name), [".cpp", ".cc "])) then                         exe_type = FPM_TARGET_CPP_OBJECT                     else                             exe_type = FPM_TARGET_OBJECT                     end if                      call add_target(targets,package=model%packages(j)%name,type = exe_type,&                                 output_name = get_object_name(sources(i)), &                                 source = sources(i), &                                 features = model%packages(j)%features, &                                 preprocess = model%packages(j)%preprocess &                                 )                      if (sources(i)%unit_scope == FPM_SCOPE_APP) then                          exe_dir = 'app'                      else if (sources(i)%unit_scope == FPM_SCOPE_EXAMPLE) then                          exe_dir = 'example'                      else                          exe_dir = 'test'                      end if                      call add_target(targets,package=model%packages(j)%name,type = FPM_TARGET_EXECUTABLE,&                                     link_libraries = sources(i)%link_libraries, &                                     output_name = join_path(exe_dir,get_exe_name_with_suffix(sources(i))))                      associate(target => targets(size(targets))%ptr)                                           select case (exe_type)                        case (FPM_TARGET_C_OBJECT)                             call model%compiler%get_main_flags("c",compile_flags)                        case (FPM_TARGET_CPP_OBJECT)                             call model%compiler%get_main_flags("c++",compile_flags)                        case default                             compile_flags = ""                     end select                     target%compile_flags = target%compile_flags//' '//compile_flags                                           call add_dependency(target, targets(size(targets)-1)%ptr)                      if (with_lib) then                                                  call add_dependency(target, targets(1)%ptr)                     end if                      endassociate                  end select              end do          end associate      end do      contains      function get_object_name(source) result(object_file)                                    type(srcfile_t), intent(in) :: source         character(:), allocatable :: object_file          integer :: i         character(1), parameter :: filesep = '/'          object_file = canon_path(source%file_name)                   i = index(object_file,filesep)         do while(i > 0)             object_file(i:i) = '_'             i = index(object_file,filesep)         end do          object_file = join_path(model%package_name,object_file)//'.o'      end function get_object_name  end subroutine build_target_list           subroutine collect_exe_link_dependencies(targets)     type(build_target_ptr), intent(inout) :: targets(:)      integer :: i, j     character(:), allocatable :: exe_source_dir           do j=1,size(targets)          if (targets(j)%ptr%target_type == FPM_TARGET_EXECUTABLE) then              do i=1,size(targets)                  if (i == j) cycle                  associate(exe => targets(j)%ptr, dep => targets(i)%ptr)                      exe_source_dir = dirname(exe%dependencies(1)%ptr%source%file_name)                      if (allocated(dep%source)) then                          if (dep%source%unit_scope /= FPM_SCOPE_LIB .and. &                             dep%source%unit_type /= FPM_UNIT_PROGRAM .and. &                             dep%source%unit_type /= FPM_UNIT_MODULE .and. &                             index(dirname(dep%source%file_name), exe_source_dir) == 1) then                              call add_dependency(exe, dep)                          end if                      end if                  end associate              end do          end if      end do  end subroutine collect_exe_link_dependencies    subroutine add_target(targets, package, type, output_name, source, link_libraries, &         & features, preprocess, version)     type(build_target_ptr), allocatable, intent(inout) :: targets(:)     character(*), intent(in) :: package     integer, intent(in) :: type     character(*), intent(in) :: output_name     type(srcfile_t), intent(in), optional :: source     type(string_t), intent(in), optional :: link_libraries(:)     type(fortran_features_t), intent(in), optional :: features     type(preprocess_config_t), intent(in), optional :: preprocess     character(*), intent(in), optional :: version      integer :: i     type(build_target_t), pointer :: new_target      if (.not.allocated(targets)) allocate(targets(0))           do i=1,size(targets)          if (targets(i)%ptr%output_name == output_name) then              write(*,*) 'Error while building target list: duplicate output object "',&                         output_name,'"'             if (present(source)) write(*,*) ' Source file: "',source%file_name,'"'             call fpm_stop(1,' ')          end if      end do      allocate(new_target)     new_target%target_type = type     new_target%output_name = output_name     new_target%package_name = package     if (present(source)) new_target%source = source     if (present(link_libraries)) new_target%link_libraries = link_libraries     if (present(features)) new_target%features = features     if (present(preprocess)) then         if (allocated(preprocess%macros)) new_target%macros = preprocess%macros     endif     if (present(version)) new_target%version = version     allocate(new_target%dependencies(0))      targets = [targets, build_target_ptr(new_target)]  end subroutine add_target    subroutine add_dependency(target, dependency)     type(build_target_t), intent(inout) :: target     type(build_target_t) , intent(in), target :: dependency      target%dependencies = [target%dependencies, build_target_ptr(dependency)]  end subroutine add_dependency                         subroutine resolve_module_dependencies(targets,external_modules,error)     type(build_target_ptr), intent(inout), target :: targets(:)     type(string_t), intent(in) :: external_modules(:)     type(error_t), allocatable, intent(out) :: error      type(build_target_ptr) :: dep      integer :: i, j      do i=1,size(targets)          if (.not.allocated(targets(i)%ptr%source)) cycle              do j=1,size(targets(i)%ptr%source%modules_used)                  if (targets(i)%ptr%source%modules_used(j)%s .in. targets(i)%ptr%source%modules_provided) then                                          cycle                 end if                  if (targets(i)%ptr%source%modules_used(j)%s .in. external_modules) then                                          cycle                 end if                  if (any(targets(i)%ptr%source%unit_scope == &                     [FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST])) then                     dep%ptr => &                         find_module_dependency(targets,targets(i)%ptr%source%modules_used(j)%s, &                                             include_dir = dirname(targets(i)%ptr%source%file_name))                 else                     dep%ptr => &                         find_module_dependency(targets,targets(i)%ptr%source%modules_used(j)%s)                 end if                  if (.not.associated(dep%ptr)) then                     call fatal_error(error, &                             'Unable to find source for module dependency: "' // &                             targets(i)%ptr%source%modules_used(j)%s // &                             '" used by "'//targets(i)%ptr%source%file_name//'"')                     return                 end if                  call add_dependency(targets(i)%ptr, dep%ptr)              end do      end do  end subroutine resolve_module_dependencies  function find_module_dependency(targets,module_name,include_dir) result(target_ptr)                              type(build_target_ptr), intent(in), target :: targets(:)     character(*), intent(in) :: module_name     character(*), intent(in), optional :: include_dir     type(build_target_t), pointer :: target_ptr      integer :: k, l      target_ptr => NULL()      do k=1,size(targets)          if (.not.allocated(targets(k)%ptr%source)) cycle          do l=1,size(targets(k)%ptr%source%modules_provided)              if (module_name == targets(k)%ptr%source%modules_provided(l)%s) then                 select case(targets(k)%ptr%source%unit_scope)                 case (FPM_SCOPE_LIB, FPM_SCOPE_DEP)                     target_ptr => targets(k)%ptr                     exit                 case default                     if (present(include_dir)) then                         if (index(dirname(targets(k)%ptr%source%file_name), include_dir) == 1) then                              target_ptr => targets(k)%ptr                             exit                         end if                     end if                 end select             end if          end do      end do  end function find_module_dependency    subroutine prune_build_targets(targets, root_package)           type(build_target_ptr), intent(inout), allocatable :: targets(:)           character(*), intent(in) :: root_package      integer :: i, j, nexec     type(string_t), allocatable :: modules_used(:)     logical :: exclude_target(size(targets))     logical, allocatable :: exclude_from_archive(:)      if (size(targets) < 1) then         return     end if      nexec = 0     allocate(modules_used(0))           do i=1,size(targets)          if (targets(i)%ptr%target_type == FPM_TARGET_EXECUTABLE) then              nexec = nexec + 1             call collect_used_modules(targets(i)%ptr)          elseif (allocated(targets(i)%ptr%source)) then              if (targets(i)%ptr%source%unit_type == FPM_UNIT_SUBPROGRAM) then                  call collect_used_modules(targets(i)%ptr)              end if          end if      end do                if (nexec < 1) then          do i=1,size(targets)              if (targets(i)%ptr%package_name == root_package .and. &                  targets(i)%ptr%target_type /= FPM_TARGET_ARCHIVE) then                  call collect_used_modules(targets(i)%ptr)              end if          end do      end if      call reset_target_flags(targets)      exclude_target(:) = .false.           do i=1,size(targets)         associate(target=>targets(i)%ptr)              if (allocated(target%source)) then                 if (target%source%unit_type == FPM_UNIT_MODULE) then                      exclude_target(i) = .true.                     target%skip = .true.                      do j=1,size(target%source%modules_provided)                          if (target%source%modules_provided(j)%s .in. modules_used) then                              exclude_target(i) = .false.                             target%skip = .false.                          end if                      end do                  elseif (target%source%unit_type == FPM_UNIT_SUBMODULE) then                                           exclude_target(i) = .true.                     target%skip = .true.                     do j=1,size(target%source%parent_modules)                          if (target%source%parent_modules(j)%s .in. modules_used) then                              exclude_target(i) = .false.                             target%skip = .false.                          end if                      end do                  end if             end if                           if (nexec < 1 .and. target%package_name == root_package) then                 exclude_target(i) = .false.                 target%skip = .false.             end if          end associate     end do      targets = pack(targets,.not.exclude_target)           if (targets(1)%ptr%target_type == FPM_TARGET_ARCHIVE) then         associate(archive=>targets(1)%ptr)              allocate(exclude_from_archive(size(archive%dependencies)))             exclude_from_archive(:) = .false.              do i=1,size(archive%dependencies)                  if (archive%dependencies(i)%ptr%skip) then                      exclude_from_archive(i) = .true.                  end if              end do              archive%dependencies = pack(archive%dependencies,.not.exclude_from_archive)          end associate     end if      contains           recursive subroutine collect_used_modules(target)         type(build_target_t), intent(inout) :: target          integer :: j, k          if (target%touched) then             return         else             target%touched = .true.         end if          if (allocated(target%source)) then                           do j=1,size(target%source%modules_provided)                  if (.not.(target%source%modules_provided(j)%s .in. modules_used)) then                      modules_used = [modules_used, target%source%modules_provided(j)]                  end if                                   do k=1,size(targets)                     if (allocated(targets(k)%ptr%source)) then                         if (targets(k)%ptr%source%unit_type == FPM_UNIT_SUBMODULE) then                             if (target%source%modules_provided(j)%s .in. targets(k)%ptr%source%parent_modules) then                                 call collect_used_modules(targets(k)%ptr)                             end if                         end if                     end if                 end do              end do         end if                   do j=1,size(target%dependencies)              if (target%dependencies(j)%ptr%target_type /= FPM_TARGET_ARCHIVE) then                 call collect_used_modules(target%dependencies(j)%ptr)             end if          end do      end subroutine collect_used_modules           subroutine reset_target_flags(targets)         type(build_target_ptr), intent(inout) :: targets(:)          integer :: i          do i=1,size(targets)              targets(i)%ptr%touched = .false.          end do      end subroutine reset_target_flags  end subroutine prune_build_targets      subroutine resolve_target_linking(targets, model)     type(build_target_ptr), intent(inout), target :: targets(:)     type(fpm_model_t), intent(in) :: model      integer :: i     character(:), allocatable :: global_link_flags, local_link_flags     character(:), allocatable :: global_include_flags      if (size(targets) == 0) return      global_link_flags = ""     if (allocated(model%link_libraries)) then         if (size(model%link_libraries) > 0) then             global_link_flags = model%compiler%enumerate_libraries(global_link_flags, model%link_libraries)         end if     end if      allocate(character(0) :: global_include_flags)     if (allocated(model%include_dirs)) then         if (size(model%include_dirs) > 0) then             global_include_flags = global_include_flags // &             & " -I" // string_cat(model%include_dirs," -I")         end if     end if      do i=1,size(targets)          associate(target => targets(i)%ptr)                                                     if (.not.allocated(target%compile_flags)) allocate(character(len=0) :: target%compile_flags)              target%compile_flags = target%compile_flags//' '              select case (target%target_type)                case (FPM_TARGET_C_OBJECT)                    target%compile_flags = target%compile_flags//model%c_compile_flags                case (FPM_TARGET_CPP_OBJECT)                    target%compile_flags = target%compile_flags//model%cxx_compile_flags                case default                    target%compile_flags = target%compile_flags//model%fortran_compile_flags &                                         & // get_feature_flags(model%compiler, target%features)             end select                           target%compile_flags = target%compile_flags // get_macros(model%compiler%id, &                                                             target%macros, &                                                             target%version)              if (len(global_include_flags) > 0) then                 target%compile_flags = target%compile_flags//global_include_flags             end if             target%output_dir = get_output_dir(model%build_prefix, target%compile_flags)             target%output_file = join_path(target%output_dir, target%output_name)             target%output_log_file = join_path(target%output_dir, target%output_name)//'.log'         end associate      end do      call add_include_build_dirs(model, targets)      do i=1,size(targets)          associate(target => targets(i)%ptr)             allocate(target%link_objects(0))              if (target%target_type == FPM_TARGET_ARCHIVE) then                 global_link_flags = target%output_file // global_link_flags                  call get_link_objects(target%link_objects,target,is_exe=.false.)                  allocate(character(0) :: target%link_flags)              else if (target%target_type == FPM_TARGET_EXECUTABLE) then                  call get_link_objects(target%link_objects,target,is_exe=.true.)                  local_link_flags = ""                 if (allocated(model%link_flags)) local_link_flags = model%link_flags                 target%link_flags = model%link_flags//" "//string_cat(target%link_objects," ")                  if (allocated(target%link_libraries)) then                     if (size(target%link_libraries) > 0) then                         target%link_flags = model%compiler%enumerate_libraries(target%link_flags, target%link_libraries)                         local_link_flags = model%compiler%enumerate_libraries(local_link_flags, target%link_libraries)                     end if                 end if                  target%link_flags = target%link_flags//" "//global_link_flags                  target%output_dir = get_output_dir(model%build_prefix, &                    & target%compile_flags//local_link_flags)                 target%output_file = join_path(target%output_dir, target%output_name)                 target%output_log_file = join_path(target%output_dir, target%output_name)//'.log'         end if          end associate      end do  contains                                         recursive subroutine get_link_objects(link_objects,target,is_exe)         type(string_t), intent(inout), allocatable :: link_objects(:)         type(build_target_t), intent(in) :: target         logical, intent(in) :: is_exe          integer :: i         type(string_t) :: temp_str          if (.not.allocated(target%dependencies)) return          do i=1,size(target%dependencies)              associate(dep => target%dependencies(i)%ptr)                  if (.not.allocated(dep%source)) cycle                                                    if (is_exe.and.(dep%source%unit_scope == FPM_SCOPE_LIB)) cycle                                   if (dep%output_file .in. link_objects) cycle                                   temp_str%s = dep%output_file                 link_objects = [link_objects, temp_str]                                                    if (is_exe) call get_link_objects(link_objects,dep,is_exe=.true.)              end associate          end do      end subroutine get_link_objects  end subroutine resolve_target_linking   subroutine add_include_build_dirs(model, targets)     type(fpm_model_t), intent(in) :: model     type(build_target_ptr), intent(inout), target :: targets(:)      integer :: i     type(string_t), allocatable :: build_dirs(:)     type(string_t) :: temp      allocate(build_dirs(0))     do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (target%target_type /= FPM_TARGET_OBJECT) cycle             if (target%output_dir .in. build_dirs) cycle             temp%s = target%output_dir             build_dirs = [build_dirs, temp]         end associate     end do      do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (target%target_type /= FPM_TARGET_OBJECT) cycle              target%compile_flags = target%compile_flags // &                 " " // model%compiler%get_module_flag(target%output_dir) // &                 " -I" // string_cat(build_dirs, " -I")         end associate     end do  end subroutine add_include_build_dirs   function get_output_dir(build_prefix, args) result(path)     character(len=*), intent(in) :: build_prefix     character(len=*), intent(in) :: args     character(len=:), allocatable :: path      character(len=16) :: build_hash      write(build_hash, '(z16.16)') fnv_1a(args)     path = build_prefix//"_"//build_hash end function get_output_dir   subroutine filter_library_targets(targets, list)     type(build_target_ptr), intent(in) :: targets(:)     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, n      n = 0     call resize(list)     do i = 1, size(targets)         if (targets(i)%ptr%target_type == FPM_TARGET_ARCHIVE) then             if (n >= size(list)) call resize(list)             n = n + 1             list(n)%s = targets(i)%ptr%output_file         end if     end do     call resize(list, n) end subroutine filter_library_targets  subroutine filter_executable_targets(targets, scope, list)     type(build_target_ptr), intent(in) :: targets(:)     integer, intent(in) :: scope     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, n      n = 0     call resize(list)     do i = 1, size(targets)         if (is_executable_target(targets(i)%ptr, scope)) then             if (n >= size(list)) call resize(list)             n = n + 1             list(n)%s = targets(i)%ptr%output_file         end if     end do     call resize(list, n) end subroutine filter_executable_targets   elemental function is_executable_target(target_ptr, scope) result(is_exe)     type(build_target_t), intent(in) :: target_ptr     integer, intent(in) :: scope     logical :: is_exe     is_exe = target_ptr%target_type == FPM_TARGET_EXECUTABLE .and. &         allocated(target_ptr%dependencies)     if (is_exe) then         is_exe = target_ptr%dependencies(1)%ptr%source%unit_scope == scope     end if end function is_executable_target   subroutine filter_modules(targets, list)     type(build_target_ptr), intent(in) :: targets(:)     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, j, n      n = 0     call resize(list)     do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (.not.allocated(target%source)) cycle             if (target%source%unit_type == FPM_UNIT_SUBMODULE) cycle             if (n + size(target%source%modules_provided) >= size(list)) call resize(list)             do j = 1, size(target%source%modules_provided)                 n = n + 1                 list(n)%s = join_path(target%output_dir, &                     target%source%modules_provided(j)%s)             end do         end associate     end do     call resize(list, n) end subroutine filter_modules   function get_feature_flags(compiler, features) result(flags)     type(compiler_t), intent(in) :: compiler     type(fortran_features_t), intent(in) :: features     character(:), allocatable :: flags      flags = ""     if (features%implicit_typing) then         flags = flags // compiler%get_feature_flag("implicit-typing")     else         flags = flags // compiler%get_feature_flag("no-implicit-typing")     end if      if (features%implicit_external) then         flags = flags // compiler%get_feature_flag("implicit-external")     else         flags = flags // compiler%get_feature_flag("no-implicit-external")     end if      if (allocated(features%source_form)) then         flags = flags // compiler%get_feature_flag(features%source_form//"-form")     end if end function get_feature_flags   end module fpm_targets 
fpm_targets.f90_comments !># Build target handling !> !> This module handles the construction of the build target list !> from the sources list (`[[targets_from_sources]]`), the !> resolution of module-dependencies between build targets !> (`[[resolve_module_dependencies]]`), and the enumeration of !> objects required for link targets (`[[resolve_target_linking]]`). !> !> A build target (`[[build_target_t]]`) is a file to be generated !> by the backend (compilation and linking). !> !> @note The current implementation is ignorant to the existence of !> module files (`.mod`,`.smod`). Dependencies arising from modules !> are based on the corresponding object files (`.o`) only. !> !> For more information, please read the documentation for the procedures: !> !> - `[[build_target_list]]` !> - `[[resolve_module_dependencies]]` !> !>### Enumerations !> !> __Target type:__ `FPM_TARGET_*` !> Describes the type of build target  determines backend build rules !> module fpm_targets use iso_fortran_env, only: int64 use fpm_error, only: error_t, fatal_error, fpm_stop use fpm_model use fpm_compiler, only : compiler_t use fpm_environment, only: get_os_type, OS_WINDOWS, OS_MACOS use fpm_filesystem, only: dirname, join_path, canon_path use fpm_strings, only: string_t, operator(.in.), string_cat, fnv_1a, resize, lower, str_ends_with use fpm_compiler, only: get_macros use fpm_sources, only: get_exe_name_with_suffix use fpm_manifest_preprocess, only: preprocess_config_t implicit none  private  public FPM_TARGET_UNKNOWN, FPM_TARGET_EXECUTABLE, &        FPM_TARGET_ARCHIVE, FPM_TARGET_OBJECT, &        FPM_TARGET_C_OBJECT, FPM_TARGET_CPP_OBJECT public build_target_t, build_target_ptr public targets_from_sources, resolve_module_dependencies public add_target, add_dependency public filter_library_targets, filter_executable_targets, filter_modules    !> Target type is unknown (ignored) integer, parameter :: FPM_TARGET_UNKNOWN = -1 !> Target type is executable integer, parameter :: FPM_TARGET_EXECUTABLE = 1 !> Target type is library archive integer, parameter :: FPM_TARGET_ARCHIVE = 2 !> Target type is compiled object integer, parameter :: FPM_TARGET_OBJECT = 3 !> Target type is c compiled object integer, parameter :: FPM_TARGET_C_OBJECT = 4 !> Target type is cpp compiled object integer, parameter :: FPM_TARGET_CPP_OBJECT = 5  !> Wrapper type for constructing arrays of `[[build_target_t]]` pointers type build_target_ptr      type(build_target_t), pointer :: ptr => null()  end type build_target_ptr   !> Type describing a generated build target type build_target_t      !> File path of build target object relative to cwd     character(:), allocatable :: output_file      !> File path of build target object relative to output_dir     character(:), allocatable :: output_name      !> File path of output directory     character(:), allocatable :: output_dir      !> File path of build log file relative to cwd     character(:), allocatable :: output_log_file      !> Name of parent package     character(:), allocatable :: package_name      !> Primary source for this build target     type(srcfile_t), allocatable :: source      !> Resolved build dependencies     type(build_target_ptr), allocatable :: dependencies(:)      !> Target type     integer :: target_type = FPM_TARGET_UNKNOWN      !> Native libraries to link against     type(string_t), allocatable :: link_libraries(:)      !> Objects needed to link this target     type(string_t), allocatable :: link_objects(:)      !> Link flags for this build target     character(:), allocatable :: link_flags      !> Compile flags for this build target     character(:), allocatable :: compile_flags      !> Flag set when first visited to check for circular dependencies     logical :: touched = .false.      !> Flag set if build target is sorted for building     logical :: sorted = .false.      !> Flag set if build target will be skipped (not built)     logical :: skip = .false.      !> Language features     type(fortran_features_t) :: features      !> Targets in the same schedule group are guaranteed to be independent     integer :: schedule = -1      !> Previous source file hash     integer(int64), allocatable :: digest_cached      !> List of macros     type(string_t), allocatable :: macros(:)      !> Version number     character(:), allocatable :: version  end type build_target_t   contains  !> High-level wrapper to generate build target information subroutine targets_from_sources(targets,model,prune,error)      !> The generated list of build targets     type(build_target_ptr), intent(out), allocatable :: targets(:)      !> The package model from which to construct the target list     type(fpm_model_t), intent(inout), target :: model      !> Enable tree-shaking/pruning of module dependencies     logical, intent(in) :: prune      !> Error structure     type(error_t), intent(out), allocatable :: error      call build_target_list(targets,model)      call collect_exe_link_dependencies(targets)      call resolve_module_dependencies(targets,model%external_modules,error)     if (allocated(error)) return      if (prune) then         call prune_build_targets(targets,root_package=model%package_name)     end if      call resolve_target_linking(targets,model)  end subroutine targets_from_sources   !> Constructs a list of build targets from a list of source files !> !>### Source-target mapping !> !> One compiled object target (`FPM_TARGET_OBJECT`) is generated for each !> non-executable source file (`FPM_UNIT_MODULE`,`FPM_UNIT_SUBMODULE`, !>  `FPM_UNIT_SUBPROGRAM`,`FPM_UNIT_CSOURCE`). !> !> If any source file has scope `FPM_SCOPE_LIB` (*i.e.* there are library sources) !> then the first target in the target list will be a library archive target !> (`FPM_TARGET_ARCHIVE`). The archive target will have a dependency on every !> compiled object target corresponding to a library source file. !> !> One compiled object target (`FPM_TARGET_OBJECT`) and one executable target (`FPM_TARGET_EXECUTABLE`) is !> generated for each exectuable source file (`FPM_UNIT_PROGRAM`). The exectuble target !> always has a dependency on the corresponding compiled object target. If there !> is a library, then the executable target has an additional dependency on the library !> archive target. !> subroutine build_target_list(targets,model)      !> The generated list of build targets     type(build_target_ptr), intent(out), allocatable :: targets(:)      !> The package model from which to construct the target list     type(fpm_model_t), intent(inout), target :: model      integer :: i, j, n_source, exe_type     character(:), allocatable :: exe_dir, compile_flags     logical :: with_lib      ! Initialize targets     allocate(targets(0))      ! Check for empty build (e.g. header-only lib)     n_source = sum([(size(model%packages(j)%sources), &                       j=1,size(model%packages))])      if (n_source < 1) return      with_lib = any([((model%packages(j)%sources(i)%unit_scope == FPM_SCOPE_LIB, &                       i=1,size(model%packages(j)%sources)), &                       j=1,size(model%packages))])      if (with_lib) call add_target(targets,package=model%package_name,type = FPM_TARGET_ARCHIVE,&                             output_name = join_path(&                                    model%package_name,'lib'//model%package_name//'.a'))      do j=1,size(model%packages)          associate(sources=>model%packages(j)%sources)              do i=1,size(sources)                  if (.not. model%include_tests) then                     if (sources(i)%unit_scope == FPM_SCOPE_TEST) cycle                 end if                  select case (sources(i)%unit_type)                 case (FPM_UNIT_MODULE,FPM_UNIT_SUBMODULE,FPM_UNIT_SUBPROGRAM,FPM_UNIT_CSOURCE)                      call add_target(targets,package=model%packages(j)%name,source = sources(i), &                                 type = merge(FPM_TARGET_C_OBJECT,FPM_TARGET_OBJECT,&                                                sources(i)%unit_type==FPM_UNIT_CSOURCE), &                                 output_name = get_object_name(sources(i)), &                                 features = model%packages(j)%features, &                                 preprocess = model%packages(j)%preprocess, &                                 version = model%packages(j)%version)                       if (with_lib .and. sources(i)%unit_scope == FPM_SCOPE_LIB) then                         ! Archive depends on object                         call add_dependency(targets(1)%ptr, targets(size(targets))%ptr)                     end if                  case (FPM_UNIT_CPPSOURCE)                      call add_target(targets,package=model%packages(j)%name,source = sources(i), &                                 type = FPM_TARGET_CPP_OBJECT, &                                 output_name = get_object_name(sources(i)), &                                 preprocess = model%packages(j)%preprocess, &                                 version = model%packages(j)%version)                      if (with_lib .and. sources(i)%unit_scope == FPM_SCOPE_LIB) then                         ! Archive depends on object                         call add_dependency(targets(1)%ptr, targets(size(targets))%ptr)                     end if                      !> Add stdc++ as a linker flag. If not already there.                     if (.not. ("stdc++" .in. model%link_libraries)) then                          if (get_os_type() == OS_MACOS) then                             model%link_libraries = [model%link_libraries, string_t("c++")]                         else                             model%link_libraries = [model%link_libraries, string_t("stdc++")]                         end if                      end if                  case (FPM_UNIT_PROGRAM)                      if (str_ends_with(lower(sources(i)%file_name), [".c"])) then                         exe_type = FPM_TARGET_C_OBJECT                     else if (str_ends_with(lower(sources(i)%file_name), [".cpp", ".cc "])) then                         exe_type = FPM_TARGET_CPP_OBJECT                     else    ! Default to a Fortran object                         exe_type = FPM_TARGET_OBJECT                     end if                      call add_target(targets,package=model%packages(j)%name,type = exe_type,&                                 output_name = get_object_name(sources(i)), &                                 source = sources(i), &                                 features = model%packages(j)%features, &                                 preprocess = model%packages(j)%preprocess &                                 )                      if (sources(i)%unit_scope == FPM_SCOPE_APP) then                          exe_dir = 'app'                      else if (sources(i)%unit_scope == FPM_SCOPE_EXAMPLE) then                          exe_dir = 'example'                      else                          exe_dir = 'test'                      end if                      call add_target(targets,package=model%packages(j)%name,type = FPM_TARGET_EXECUTABLE,&                                     link_libraries = sources(i)%link_libraries, &                                     output_name = join_path(exe_dir,get_exe_name_with_suffix(sources(i))))                      associate(target => targets(size(targets))%ptr)                      ! Linker-only flags are necessary on some compilers for codes with non-Fortran main                     select case (exe_type)                        case (FPM_TARGET_C_OBJECT)                             call model%compiler%get_main_flags("c",compile_flags)                        case (FPM_TARGET_CPP_OBJECT)                             call model%compiler%get_main_flags("c++",compile_flags)                        case default                             compile_flags = ""                     end select                     target%compile_flags = target%compile_flags//' '//compile_flags                      ! Executable depends on object                     call add_dependency(target, targets(size(targets)-1)%ptr)                      if (with_lib) then                         ! Executable depends on library                         call add_dependency(target, targets(1)%ptr)                     end if                      endassociate                  end select              end do          end associate      end do      contains      function get_object_name(source) result(object_file)         ! Generate object target path from source name and model params         !         !         type(srcfile_t), intent(in) :: source         character(:), allocatable :: object_file          integer :: i         character(1), parameter :: filesep = '/'          object_file = canon_path(source%file_name)          ! Convert any remaining directory separators to underscores         i = index(object_file,filesep)         do while(i > 0)             object_file(i:i) = '_'             i = index(object_file,filesep)         end do          object_file = join_path(model%package_name,object_file)//'.o'      end function get_object_name  end subroutine build_target_list   !> Add non-library non-module dependencies for executable targets !> !>  Executable targets will link to any non-program non-module source files that !>   are in the same directory or in a subdirectory. !> !>  (Note: Fortran module dependencies are handled separately in !>    `resolve_module_dependencies` and `resolve_target_linking`.) !> subroutine collect_exe_link_dependencies(targets)     type(build_target_ptr), intent(inout) :: targets(:)      integer :: i, j     character(:), allocatable :: exe_source_dir      ! Add non-module dependencies for executables     do j=1,size(targets)          if (targets(j)%ptr%target_type == FPM_TARGET_EXECUTABLE) then              do i=1,size(targets)                  if (i == j) cycle                  associate(exe => targets(j)%ptr, dep => targets(i)%ptr)                      exe_source_dir = dirname(exe%dependencies(1)%ptr%source%file_name)                      if (allocated(dep%source)) then                          if (dep%source%unit_scope /= FPM_SCOPE_LIB .and. &                             dep%source%unit_type /= FPM_UNIT_PROGRAM .and. &                             dep%source%unit_type /= FPM_UNIT_MODULE .and. &                             index(dirname(dep%source%file_name), exe_source_dir) == 1) then                              call add_dependency(exe, dep)                          end if                      end if                  end associate              end do          end if      end do  end subroutine collect_exe_link_dependencies   !> Allocate a new target and append to target list subroutine add_target(targets, package, type, output_name, source, link_libraries, &         & features, preprocess, version)     type(build_target_ptr), allocatable, intent(inout) :: targets(:)     character(*), intent(in) :: package     integer, intent(in) :: type     character(*), intent(in) :: output_name     type(srcfile_t), intent(in), optional :: source     type(string_t), intent(in), optional :: link_libraries(:)     type(fortran_features_t), intent(in), optional :: features     type(preprocess_config_t), intent(in), optional :: preprocess     character(*), intent(in), optional :: version      integer :: i     type(build_target_t), pointer :: new_target      if (.not.allocated(targets)) allocate(targets(0))      ! Check for duplicate outputs     do i=1,size(targets)          if (targets(i)%ptr%output_name == output_name) then              write(*,*) 'Error while building target list: duplicate output object "',&                         output_name,'"'             if (present(source)) write(*,*) ' Source file: "',source%file_name,'"'             call fpm_stop(1,' ')          end if      end do      allocate(new_target)     new_target%target_type = type     new_target%output_name = output_name     new_target%package_name = package     if (present(source)) new_target%source = source     if (present(link_libraries)) new_target%link_libraries = link_libraries     if (present(features)) new_target%features = features     if (present(preprocess)) then         if (allocated(preprocess%macros)) new_target%macros = preprocess%macros     endif     if (present(version)) new_target%version = version     allocate(new_target%dependencies(0))      targets = [targets, build_target_ptr(new_target)]  end subroutine add_target   !> Add pointer to dependeny in target%dependencies subroutine add_dependency(target, dependency)     type(build_target_t), intent(inout) :: target     type(build_target_t) , intent(in), target :: dependency      target%dependencies = [target%dependencies, build_target_ptr(dependency)]  end subroutine add_dependency   !> Add dependencies to source-based targets (`FPM_TARGET_OBJECT`) !> based on any modules used by the corresponding source file. !> !>### Source file scoping !> !> Source files are assigned a scope of either `FPM_SCOPE_LIB`, !> `FPM_SCOPE_APP` or `FPM_SCOPE_TEST`. The scope controls which !> modules may be used by the source file: !> !> - Library sources (`FPM_SCOPE_LIB`) may only use modules !>   also with library scope. This includes library modules !>   from dependencies. !> !> - Executable sources (`FPM_SCOPE_APP`,`FPM_SCOPE_TEST`) may use !>   library modules (including dependencies) as well as any modules !>   corresponding to source files in the same directory or a !>   subdirectory of the executable source file. !> !> @warning If a module used by a source file cannot be resolved to !> a source file in the package of the correct scope, then a __fatal error__ !> is returned by the procedure and model construction fails. !> subroutine resolve_module_dependencies(targets,external_modules,error)     type(build_target_ptr), intent(inout), target :: targets(:)     type(string_t), intent(in) :: external_modules(:)     type(error_t), allocatable, intent(out) :: error      type(build_target_ptr) :: dep      integer :: i, j      do i=1,size(targets)          if (.not.allocated(targets(i)%ptr%source)) cycle              do j=1,size(targets(i)%ptr%source%modules_used)                  if (targets(i)%ptr%source%modules_used(j)%s .in. targets(i)%ptr%source%modules_provided) then                     ! Dependency satisfied in same file, skip                     cycle                 end if                  if (targets(i)%ptr%source%modules_used(j)%s .in. external_modules) then                     ! Dependency satisfied in system-installed module                     cycle                 end if                  if (any(targets(i)%ptr%source%unit_scope == &                     [FPM_SCOPE_APP, FPM_SCOPE_EXAMPLE, FPM_SCOPE_TEST])) then                     dep%ptr => &                         find_module_dependency(targets,targets(i)%ptr%source%modules_used(j)%s, &                                             include_dir = dirname(targets(i)%ptr%source%file_name))                 else                     dep%ptr => &                         find_module_dependency(targets,targets(i)%ptr%source%modules_used(j)%s)                 end if                  if (.not.associated(dep%ptr)) then                     call fatal_error(error, &                             'Unable to find source for module dependency: "' // &                             targets(i)%ptr%source%modules_used(j)%s // &                             '" used by "'//targets(i)%ptr%source%file_name//'"')                     return                 end if                  call add_dependency(targets(i)%ptr, dep%ptr)              end do      end do  end subroutine resolve_module_dependencies  function find_module_dependency(targets,module_name,include_dir) result(target_ptr)     ! Find a module dependency in the library or a dependency library     !     ! 'include_dir' specifies an allowable non-library search directory     !   (Used for executable dependencies)     !     type(build_target_ptr), intent(in), target :: targets(:)     character(*), intent(in) :: module_name     character(*), intent(in), optional :: include_dir     type(build_target_t), pointer :: target_ptr      integer :: k, l      target_ptr => NULL()      do k=1,size(targets)          if (.not.allocated(targets(k)%ptr%source)) cycle          do l=1,size(targets(k)%ptr%source%modules_provided)              if (module_name == targets(k)%ptr%source%modules_provided(l)%s) then                 select case(targets(k)%ptr%source%unit_scope)                 case (FPM_SCOPE_LIB, FPM_SCOPE_DEP)                     target_ptr => targets(k)%ptr                     exit                 case default                     if (present(include_dir)) then                         if (index(dirname(targets(k)%ptr%source%file_name), include_dir) == 1) then ! source file is within the include_dir or a subdirectory                             target_ptr => targets(k)%ptr                             exit                         end if                     end if                 end select             end if          end do      end do  end function find_module_dependency   !> Perform tree-shaking to remove unused module targets subroutine prune_build_targets(targets, root_package)      !> Build target list to prune     type(build_target_ptr), intent(inout), allocatable :: targets(:)      !> Name of root package     character(*), intent(in) :: root_package      integer :: i, j, nexec     type(string_t), allocatable :: modules_used(:)     logical :: exclude_target(size(targets))     logical, allocatable :: exclude_from_archive(:)      if (size(targets) < 1) then         return     end if      nexec = 0     allocate(modules_used(0))      ! Enumerate modules used by executables, non-module subprograms and their dependencies     do i=1,size(targets)          if (targets(i)%ptr%target_type == FPM_TARGET_EXECUTABLE) then              nexec = nexec + 1             call collect_used_modules(targets(i)%ptr)          elseif (allocated(targets(i)%ptr%source)) then              if (targets(i)%ptr%source%unit_type == FPM_UNIT_SUBPROGRAM) then                  call collect_used_modules(targets(i)%ptr)              end if          end if      end do      ! If there aren't any executables, then prune     !  based on modules used in root package     if (nexec < 1) then          do i=1,size(targets)              if (targets(i)%ptr%package_name == root_package .and. &                  targets(i)%ptr%target_type /= FPM_TARGET_ARCHIVE) then                  call collect_used_modules(targets(i)%ptr)              end if          end do      end if      call reset_target_flags(targets)      exclude_target(:) = .false.      ! Exclude purely module targets if they are not used anywhere     do i=1,size(targets)         associate(target=>targets(i)%ptr)              if (allocated(target%source)) then                 if (target%source%unit_type == FPM_UNIT_MODULE) then                      exclude_target(i) = .true.                     target%skip = .true.                      do j=1,size(target%source%modules_provided)                          if (target%source%modules_provided(j)%s .in. modules_used) then                              exclude_target(i) = .false.                             target%skip = .false.                          end if                      end do                  elseif (target%source%unit_type == FPM_UNIT_SUBMODULE) then                     ! Remove submodules if their parents are not used                      exclude_target(i) = .true.                     target%skip = .true.                     do j=1,size(target%source%parent_modules)                          if (target%source%parent_modules(j)%s .in. modules_used) then                              exclude_target(i) = .false.                             target%skip = .false.                          end if                      end do                  end if             end if              ! (If there aren't any executables then we only prune modules from dependencies)             if (nexec < 1 .and. target%package_name == root_package) then                 exclude_target(i) = .false.                 target%skip = .false.             end if          end associate     end do      targets = pack(targets,.not.exclude_target)      ! Remove unused targets from archive dependency list     if (targets(1)%ptr%target_type == FPM_TARGET_ARCHIVE) then         associate(archive=>targets(1)%ptr)              allocate(exclude_from_archive(size(archive%dependencies)))             exclude_from_archive(:) = .false.              do i=1,size(archive%dependencies)                  if (archive%dependencies(i)%ptr%skip) then                      exclude_from_archive(i) = .true.                  end if              end do              archive%dependencies = pack(archive%dependencies,.not.exclude_from_archive)          end associate     end if      contains      !> Recursively collect which modules are actually used     recursive subroutine collect_used_modules(target)         type(build_target_t), intent(inout) :: target          integer :: j, k          if (target%touched) then             return         else             target%touched = .true.         end if          if (allocated(target%source)) then              ! Add modules from this target and from any of it's children submodules             do j=1,size(target%source%modules_provided)                  if (.not.(target%source%modules_provided(j)%s .in. modules_used)) then                      modules_used = [modules_used, target%source%modules_provided(j)]                  end if                  ! Recurse into child submodules                 do k=1,size(targets)                     if (allocated(targets(k)%ptr%source)) then                         if (targets(k)%ptr%source%unit_type == FPM_UNIT_SUBMODULE) then                             if (target%source%modules_provided(j)%s .in. targets(k)%ptr%source%parent_modules) then                                 call collect_used_modules(targets(k)%ptr)                             end if                         end if                     end if                 end do              end do         end if          ! Recurse into dependencies         do j=1,size(target%dependencies)              if (target%dependencies(j)%ptr%target_type /= FPM_TARGET_ARCHIVE) then                 call collect_used_modules(target%dependencies(j)%ptr)             end if          end do      end subroutine collect_used_modules      !> Reset target flags after recursive search     subroutine reset_target_flags(targets)         type(build_target_ptr), intent(inout) :: targets(:)          integer :: i          do i=1,size(targets)              targets(i)%ptr%touched = .false.          end do      end subroutine reset_target_flags  end subroutine prune_build_targets   !> Construct the linker flags string for each target !>  `target%link_flags` includes non-library objects and library flags !> subroutine resolve_target_linking(targets, model)     type(build_target_ptr), intent(inout), target :: targets(:)     type(fpm_model_t), intent(in) :: model      integer :: i     character(:), allocatable :: global_link_flags, local_link_flags     character(:), allocatable :: global_include_flags      if (size(targets) == 0) return      global_link_flags = ""     if (allocated(model%link_libraries)) then         if (size(model%link_libraries) > 0) then             global_link_flags = model%compiler%enumerate_libraries(global_link_flags, model%link_libraries)         end if     end if      allocate(character(0) :: global_include_flags)     if (allocated(model%include_dirs)) then         if (size(model%include_dirs) > 0) then             global_include_flags = global_include_flags // &             & " -I" // string_cat(model%include_dirs," -I")         end if     end if      do i=1,size(targets)          associate(target => targets(i)%ptr)              ! If the main program is a C/C++ one, some compilers require additional linking flags, see             ! https://stackoverflow.com/questions/36221612/p3dfft-compilation-ifort-compiler-error-multiple-definiton-of-main             ! In this case, compile_flags were already allocated             if (.not.allocated(target%compile_flags)) allocate(character(len=0) :: target%compile_flags)              target%compile_flags = target%compile_flags//' '              select case (target%target_type)                case (FPM_TARGET_C_OBJECT)                    target%compile_flags = target%compile_flags//model%c_compile_flags                case (FPM_TARGET_CPP_OBJECT)                    target%compile_flags = target%compile_flags//model%cxx_compile_flags                case default                    target%compile_flags = target%compile_flags//model%fortran_compile_flags &                                         & // get_feature_flags(model%compiler, target%features)             end select              !> Get macros as flags.             target%compile_flags = target%compile_flags // get_macros(model%compiler%id, &                                                             target%macros, &                                                             target%version)              if (len(global_include_flags) > 0) then                 target%compile_flags = target%compile_flags//global_include_flags             end if             target%output_dir = get_output_dir(model%build_prefix, target%compile_flags)             target%output_file = join_path(target%output_dir, target%output_name)             target%output_log_file = join_path(target%output_dir, target%output_name)//'.log'         end associate      end do      call add_include_build_dirs(model, targets)      do i=1,size(targets)          associate(target => targets(i)%ptr)             allocate(target%link_objects(0))              if (target%target_type == FPM_TARGET_ARCHIVE) then                 global_link_flags = target%output_file // global_link_flags                  call get_link_objects(target%link_objects,target,is_exe=.false.)                  allocate(character(0) :: target%link_flags)              else if (target%target_type == FPM_TARGET_EXECUTABLE) then                  call get_link_objects(target%link_objects,target,is_exe=.true.)                  local_link_flags = ""                 if (allocated(model%link_flags)) local_link_flags = model%link_flags                 target%link_flags = model%link_flags//" "//string_cat(target%link_objects," ")                  if (allocated(target%link_libraries)) then                     if (size(target%link_libraries) > 0) then                         target%link_flags = model%compiler%enumerate_libraries(target%link_flags, target%link_libraries)                         local_link_flags = model%compiler%enumerate_libraries(local_link_flags, target%link_libraries)                     end if                 end if                  target%link_flags = target%link_flags//" "//global_link_flags                  target%output_dir = get_output_dir(model%build_prefix, &                    & target%compile_flags//local_link_flags)                 target%output_file = join_path(target%output_dir, target%output_name)                 target%output_log_file = join_path(target%output_dir, target%output_name)//'.log'         end if          end associate      end do  contains      !> Wrapper to build link object list     !>     !>  For libraries: just list dependency objects of lib target     !>     !>  For executables: need to recursively discover non-library     !>   dependency objects. (i.e. modules in same dir as program)     !>     recursive subroutine get_link_objects(link_objects,target,is_exe)         type(string_t), intent(inout), allocatable :: link_objects(:)         type(build_target_t), intent(in) :: target         logical, intent(in) :: is_exe          integer :: i         type(string_t) :: temp_str          if (.not.allocated(target%dependencies)) return          do i=1,size(target%dependencies)              associate(dep => target%dependencies(i)%ptr)                  if (.not.allocated(dep%source)) cycle                  ! Skip library dependencies for executable targets                 !  since the library archive will always be linked                 if (is_exe.and.(dep%source%unit_scope == FPM_SCOPE_LIB)) cycle                  ! Skip if dependency object already listed                 if (dep%output_file .in. link_objects) cycle                  ! Add dependency object file to link object list                 temp_str%s = dep%output_file                 link_objects = [link_objects, temp_str]                  ! For executable objects, also need to include non-library                 !  dependencies from dependencies (recurse)                 if (is_exe) call get_link_objects(link_objects,dep,is_exe=.true.)              end associate          end do      end subroutine get_link_objects  end subroutine resolve_target_linking   subroutine add_include_build_dirs(model, targets)     type(fpm_model_t), intent(in) :: model     type(build_target_ptr), intent(inout), target :: targets(:)      integer :: i     type(string_t), allocatable :: build_dirs(:)     type(string_t) :: temp      allocate(build_dirs(0))     do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (target%target_type /= FPM_TARGET_OBJECT) cycle             if (target%output_dir .in. build_dirs) cycle             temp%s = target%output_dir             build_dirs = [build_dirs, temp]         end associate     end do      do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (target%target_type /= FPM_TARGET_OBJECT) cycle              target%compile_flags = target%compile_flags // &                 " " // model%compiler%get_module_flag(target%output_dir) // &                 " -I" // string_cat(build_dirs, " -I")         end associate     end do  end subroutine add_include_build_dirs   function get_output_dir(build_prefix, args) result(path)     character(len=*), intent(in) :: build_prefix     character(len=*), intent(in) :: args     character(len=:), allocatable :: path      character(len=16) :: build_hash      write(build_hash, '(z16.16)') fnv_1a(args)     path = build_prefix//"_"//build_hash end function get_output_dir   subroutine filter_library_targets(targets, list)     type(build_target_ptr), intent(in) :: targets(:)     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, n      n = 0     call resize(list)     do i = 1, size(targets)         if (targets(i)%ptr%target_type == FPM_TARGET_ARCHIVE) then             if (n >= size(list)) call resize(list)             n = n + 1             list(n)%s = targets(i)%ptr%output_file         end if     end do     call resize(list, n) end subroutine filter_library_targets  subroutine filter_executable_targets(targets, scope, list)     type(build_target_ptr), intent(in) :: targets(:)     integer, intent(in) :: scope     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, n      n = 0     call resize(list)     do i = 1, size(targets)         if (is_executable_target(targets(i)%ptr, scope)) then             if (n >= size(list)) call resize(list)             n = n + 1             list(n)%s = targets(i)%ptr%output_file         end if     end do     call resize(list, n) end subroutine filter_executable_targets   elemental function is_executable_target(target_ptr, scope) result(is_exe)     type(build_target_t), intent(in) :: target_ptr     integer, intent(in) :: scope     logical :: is_exe     is_exe = target_ptr%target_type == FPM_TARGET_EXECUTABLE .and. &         allocated(target_ptr%dependencies)     if (is_exe) then         is_exe = target_ptr%dependencies(1)%ptr%source%unit_scope == scope     end if end function is_executable_target   subroutine filter_modules(targets, list)     type(build_target_ptr), intent(in) :: targets(:)     type(string_t), allocatable, intent(out) :: list(:)      integer :: i, j, n      n = 0     call resize(list)     do i = 1, size(targets)         associate(target => targets(i)%ptr)             if (.not.allocated(target%source)) cycle             if (target%source%unit_type == FPM_UNIT_SUBMODULE) cycle             if (n + size(target%source%modules_provided) >= size(list)) call resize(list)             do j = 1, size(target%source%modules_provided)                 n = n + 1                 list(n)%s = join_path(target%output_dir, &                     target%source%modules_provided(j)%s)             end do         end associate     end do     call resize(list, n) end subroutine filter_modules   function get_feature_flags(compiler, features) result(flags)     type(compiler_t), intent(in) :: compiler     type(fortran_features_t), intent(in) :: features     character(:), allocatable :: flags      flags = ""     if (features%implicit_typing) then         flags = flags // compiler%get_feature_flag("implicit-typing")     else         flags = flags // compiler%get_feature_flag("no-implicit-typing")     end if      if (features%implicit_external) then         flags = flags // compiler%get_feature_flag("implicit-external")     else         flags = flags // compiler%get_feature_flag("no-implicit-external")     end if      if (allocated(features%source_form)) then         flags = flags // compiler%get_feature_flag(features%source_form//"-form")     end if end function get_feature_flags   end module fpm_targets 
