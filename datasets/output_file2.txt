amos.f90_stripped module amos   implicit none                                                    interface             pure subroutine zbesj(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesj             pure subroutine zbesy(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, workr, worki, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: workr(length), worki(length), &             zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesy             pure subroutine zbesi(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesi             pure subroutine zbesk(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesk             pure subroutine zbesh(re, im, order, scaling, hankelkind, length, zOut_r, &           zOut_i, underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, hankelkind, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesh             pure subroutine zairy(re, im, deriv, scaling, zOut_r, zOut_i, underflow, ierr)        implicit none        double precision, intent(in) :: re, im        integer, intent(in) :: deriv, scaling        double precision, intent(out) :: zOut_r, zOut_i        integer, intent(out) :: underflow, ierr      end subroutine zairy             pure subroutine zbiry(re, im, deriv, scaling, zOut_r, zOut_i, ierr)        implicit none        double precision, intent(in) :: re, im        integer, intent(in) :: deriv, scaling        double precision, intent(out) :: zOut_r, zOut_i        integer, intent(out) :: ierr      end subroutine zbiry    end interface  end module amos 
amos.f90_comments module amos   implicit none    ! This module contains interfaces for the amos routines (in unmodified form   ! found on http://netlib.org/amos).   ! The slightly modified sources taken from SciPy's "legacy/amos/special"   ! module are linked against.    ! The original code was written by Donald E. Amos at Sandia National Labratories   ! See also "Portable package for Bessel functions of a complex argument and   ! non-negative order" by D. E. Amos in Trans. Math. Software (1986)    ! Note that we made all routines pure routines. We do this to be able to   ! use these routines in OpenMP loops and forall statements. The F77 routines   ! are, of course, not declared as pure. However, they behave as such - the do   ! not have side effects. Also, the intent of every argument is clear.   ! Technically, there is one exception: the ?1mach.f90 routines (used in   ! finding machine constants) each contain a write statement in case the query   ! fails. We ignore this possibility (as we trust the queries made by amos).   ! The author of the wrapper uses this without any problems in production code.    interface       ! Bessel J function:      pure subroutine zbesj(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesj       ! Bessel Y function of second kind:      pure subroutine zbesy(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, workr, worki, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: workr(length), worki(length), &             zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesy       ! modified Bessel I function of first kind:      pure subroutine zbesi(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesi       ! modified Bessel K function of second kind:      pure subroutine zbesk(re, im, order, scaling, length, zOut_r, zOut_i, &           underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesk       ! Hankel H functions:      pure subroutine zbesh(re, im, order, scaling, hankelkind, length, zOut_r, &           zOut_i, underflows, ierr)        implicit none        double precision, intent(in) :: re, im, order        integer, intent(in) :: scaling, hankelkind, length        double precision, intent(out) :: zOut_r(length), zOut_i(length)        integer, intent(out) :: underflows, ierr      end subroutine zbesh       ! Airy function Ai (or its derivative):      pure subroutine zairy(re, im, deriv, scaling, zOut_r, zOut_i, underflow, ierr)        implicit none        double precision, intent(in) :: re, im        integer, intent(in) :: deriv, scaling        double precision, intent(out) :: zOut_r, zOut_i        integer, intent(out) :: underflow, ierr      end subroutine zairy       ! Airy function Bi (or its derivative)      pure subroutine zbiry(re, im, deriv, scaling, zOut_r, zOut_i, ierr)        implicit none        double precision, intent(in) :: re, im        integer, intent(in) :: deriv, scaling        double precision, intent(out) :: zOut_r, zOut_i        integer, intent(out) :: ierr      end subroutine zbiry    end interface  end module amos 
constants.f90_stripped module constants use types, only: dp implicit none private public pi, e_, i_      real(dp), parameter :: pi    = 3.1415926535897932384626433832795_dp real(dp), parameter :: e_    = 2.7182818284590452353602874713527_dp complex(dp), parameter :: i_ = (0, 1)  end module 
constants.f90_comments module constants use types, only: dp implicit none private public pi, e_, i_  ! Constants contain more digits than double precision, so that ! they are rounded correctly. Single letter constants contain underscore so ! that they do not clash with user variables ("e" and "i" are frequently used as ! loop variables) real(dp), parameter :: pi    = 3.1415926535897932384626433832795_dp real(dp), parameter :: e_    = 2.7182818284590452353602874713527_dp complex(dp), parameter :: i_ = (0, 1)  end module 
h5_utils.f90_stripped module h5_utils  use hdf5, only: HID_T, HSIZE_T, H5T_NATIVE_DOUBLE, H5T_NATIVE_INTEGER, &     H5F_ACC_TRUNC_F, h5gcreate_f, h5gclose_f, h5screate_simple_f, &     h5sclose_f, h5dcreate_f, h5dclose_f, h5dwrite_f, h5fcreate_f, &     h5fclose_f, h5close_f, h5open_f use types, only: dp use utils, only: stop_error implicit none private public h5_open, h5_close, h5_write_array, h5_file, h5_create_group  type h5_file     integer(HID_T) :: file_id end type  interface h5_write_array     module procedure h5_write_array_int, h5_write_array_real end interface  integer :: number_of_open_files = 0  contains  subroutine check(error) integer, intent(in) :: error if (error /= 0) call stop_error("Error when calling HDF5.") end subroutine  type(h5_file) function h5_open(filename) character(len=*), intent(in) :: filename integer :: error integer(HID_T) :: file_id if (number_of_open_files == 0) then               call h5open_f(error)     call check(error) end if number_of_open_files = number_of_open_files + 1 call h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error) call check(error) h5_open%file_id = file_id end function  subroutine h5_close(self) type(h5_file), intent(in) :: self integer :: error call h5fclose_f(self%file_id, error) call check(error) number_of_open_files = number_of_open_files - 1 if (number_of_open_files == 0) then          call h5close_f(error)     call check(error) end if end subroutine  subroutine h5_write_array_int(self, a_name, A) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: a_name integer, intent(in) :: A(:)  integer, parameter :: rank = 1 integer(HID_T) :: dset_id, dspace_id integer(HSIZE_T) :: dims(1) integer :: error  dims(1) = size(A)  call h5screate_simple_f(rank, dims, dspace_id, error) call check(error) call h5dcreate_f(self%file_id, a_name, H5T_NATIVE_INTEGER, dspace_id, dset_id, error) call check(error)  call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, A, dims, error) call check(error)  call h5dclose_f(dset_id, error) call check(error) call h5sclose_f(dspace_id, error) call check(error) end subroutine  subroutine h5_write_array_real(self, a_name, A) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: a_name real(dp), intent(in) :: A(:)  integer, parameter :: rank = 1 integer(HID_T) :: dset_id, dspace_id integer(HSIZE_T) :: dims(1) integer :: error  dims(1) = size(A)  call h5screate_simple_f(rank, dims, dspace_id, error) call check(error) call h5dcreate_f(self%file_id, a_name, H5T_NATIVE_DOUBLE, dspace_id, dset_id, error) call check(error)  call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, A, dims, error) call check(error)  call h5dclose_f(dset_id, error) call check(error) call h5sclose_f(dspace_id, error) call check(error) end subroutine  subroutine h5_create_group(self, g_name) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: g_name  integer(HID_T) :: group_id integer :: error  call h5gcreate_f(self%file_id, g_name, group_id, error) call check(error) call h5gclose_f(group_id, error) call check(error) end subroutine  end module 
h5_utils.f90_comments module h5_utils  use hdf5, only: HID_T, HSIZE_T, H5T_NATIVE_DOUBLE, H5T_NATIVE_INTEGER, &     H5F_ACC_TRUNC_F, h5gcreate_f, h5gclose_f, h5screate_simple_f, &     h5sclose_f, h5dcreate_f, h5dclose_f, h5dwrite_f, h5fcreate_f, &     h5fclose_f, h5close_f, h5open_f use types, only: dp use utils, only: stop_error implicit none private public h5_open, h5_close, h5_write_array, h5_file, h5_create_group  type h5_file     integer(HID_T) :: file_id end type  interface h5_write_array     module procedure h5_write_array_int, h5_write_array_real end interface  integer :: number_of_open_files = 0  contains  subroutine check(error) integer, intent(in) :: error if (error /= 0) call stop_error("Error when calling HDF5.") end subroutine  type(h5_file) function h5_open(filename) character(len=*), intent(in) :: filename integer :: error integer(HID_T) :: file_id if (number_of_open_files == 0) then     ! If this is the first call to the HDF5, we need to initialize the     ! interface:     call h5open_f(error)     call check(error) end if number_of_open_files = number_of_open_files + 1 call h5fcreate_f(filename, H5F_ACC_TRUNC_F, file_id, error) call check(error) h5_open%file_id = file_id end function  subroutine h5_close(self) type(h5_file), intent(in) :: self integer :: error call h5fclose_f(self%file_id, error) call check(error) number_of_open_files = number_of_open_files - 1 if (number_of_open_files == 0) then     ! All files are closed, so we can close the HDF5 interface:     call h5close_f(error)     call check(error) end if end subroutine  subroutine h5_write_array_int(self, a_name, A) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: a_name integer, intent(in) :: A(:)  integer, parameter :: rank = 1 integer(HID_T) :: dset_id, dspace_id integer(HSIZE_T) :: dims(1) integer :: error  dims(1) = size(A)  call h5screate_simple_f(rank, dims, dspace_id, error) call check(error) call h5dcreate_f(self%file_id, a_name, H5T_NATIVE_INTEGER, dspace_id, dset_id, error) call check(error)  call h5dwrite_f(dset_id, H5T_NATIVE_INTEGER, A, dims, error) call check(error)  call h5dclose_f(dset_id, error) call check(error) call h5sclose_f(dspace_id, error) call check(error) end subroutine  subroutine h5_write_array_real(self, a_name, A) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: a_name real(dp), intent(in) :: A(:)  integer, parameter :: rank = 1 integer(HID_T) :: dset_id, dspace_id integer(HSIZE_T) :: dims(1) integer :: error  dims(1) = size(A)  call h5screate_simple_f(rank, dims, dspace_id, error) call check(error) call h5dcreate_f(self%file_id, a_name, H5T_NATIVE_DOUBLE, dspace_id, dset_id, error) call check(error)  call h5dwrite_f(dset_id, H5T_NATIVE_DOUBLE, A, dims, error) call check(error)  call h5dclose_f(dset_id, error) call check(error) call h5sclose_f(dspace_id, error) call check(error) end subroutine  subroutine h5_create_group(self, g_name) type(h5_file), intent(in) :: self character(LEN=*), intent(in) :: g_name  integer(HID_T) :: group_id integer :: error  call h5gcreate_f(self%file_id, g_name, group_id, error) call check(error) call h5gclose_f(group_id, error) call check(error) end subroutine  end module 
lapack.f90_stripped module lapack implicit none          integer, parameter :: dp=kind(0.d0)  interface      SUBROUTINE      import :: dp     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE                         EQUED, R,                         IWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * ), IWORK( * )     REAL(dp)           A( LDA, * ), AF( LDAF, * ), B( LDB, * ), BERR( * ), &                             END SUBROUTINE      SUBROUTINE ZGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )          END SUBROUTINE      SUBROUTINE ZGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV, &                        EQUED, R,                         WORK, RWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * )     REAL(dp)           BERR( * ),                              X( LDX, * )     END SUBROUTINE      SUBROUTINE      import :: dp     INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           AB( LDAB, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER            INFO, LDA, LDB, LWORK, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE                         LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK, &                        IWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * ), IWORK( * )     REAL(dp)           A( LDA, * ), AF( LDAF, * ), B( LDB, * ), &                        BERR( * ), FERR( * ), WORK( * ), X( LDX, * )     END SUBROUTINE      SUBROUTINE                         LIWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), W( * ), WORK( * )     END SUBROUTINE      SUBROUTINE                         VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, &                        LWORK, IWORK, IFAIL, INFO )     import :: dp          INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N     REAL(dp)           ABSTOL, VL, VU     INTEGER            IFAIL( * ), IWORK( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), W( * ), WORK( * ), &                        Z( LDZ, * )     END SUBROUTINE      SUBROUTINE                         VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, &                        LWORK, IWORK, IFAIL, INFO )     import :: dp          INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N     REAL(dp)           ABSTOL, VL, VU     INTEGER            IFAIL( * ), IWORK( * )     REAL(dp)           A( LDA, * ), W( * ), WORK( * ), &                        Z( LDZ, * )     END SUBROUTINE      SUBROUTINE                        BETA, VL, LDVL, VR, LDVR, WORK, LWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N     REAL(dp)           A( LDA, * ), ALPHAI( * ), ALPHAR( * ), &                        B( LDB, * ), BETA( * ), VL( LDVL, * ), &                        VR( LDVR, * ), WORK( * )     END SUBROUTINE      SUBROUTINE                         ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO, IHI, &                        LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, WORK, &                        LWORK, IWORK, BWORK, INFO )     import :: dp          INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM, BBNRM     LOGICAL            BWORK( * )     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), ALPHAI( * ), ALPHAR( * ), B( LDB, * ), &                        BETA( * ), LSCALE( * ), RCONDE( * ), RCONDV( * ), &                        RSCALE( * ), VL( LDVL, * ), VR( LDVR, * ), WORK( * )     END SUBROUTINE      SUBROUTINE                        LDVR, WORK, LWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ), WI( * ), &                        WORK( * ), WR( * )     END SUBROUTINE      SUBROUTINE                         VL, LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, &                        RCONDE, RCONDV, WORK, LWORK, IWORK, INFO )     import :: dp          INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), RCONDE( * ), RCONDV( * ), &                        SCALE( * ), VL( LDVL, * ), VR( LDVR, * ), &                        WI( * ), WORK( * ), WR( * )     END SUBROUTINE      SUBROUTINE ZGEEV( JOBVL, JOBVR, N, A, LDA, W, VL, LDVL, VR, LDVR, &                       WORK, LWORK, RWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           RWORK( * )                             WORK( * )     END SUBROUTINE      SUBROUTINE ZGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, W, VL, &                        LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, RCONDE, &                        RCONDV, WORK, LWORK, RWORK, INFO )     import :: dp          INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM     REAL(dp)           RCONDE( * ), RCONDV( * ), RWORK( * ), SCALE( * )                             WORK( * )     END SUBROUTINE      SUBROUTINE                         LWORK, IWORK, LIWORK, INFO )     import :: dp          INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), W( * ), WORK( * )     END SUBROUTINE      REAL(dp) FUNCTION      import :: dp          END FUNCTION      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )          INTEGER            ISPEC, N1, N2, N3, N4     END FUNCTION      SUBROUTINE ZGETRF( M, N, A, LDA, IPIV, INFO )     import :: dp     INTEGER            INFO, LDA, M, N     INTEGER            IPIV( * )          END SUBROUTINE      SUBROUTINE ZGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp          INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )          END SUBROUTINE      SUBROUTINE ZGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )          END SUBROUTINE      SUBROUTINE      import :: dp     INTEGER            INFO, LDA, M, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * )     END SUBROUTINE      SUBROUTINE      import :: dp     INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LWORK, N     REAL(dp)           RWORK( * ), W( * )          END SUBROUTINE      SUBROUTINE ZHEEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK, &                        LRWORK, IWORK, LIWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LIWORK, LRWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           RWORK( * ), W( * )          END SUBROUTINE      SUBROUTINE ZHEGVD( ITYPE,  JOBZ,  UPLO,  N,  A,  LDA,  B, LDB, W, &                        WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &                        INFO )     import :: dp          INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LRWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           RWORK( * ), W( * )          END SUBROUTINE      SUBROUTINE                         WORK, LWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK     REAL(dp)           RCOND     INTEGER            JPVT( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK, &                        WORK, LWORK, RWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK     REAL(dp)           RCOND     INTEGER            JPVT( * )     REAL(dp)           RWORK( * )          END SUBROUTINE      SUBROUTINE                         LDVT, WORK, LWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N     REAL(dp)           A( LDA, * ), S( * ),  U( LDU,  * ), VT( LDVT, * ), &                        WORK( * )     END SUBROUTINE      SUBROUTINE ZGESVD( JOBU, JOBVT,  M,  N,  A,  LDA, S, U, LDU, VT, LDVT, &                        WORK, LWORK, RWORK, INFO )     import :: dp          INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N     REAL(dp)           RWORK( * ), S( * )          END SUBROUTINE      SUBROUTINE                         LIWORK, INFO )     import :: dp          INTEGER            INFO, LDZ, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)                END SUBROUTINE      SUBROUTINE XERBLA( SRNAME, INFO )          INTEGER            INFO     END SUBROUTINE        SUBROUTINE ZCOPY(N,ZX,INCX,ZY,INCY)     import :: dp     INTEGER INCX,INCY,N          END SUBROUTINE      SUBROUTINE      import :: dp     integer :: INCX, INCY, N     real(dp) ::      END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER K,LDA,LDB,LDC,M,N          REAL(dp) A(LDA,*),B(LDB,*),     END SUBROUTINE      real(dp) FUNCTION      import :: dp     integer :: INCX, N     real(dp) :: X(*)     END FUNCTION      SUBROUTINE      import :: dp     real(dp) ::      integer :: INCX, N     END SUBROUTINE      SUBROUTINE      import :: dp     REAL(dp) ALPHA,BETA     INTEGER LDA,LDB,LDC,M,N          REAL(dp) A(LDA,*),B(LDB,*),     END SUBROUTINE      SUBROUTINE      import :: dp     INTEGER  INFO, LDA, LWORK, M, N     REAL(dp) A(LDA, *), TAU(*), WORK(*)     END SUBROUTINE      SUBROUTINE      import :: dp     INTEGER  INFO, K, LDA, LWORK, M, N     REAL(dp) A(LDA,*), TAU(*), WORK(*)     END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER            INFO, LDA, N     REAL(dp)           A( LDA, * )     END SUBROUTINE      SUBROUTINE      import :: dp          INTEGER            INFO, LDA, LDB, N, NRHS     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE  end interface  contains  end module 
lapack.f90_comments module lapack implicit none  ! This is the precision that LAPACK "d" routines were compiled with (typically ! double precision, unless a special compiler option was used while compiling ! LAPACK). This "dp" is only used in lapack.f90 ! The "d" routines data type is defined as "double precision", so ! we make "dp" the same kind as 0.d0 ("double precision"), so ! as long as LAPACK and this file were compiled with the same compiler options, ! it will be consistent. (If for example all double precision is promoted to ! quadruple precision, it will be promoted both in LAPACK and here.) integer, parameter :: dp=kind(0.d0)  interface      SUBROUTINE DGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE DGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV, &                        EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR, WORK, &                        IWORK, INFO )     import :: dp     CHARACTER          EQUED, FACT, TRANS     INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * ), IWORK( * )     REAL(dp)           A( LDA, * ), AF( LDAF, * ), B( LDB, * ), BERR( * ), &                        C( * ), FERR( * ), R( * ), WORK( * ), X( LDX, * )     END SUBROUTINE      SUBROUTINE ZGESV( N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     COMPLEX(dp)        A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE ZGESVX( FACT, TRANS, N, NRHS, A, LDA, AF, LDAF, IPIV, &                        EQUED, R, C, B, LDB, X, LDX, RCOND, FERR, BERR, &                        WORK, RWORK, INFO )     import :: dp     CHARACTER          EQUED, FACT, TRANS     INTEGER            INFO, LDA, LDAF, LDB, LDX, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * )     REAL(dp)           BERR( * ), C( * ), FERR( * ), R( * ), RWORK( * )     COMPLEX(dp)        A( LDA, * ), AF( LDAF, * ), B( LDB, * ), WORK( * ), &                        X( LDX, * )     END SUBROUTINE      SUBROUTINE DGBSV( N, KL, KU, NRHS, AB, LDAB, IPIV, B, LDB, INFO )     import :: dp     INTEGER            INFO, KL, KU, LDAB, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           AB( LDAB, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE DSYSV( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, WORK, LWORK, INFO )     import :: dp     CHARACTER          UPLO     INTEGER            INFO, LDA, LDB, LWORK, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DSYTRS( UPLO, N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp     CHARACTER          UPLO     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE DSYTRF( UPLO, N, A, LDA, IPIV, WORK, LWORK, INFO )     import :: dp     CHARACTER          UPLO     INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DSYSVX( FACT, UPLO, N, NRHS, A, LDA, AF, LDAF, IPIV, B, &                        LDB, X, LDX, RCOND, FERR, BERR, WORK, LWORK, &                        IWORK, INFO )     import :: dp     CHARACTER          FACT, UPLO     INTEGER            INFO, LDA, LDAF, LDB, LDX, LWORK, N, NRHS     REAL(dp)           RCOND     INTEGER            IPIV( * ), IWORK( * )     REAL(dp)           A( LDA, * ), AF( LDAF, * ), B( LDB, * ), &                        BERR( * ), FERR( * ), WORK( * ), X( LDX, * )     END SUBROUTINE      SUBROUTINE DSYEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, IWORK, &                        LIWORK, INFO )     import :: dp     CHARACTER          JOBZ, UPLO     INTEGER            INFO, LDA, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), W( * ), WORK( * )     END SUBROUTINE      SUBROUTINE DSYGVX( ITYPE, JOBZ, RANGE, UPLO, N, A, LDA, B, LDB, &                        VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, &                        LWORK, IWORK, IFAIL, INFO )     import :: dp     CHARACTER          JOBZ, RANGE, UPLO     INTEGER            IL, INFO, ITYPE, IU, LDA, LDB, LDZ, LWORK, M, N     REAL(dp)           ABSTOL, VL, VU     INTEGER            IFAIL( * ), IWORK( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), W( * ), WORK( * ), &                        Z( LDZ, * )     END SUBROUTINE      SUBROUTINE DSYEVX( JOBZ, RANGE, UPLO, N, A, LDA, &                        VL, VU, IL, IU, ABSTOL, M, W, Z, LDZ, WORK, &                        LWORK, IWORK, IFAIL, INFO )     import :: dp     CHARACTER          JOBZ, RANGE, UPLO     INTEGER            IL, INFO, IU, LDA, LDZ, LWORK, M, N     REAL(dp)           ABSTOL, VL, VU     INTEGER            IFAIL( * ), IWORK( * )     REAL(dp)           A( LDA, * ), W( * ), WORK( * ), &                        Z( LDZ, * )     END SUBROUTINE      SUBROUTINE DGGEV( JOBVL, JOBVR, N, A, LDA, B, LDB, ALPHAR, ALPHAI, &                       BETA, VL, LDVL, VR, LDVR, WORK, LWORK, INFO )     import :: dp     CHARACTER          JOBVL, JOBVR     INTEGER            INFO, LDA, LDB, LDVL, LDVR, LWORK, N     REAL(dp)           A( LDA, * ), ALPHAI( * ), ALPHAR( * ), &                        B( LDB, * ), BETA( * ), VL( LDVL, * ), &                        VR( LDVR, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DGGEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, B, LDB, &                        ALPHAR, ALPHAI, BETA, VL, LDVL, VR, LDVR, ILO, IHI, &                        LSCALE, RSCALE, ABNRM, BBNRM, RCONDE, RCONDV, WORK, &                        LWORK, IWORK, BWORK, INFO )     import :: dp     CHARACTER          BALANC, JOBVL, JOBVR, SENSE     INTEGER            IHI, ILO, INFO, LDA, LDB, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM, BBNRM     LOGICAL            BWORK( * )     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), ALPHAI( * ), ALPHAR( * ), B( LDB, * ), &                        BETA( * ), LSCALE( * ), RCONDE( * ), RCONDV( * ), &                        RSCALE( * ), VL( LDVL, * ), VR( LDVR, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DGEEV( JOBVL, JOBVR, N, A, LDA, WR, WI, VL, LDVL, VR, &                       LDVR, WORK, LWORK, INFO )     import :: dp     CHARACTER          JOBVL, JOBVR     INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ), WI( * ), &                        WORK( * ), WR( * )     END SUBROUTINE      SUBROUTINE DGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, WR, WI, &                        VL, LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, &                        RCONDE, RCONDV, WORK, LWORK, IWORK, INFO )     import :: dp     CHARACTER          BALANC, JOBVL, JOBVR, SENSE     INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), RCONDE( * ), RCONDV( * ), &                        SCALE( * ), VL( LDVL, * ), VR( LDVR, * ), &                        WI( * ), WORK( * ), WR( * )     END SUBROUTINE      SUBROUTINE ZGEEV( JOBVL, JOBVR, N, A, LDA, W, VL, LDVL, VR, LDVR, &                       WORK, LWORK, RWORK, INFO )     import :: dp     CHARACTER          JOBVL, JOBVR     INTEGER            INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           RWORK( * )     COMPLEX(dp)        A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ), W( * ), &                        WORK( * )     END SUBROUTINE      SUBROUTINE ZGEEVX( BALANC, JOBVL, JOBVR, SENSE, N, A, LDA, W, VL, &                        LDVL, VR, LDVR, ILO, IHI, SCALE, ABNRM, RCONDE, &                        RCONDV, WORK, LWORK, RWORK, INFO )     import :: dp     CHARACTER          BALANC, JOBVL, JOBVR, SENSE     INTEGER            IHI, ILO, INFO, LDA, LDVL, LDVR, LWORK, N     REAL(dp)           ABNRM     REAL(dp)           RCONDE( * ), RCONDV( * ), RWORK( * ), SCALE( * )     COMPLEX(dp)        A( LDA, * ), VL( LDVL, * ), VR( LDVR, * ), W( * ), &                        WORK( * )     END SUBROUTINE      SUBROUTINE DSYGVD( ITYPE, JOBZ, UPLO, N, A, LDA, B, LDB, W, WORK, &                        LWORK, IWORK, LIWORK, INFO )     import :: dp     CHARACTER          JOBZ, UPLO     INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), W( * ), WORK( * )     END SUBROUTINE      REAL(dp) FUNCTION DLAMCH( CMACH )     import :: dp     CHARACTER          CMACH     END FUNCTION      INTEGER FUNCTION ILAENV( ISPEC, NAME, OPTS, N1, N2, N3, N4 )     CHARACTER*( * )    NAME, OPTS     INTEGER            ISPEC, N1, N2, N3, N4     END FUNCTION      SUBROUTINE ZGETRF( M, N, A, LDA, IPIV, INFO )     import :: dp     INTEGER            INFO, LDA, M, N     INTEGER            IPIV( * )     COMPLEX(dp)        A( LDA, * )     END SUBROUTINE      SUBROUTINE ZGETRS( TRANS, N, NRHS, A, LDA, IPIV, B, LDB, INFO )     import :: dp     CHARACTER          TRANS     INTEGER            INFO, LDA, LDB, N, NRHS     INTEGER            IPIV( * )     COMPLEX(dp)         A( LDA, * ), B( LDB, * )     END SUBROUTINE      SUBROUTINE ZGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )     COMPLEX(dp)        A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DGETRF( M, N, A, LDA, IPIV, INFO )     import :: dp     INTEGER            INFO, LDA, M, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * )     END SUBROUTINE      SUBROUTINE DGETRI( N, A, LDA, IPIV, WORK, LWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LWORK, N     INTEGER            IPIV( * )     REAL(dp)           A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZHEEV( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK, INFO )     import :: dp     CHARACTER          JOBZ, UPLO     INTEGER            INFO, LDA, LWORK, N     REAL(dp)           RWORK( * ), W( * )     COMPLEX(dp)        A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZHEEVD( JOBZ, UPLO, N, A, LDA, W, WORK, LWORK, RWORK, &                        LRWORK, IWORK, LIWORK, INFO )     import :: dp     CHARACTER          JOBZ, UPLO     INTEGER            INFO, LDA, LIWORK, LRWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           RWORK( * ), W( * )     COMPLEX(dp)        A( LDA, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZHEGVD( ITYPE,  JOBZ,  UPLO,  N,  A,  LDA,  B, LDB, W, &                        WORK, LWORK, RWORK, LRWORK, IWORK, LIWORK, &                        INFO )     import :: dp     CHARACTER          JOBZ, UPLO     INTEGER            INFO, ITYPE, LDA, LDB, LIWORK, LRWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           RWORK( * ), W( * )     COMPLEX(dp)        A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK, &                        WORK, LWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK     REAL(dp)           RCOND     INTEGER            JPVT( * )     REAL(dp)           A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE ZGELSY( M, N, NRHS, A, LDA, B, LDB, JPVT, RCOND, RANK, &                        WORK, LWORK, RWORK, INFO )     import :: dp     INTEGER            INFO, LDA, LDB, LWORK, M, N, NRHS, RANK     REAL(dp)           RCOND     INTEGER            JPVT( * )     REAL(dp)           RWORK( * )     COMPLEX(dp)        A( LDA, * ), B( LDB, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DGESVD( JOBU, JOBVT, M, N, A, LDA, S, U, LDU, VT, &                        LDVT, WORK, LWORK, INFO )     import :: dp     CHARACTER          JOBU, JOBVT     INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N     REAL(dp)           A( LDA, * ), S( * ),  U( LDU,  * ), VT( LDVT, * ), &                        WORK( * )     END SUBROUTINE      SUBROUTINE ZGESVD( JOBU, JOBVT,  M,  N,  A,  LDA, S, U, LDU, VT, LDVT, &                        WORK, LWORK, RWORK, INFO )     import :: dp     CHARACTER          JOBU, JOBVT     INTEGER            INFO, LDA, LDU, LDVT, LWORK, M, N     REAL(dp)           RWORK( * ), S( * )     COMPLEX(dp)        A( LDA, * ), U( LDU, * ), VT( LDVT, * ), WORK( * )     END SUBROUTINE      SUBROUTINE DSTEVD( JOBZ, N, D, E, Z, LDZ, WORK, LWORK, IWORK, &                        LIWORK, INFO )     import :: dp     CHARACTER          JOBZ     INTEGER            INFO, LDZ, LIWORK, LWORK, N     INTEGER            IWORK( * )     REAL(dp)           D( * ), E( * ), WORK( * ), Z( LDZ, * )     END SUBROUTINE      SUBROUTINE XERBLA( SRNAME, INFO )     CHARACTER*(*)      SRNAME     INTEGER            INFO     END SUBROUTINE  ! BLAS      SUBROUTINE ZCOPY(N,ZX,INCX,ZY,INCY)     import :: dp     INTEGER INCX,INCY,N     COMPLEX(dp) ZX(*),ZY(*)     END SUBROUTINE      SUBROUTINE DAXPY(N,DA,DX,INCX,DY,INCY)     import :: dp     integer :: INCX, INCY, N     real(dp) :: DA, DX(*), DY(*)     END SUBROUTINE      SUBROUTINE DGEMM(TRANSA,TRANSB,M,N,K,ALPHA,A,LDA,B,LDB,BETA,C,LDC)     import :: dp     DOUBLE PRECISION ALPHA,BETA     INTEGER K,LDA,LDB,LDC,M,N     CHARACTER TRANSA,TRANSB     REAL(dp) A(LDA,*),B(LDB,*),C(LDC,*)     END SUBROUTINE      real(dp) FUNCTION DNRM2(N,X,INCX)     import :: dp     integer :: INCX, N     real(dp) :: X(*)     END FUNCTION      SUBROUTINE DSCAL(N,DA,DX,INCX)     import :: dp     real(dp) :: DA, DX(*)     integer :: INCX, N     END SUBROUTINE      SUBROUTINE DSYMM(SIDE,UPLO,M,N,ALPHA,A,LDA,B,LDB,BETA,C,LDC)     import :: dp     REAL(dp) ALPHA,BETA     INTEGER LDA,LDB,LDC,M,N     CHARACTER SIDE,UPLO     REAL(dp) A(LDA,*),B(LDB,*),C(LDC,*)     END SUBROUTINE      SUBROUTINE DGEQRF(M, N, A, LDA, TAU, WORK, LWORK, INFO)     import :: dp     INTEGER  INFO, LDA, LWORK, M, N     REAL(dp) A(LDA, *), TAU(*), WORK(*)     END SUBROUTINE      SUBROUTINE DORGQR(M, N, K, A, LDA, TAU, WORK, LWORK, INFO)     import :: dp     INTEGER  INFO, K, LDA, LWORK, M, N     REAL(dp) A(LDA,*), TAU(*), WORK(*)     END SUBROUTINE      SUBROUTINE DPOTRF( UPLO, N, A, LDA, INFO )     import :: dp     CHARACTER          UPLO     INTEGER            INFO, LDA, N     REAL(dp)           A( LDA, * )     END SUBROUTINE      SUBROUTINE DTRTRS( UPLO, TRANS, DIAG, N, NRHS, A, LDA, B, LDB, INFO )     import :: dp     CHARACTER          DIAG, TRANS, UPLO     INTEGER            INFO, LDA, LDB, N, NRHS     REAL(dp)           A( LDA, * ), B( LDB, * )     END SUBROUTINE  end interface  contains  end module 
linalg.f90_stripped module linalg   use types, only: dp   use lapack, only: dsyevd, dsygvd, ilaenv, zgetri, zgetrf, zheevd, &        dgeev, zgeev, zhegvd, dgesv, zgesv, dgetrf, dgetri, dgelsy, zgelsy, &        dgesvd, zgesvd, dgeqrf, dorgqr, dpotrf, dtrtrs   use utils, only: stop_error, assert   use constants, only: i_   implicit none   private   public eig, eigvals, eigh, inv, solve, eye, det, lstsq, diag, trace, &        svdvals, svd, qr_fact, cholesky, solve_triangular       interface eig      module procedure deig      module procedure zeig   end interface eig       interface eigh      module procedure deigh_generalized      module procedure deigh_generalized_values      module procedure deigh_simple      module procedure zeigh_generalized      module procedure zeigh_simple   end interface eigh       interface eigvals      module procedure deigvals      module procedure zeigvals   end interface eigvals       interface inv      module procedure dinv      module procedure zinv   end interface inv       interface solve      module procedure dsolve      module procedure zsolve   end interface solve    interface solve_triangular      module procedure dsolve_triangular   end interface solve_triangular       interface det      module procedure ddet      module procedure zdet   end interface det       interface lstsq      module procedure dlstsq      module procedure zlstsq   end interface lstsq       interface diag      module procedure ddiag      module procedure zdiag   end interface diag       interface trace      module procedure dtrace      module procedure ztrace   end interface trace       interface svdvals      module procedure dsvdvals      module procedure zsvdvals   end interface svdvals       interface svd      module procedure dsvd      module procedure zsvd   end interface svd       interface cholesky      module procedure dcholesky   end interface cholesky       interface assert_shape      module procedure dassert_shape      module procedure zassert_shape   end interface assert_shape  contains       subroutine deig(A, lam, c)     real(dp), intent(in) :: A(:, :)       complex(dp), intent(out) :: lam(:)       complex(dp), intent(out) :: c(:, :)            real(dp), allocatable ::  At(:,:), vl(:,: ), vr(:,:), wi(:), work(:), wr(:)     integer :: info, lda, ldvl, ldvr, lwork, n, i      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     call assert_shape(c, [n, n], "solve", "c")     ldvl = n     ldvr = n     lwork = 8*n       allocate(At(lda,n), wr(n), wi(n), vl(ldvl,n), vr(ldvr,n), work(lwork))     At = A      call dgeev('N', 'V', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &          work, lwork, info)     if(info /= 0) then        print *, "dgeev returned info = ", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements ", info+1, ":", n, "of WR and WI contain eigenvalues which"           print *, "have converged."        end if        call stop_error('eig: dgeev error')     end if      lam = wr + i_*wi                    do i = 1,n        if(wi(i) > 0.0) then             c(:, i) = vr(:, i) + i_*vr(:, i+1)        elseif(wi(i) < 0.0_dp) then             c(:, i) = vr(:, i-1) - i_*vr(:, i)        else           c(:, i) = vr(:, i)        end if     end do   end subroutine deig    subroutine zeig(A, lam, c)     complex(dp), intent(in) :: A(:, :)       complex(dp), intent(out) :: lam(:)       complex(dp), intent(out) :: c(:,:)            integer :: info, lda, ldvl, ldvr, lwork, n, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: vl(:,:), vr(:,:), work(:)      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     call assert_shape(c, [n, n], "solve", "c")     ldvl = n     ldvr = n     lwork = 8*n       lrwork = 2*n     allocate(vl(ldvl,n), vr(ldvr,n), work(lwork), rwork(lrwork))     c = A     call zgeev('N', 'V', n, c, lda, lam, vl, ldvl, vr, ldvr, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgeev returned info = ", info        if(info < 0) then           print *, "the ",-info, "-th argument had an illegal value."        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements and ", info+1, ":", n, " of W contain eigenvalues which have"           print *, "converged."        end if        call stop_error('eig: zgeev error')     end if     c = vr   end subroutine zeig    function deigvals(A) result(lam)     real(dp), intent(in) :: A(:, :)       complex(dp), allocatable :: lam(:)            real(dp), allocatable ::  At(:,:), vl(:,: ), vr(:,:), wi(:), work(:), wr(:)     integer :: info, lda, ldvl, ldvr, lwork, n      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     ldvl = n     ldvr = n     lwork = 8*n       allocate(At(lda,n), wr(n), wi(n), vl(ldvl,n), vr(ldvr,n), work(lwork), lam(n))     At = A      call dgeev('N', 'N', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &          work, lwork, info)     if(info /= 0) then        print *, "dgeev returned info = ", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements ", info+1, ":", n, "of WR and WI contain eigenvalues which"           print *, "have converged."        end if        call stop_error('eigvals: dgeev error')     end if      lam = wr + i_*wi   end function deigvals    function zeigvals(A) result(lam)     complex(dp), intent(in) :: A(:, :)       complex(dp), allocatable :: lam(:)            integer :: info, lda, ldvl, ldvr, lwork, n, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: At(:,:), vl(:,:), vr(:,:), work(:)      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     ldvl = n     ldvr = n     lwork = 8*n       lrwork = 2*n     allocate(At(lda,n), vl(ldvl,n), vr(ldvr,n), work(lwork), rwork(lrwork), lam(n))     At = A     call zgeev('N', 'N', n, At, lda, lam, vl, ldvl, vr, ldvr, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgeev returned info = ", info        if(info < 0) then           print *, "the ",-info, "-th argument had an illegal value."        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements and ", info+1, ":", n, " of W contain eigenvalues which have"           print *, "converged."        end if        call stop_error('eig: zgeev error')     end if   end function zeigvals    subroutine deigh_generalized(Am, Bm, lam, c)                    real(dp), intent(in) :: Am(:,:)        real(dp), intent(in) :: Bm(:,:)        real(dp), intent(out) :: lam(:)        real(dp), intent(out) :: c(:,:)        integer :: n          integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: Bmt(:,:), work(:)           n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "B")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 1 + 6*n + 2*n**2     liwork = 3 + 5*n     allocate(Bmt(n,n), work(lwork), iwork(liwork))     c = Am; Bmt = Bm       call dsygvd(1,'V','L',n,c,n,Bmt,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsygvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: dsygvd error')     end if   end subroutine deigh_generalized    subroutine deigh_generalized_values(Am, Bm, lam)                    real(dp), intent(in) :: Am(:,:)        real(dp), intent(in) :: Bm(:,:)        real(dp), intent(out) :: lam(:)        integer :: n          integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: work(:)     real(dp) :: c(size(Am, 1), size(Am, 2)), Bmt(size(Bm, 1), size(Bm, 2))           n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "B")     lwork = 1 + 2*n     liwork = 1     allocate(work(lwork), iwork(liwork))     c = Am; Bmt = Bm       call dsygvd(1,'N','U',n,c,n,Bmt,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsygvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, " the algorithm failed to converge; "           print *, info, " off-diagonal elements of an intermediate tridiagonal form "           print *, "did not converge to zero"        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: dsygvd error')     end if   end subroutine deigh_generalized_values    subroutine deigh_simple(Am, lam, c)                    real(dp), intent(in) :: Am(:,:)        real(dp), intent(out) :: lam(:)        real(dp), intent(out) :: c(:,:)        integer :: n          integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: work(:)           n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 1 + 6*n + 2*n**2     liwork = 3 + 5*n     allocate(work(lwork), iwork(liwork))     c = Am     call dsyevd('V','L',n,c,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsyevd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        end if        call stop_error('eigh: dsyevd error')     end if   end subroutine deigh_simple    subroutine zeigh_generalized(Am, Bm, lam, c)                    complex(dp), intent(in) :: Am(:,:)        complex(dp), intent(in) :: Bm(:,:)        real(dp), intent(out) :: lam(:)           complex(dp), intent(out) :: c(:,:)             integer :: info, liwork, lrwork, lwork, n     integer, allocatable :: iwork(:)     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: Bmt(:,:), work(:)           n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "Bm")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 2*n + n**2     lrwork = 1 + 5*N + 2*n**2     liwork = 3 + 5*n     allocate(Bmt(n,n), work(lwork), rwork(lrwork), iwork(liwork))     c = Am; Bmt = Bm       call zhegvd(1,'V','L',n,c,n,Bmt,n,lam,work,lwork,rwork,lrwork,iwork,liwork,info)     if (info /= 0) then        print *, "zhegvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: zhegvd error')     end if   end subroutine zeigh_generalized    subroutine zeigh_simple(Am, lam, c)                    complex(dp), intent(in) :: Am(:,:)        real(dp), intent(out) :: lam(:)        complex(dp), intent(out) :: c(:,:)             integer :: info, lda, liwork, lrwork, lwork, n     integer, allocatable :: iwork(:)     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: work(:)           n = size(Am, 1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(c, [n, n], "eigh", "c")     lda = max(1, n)     lwork = 2*n + n**2     lrwork = 1 + 5*n + 2*n**2     liwork = 3 + 5*n     allocate(work(lwork), rwork(lrwork), iwork(liwork))     c = Am     call zheevd("V", "L", n, c, lda, lam, work, lwork, rwork, lrwork, &          iwork, liwork, info)     if (info /= 0) then        print *, "zheevd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "through the submatrix lying in rows and columns through"           print *, info/(n+1), " through ", mod(info, n+1)        end if        call stop_error('eigh: zheevd error')     end if   end subroutine zeigh_simple    function dinv(Am) result(Bm)     real(dp), intent(in) :: Am(:,:)       real(dp) :: Bm(size(Am, 1), size(Am, 2))        real(dp), allocatable :: Amt(:,:), work(:)             integer ::  info, lda, n, lwork, nb     integer, allocatable :: ipiv(:)           n = size(Am(1, :))     call assert_shape(Am, [n, n], "inv", "Am")     lda = n     nb = ilaenv(1, '     lwork = n*nb     if (nb < 1) nb = max(1, n)     allocate(Amt(n,n), work(lwork), ipiv(n))     Amt = Am     call dgetrf(n, n, Amt, lda, ipiv, info)     if(info /= 0) then        print *, "dgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: dgetrf error')     end if      call dgetri(n, Amt, n, ipiv, work, lwork, info)     if (info /= 0) then        print *, "dgetri returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; the matrix is"           print *, "singular and its inverse could not be computed."        end if        call stop_error('inv: dgetri error')     end if     Bm = Amt    end function dinv    function zinv(Am) result(Bm)          complex(dp), intent(in) :: Am(:,:)        complex(dp) :: Bm(size(Am, 1), size(Am, 2))        integer :: n, nb          integer :: lwork, info     complex(dp), allocatable:: Amt(:,:), work(:)     integer, allocatable:: ipiv(:)      n = size(Am, 1)     call assert_shape(Am, [n, n], "inv", "Am")     nb = ilaenv(1, 'ZGETRI', "UN", n, -1, -1, -1)       if (nb < 1) nb = max(1, n)     lwork = n*nb     allocate(Amt(n,n), ipiv(n), work(lwork))     Amt = Am     call zgetrf(n, n, Amt, n, ipiv, info)     if (info /= 0) then        print *, "zgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: zgetrf error')     end if     call zgetri(n, Amt, n, ipiv, work, lwork, info)     if (info /= 0) then        print *, "zgetri returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; the matrix is"           print *, "singular and its inverse could not be computed."        end if        call stop_error('inv: zgetri error')     end if     Bm = Amt   end function zinv    function dsolve(A, b) result(x)          real(dp), intent(in) :: A(:,:)       real(dp), intent(in) :: b(:)       real(dp), allocatable :: x(:)          real(dp), allocatable :: At(:,:), bt(:,:)     integer :: n, info, lda     integer, allocatable :: ipiv(:)      n = size(A(1,:))     lda = size(A(:, 1))       call assert_shape(A, [n, n], "solve", "A")     allocate(At(lda,n), bt(n,1), ipiv(n), x(n))     At = A     bt(:,1) = b(:)     call dgesv(n, 1, At, lda, ipiv, bt, n, info)     if(info /= 0) then        print *, "dgesv returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, so the solution could not be computed."        end if        call stop_error('inv: dgesv error')     endif     x = bt(:,1)   end function dsolve    function zsolve(A, b) result(x)          complex(dp), intent(in) :: A(:,:)       complex(dp), intent(in) :: b(:)       complex(dp), allocatable :: x(:)          complex(dp), allocatable :: At(:,:), bt(:,:)     integer :: n, info, lda     integer, allocatable :: ipiv(:)      n = size(A(1,:))     lda = size(A(:, 1))       call assert_shape(A, [n, n], "solve", "A")     allocate(At(lda,n), bt(n,1), ipiv(n), x(n))     At = A     bt(:,1) = b(:)     call zgesv(n, 1, At, lda, ipiv, bt, n, info)     if(info /= 0) then        print *, "zgesv returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, so the solution could not be computed."        end if        call stop_error('inv: zgesv error')     endif     x = bt(:,1)   end function zsolve    function dsolve_triangular(A, b, trans) result(x)               real(dp), intent(in) :: A(:,:)       real(dp), intent(in) :: b(:)       logical, intent(in), optional :: trans     real(dp) :: x(size(b))          real(dp) :: bt(size(b))     integer :: n, info     logical :: trans_     character :: trans_char     trans_ = .false.     if (present(trans)) trans_ = trans     if (trans_) then         trans_char = "T"     else         trans_char = "N"     end if      n = size(A, 1)     call assert_shape(A, [n, n], "solve", "A")     bt = b     call dtrtrs("L", trans_char, "N", n, 1, A, n, bt, n, info)     if(info /= 0) then        print *, "dtrtrs returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the ", info, "-th diagonal element of A is zero,"           print *, "indicating that the matrix is singular and the solutions"           print *, "X have not been computed."        end if        call stop_error('inv: dgesv error')     endif     x = bt   end function dsolve_triangular    function eye(n) result(A)          integer, intent(in) :: n     real(dp) :: A(n, n)     integer :: i      A = 0     do i = 1, n        A(i, i) = 1     end do   end function eye    function ddet(A) result(x)          real(dp), intent(in) :: A(:, :)     real(dp) :: x     integer :: i          integer :: info, n     integer, allocatable :: ipiv(:)     real(dp), allocatable :: At(:,:)      n = size(A(1,:))     call assert_shape(A, [n, n], "det", "A")     allocate(At(n,n), ipiv(n))     At = A     call dgetrf(n, n, At, n, ipiv, info)     if(info /= 0) then        print *, "dgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('det: dgetrf error')     end if                          x = 1.0_dp     do i = 1,n        if(ipiv(i) /= i) then             x = -x*At(i,i)        else           x = x*At(i,i)        endif     end do   end function ddet    function zdet(A) result(x)          complex(dp), intent(in) :: A(:, :)     complex(dp) :: x     integer :: i          integer :: info, n     integer, allocatable :: ipiv(:)     complex(dp), allocatable :: At(:,:)      n = size(A(1,:))     call assert_shape(A, [n, n], "det", "A")     allocate(At(n,n), ipiv(n))     At = A     call zgetrf(n, n, At, n, ipiv, info)     if(info /= 0) then        print *, "zgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: zgetrf error')     end if           x = 1.0_dp + 0*i_     do i = 1,n        if(ipiv(i) /= i) then             x = -x*At(i,i)        else           x = x*At(i,i)        endif     end do   end function zdet    function dlstsq(A, b) result(x)          real(dp), intent(in) :: A(:,:), b(:)     real(dp), allocatable :: x(:)          integer :: info, ldb, lwork, m, n, rank     real(dp) :: rcond     real(dp), allocatable :: work(:), At(:,:), Bt(:,:)     integer, allocatable :: jpvt(:)      m = size(A(:,1))      n = size(A(1,:))     ldb = size(b)     allocate(x(n), At(m,n), Bt(ldb,1), jpvt(n), work(1))     call dgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          -1, info)       lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))       rcond = 0.0_dp     jpvt(:) = 0     Bt(:,1) = b(:)       At(:,:) = A(:,:)     call dgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          lwork, info)     if(info /= 0) then        print *, "dgelsy returned info = ", info        print *, "the ", -info, "-th argument had an illegal value"        call stop_error('lstsq: dgelsy error')     endif     x(:) = Bt(1:n,1)   end function dlstsq    function zlstsq(A, b) result(x)          complex(dp), intent(in) :: A(:,:), b(:)     complex(dp), allocatable :: x(:)          integer :: info, ldb, lwork, m, n, rank     real(dp) :: rcond     complex(dp), allocatable :: At(:,:), Bt(:,:), work(:)     real(dp), allocatable :: rwork(:)     integer, allocatable :: jpvt(:)      m = size(A(:,1))      n = size(A(1,:))     ldb = size(b)     allocate(x(n), At(m,n), Bt(ldb,1), jpvt(n), work(1), rwork(2*n))     call zgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          -1, rwork, info)       lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))       rcond = 0.0_dp     jpvt(:) = 0     Bt(:,1) = b(:)       At(:,:) = A(:,:)     call zgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgelsy returned info = ", info        print *, "the ", -info, "-th argument had an illegal value"        call stop_error('lstsq: zgelsy error')     endif     x(:) = Bt(1:n,1)   end function zlstsq          function ddiag(x) result(A)          real(dp), intent(in) :: x(:)     real(dp), allocatable :: A(:,:)     integer :: i, n      n = size(x)     allocate(A(n,n))     A(:,:) = 0.0_dp     forall(i=1:n) A(i,i) = x(i)   end function ddiag    function zdiag(x) result(A)          complex(dp), intent(in) :: x(:)     complex(dp), allocatable :: A(:,:)     integer :: i, n      n = size(x)     allocate(A(n,n))     A(:,:) = 0*i_     forall(i=1:n) A(i,i) = x(i)   end function zdiag       function dtrace(A) result(t)          real(dp), intent(in) :: A(:,:)     real(dp) :: t     integer :: i      t = 0.0_dp     do i = 1,minval(shape(A))        t = t + A(i,i)     end do   end function dtrace    function ztrace(A) result(t)          complex(dp), intent(in) :: A(:,:)     complex(dp) :: t     integer :: i      t = 0*i_     do i = 1,minval(shape(A))        t = t + A(i,i)     end do   end function ztrace    function dsvdvals(A) result(s)          real(dp), intent(in) :: A(:,:)     real(dp), allocatable :: s(:)          integer :: info, lwork, m, n     real(dp), allocatable :: work(:), At(:,:)     real(dp) :: u(1,1), vt(1,1)        m = size(A(:,1))       n = size(A(1,:))     allocate(At(m,n), s(min(m,n)))     At(:,:) = A(:, :)             allocate(work(1))     call dgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, -1, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call dgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, lwork, info)     if(info /= 0) then        print *, "dgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in         endif        call stop_error('svdvals: dgesvd error')     endif   end function dsvdvals    function zsvdvals(A) result(s)          complex(dp), intent(in) :: A(:,:)     real(dp), allocatable :: s(:)          integer :: info, lwork, m, n, lrwork     complex(dp), allocatable :: work(:), At(:,:)     real(dp), allocatable :: rwork(:)     complex(dp) :: u(1,1), vt(1,1)        m = size(A(:,1))       n = size(A(1,:))     lrwork = 5*min(m,n)     allocate(At(m,n), s(min(m,n)), rwork(lrwork))     At(:,:) = A(:,:)             allocate(work(1))     call zgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, -1, rwork, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call zgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, lwork, rwork, info)     if(info /= 0) then        print *, "zgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "ZBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of RWORK"           print *, "in ZGESVD's man page for details."        endif        call stop_error('svdvals: zgesvd error')     endif   end function zsvdvals    subroutine dsvd(A, s, U, Vtransp)                              real(dp), intent(in) :: A(:,:)     real(dp), intent(out) :: s(:), U(:,:), Vtransp(:,:)          integer :: info, lwork, m, n, ldu     real(dp), allocatable :: work(:), At(:,:)            m = size(A(:,1))       n = size(A(1,:))     ldu = m     allocate(At(m,n))     At(:,:) = A(:,:)        call assert_shape(U, [m, m], "svd", "U")     call assert_shape(Vtransp, [n, n], "svd", "Vtransp")           allocate(work(1))     call dgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, -1, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call dgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, lwork, info)     if(info /= 0) then        print *, "dgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in         endif        call stop_error('svd: dgesvd error')     endif   end subroutine dsvd    subroutine zsvd(A, s, U, Vtransp)                                   complex(dp), intent(in) :: A(:,:)     real(dp), intent(out) :: s(:)     complex(dp), intent(out) :: U(:,:), Vtransp(:,:)          integer :: info, lwork, m, n, ldu, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: work(:), At(:,:)            m = size(A(:,1))       n = size(A(1,:))     ldu = m     lrwork = 5*min(m,n)     allocate(rwork(lrwork), At(m,n))     At(:,:) = A(:,:)        call assert_shape(U, [m, m], "svd", "U")     call assert_shape(Vtransp, [n, n], "svd", "Vtransp")           allocate(work(1))     call zgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, -1,&          rwork, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call zgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "ZBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in         endif        call stop_error('svd: zgesvd error')     endif   end subroutine zsvd    function dcholesky(A) result(L)                    real(dp), intent(in) :: A(:,:)     real(dp) :: L(size(A,1), size(A,1))          integer :: info, n, i, j     n = size(A,1)     call assert_shape(A, [n, n], "cholesky", "A")     L = A     call dpotrf("L", n, L, n, info)     if(info /= 0) then        print *, "dpotrf returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "the leading minor of order", info           print *, "is not positive definite, and the factorization could not"           print *, "be completed."        endif        call stop_error('cholesky: dpotrf error')     endif     do j = 1, n         do i = 1, j-1             L(i,j) = 0         end do     end do   end function dcholesky    subroutine dassert_shape(A, shap, routine, matname)          real(dp), intent(in) :: A(:,:)     integer, intent(in) :: shap(:)     character(len=*) :: routine, matname      if(any(shape(A) /= shap)) then        print *, "In routine " // routine // " matrix " // matname // " has illegal shape ", shape(A)        print *, "Shape should be ", shap        call stop_error("Aborting due to illegal matrix operation")     end if   end subroutine dassert_shape    subroutine zassert_shape(A, shap, routine, matname)          complex(dp), intent(in) :: A(:,:)     integer, intent(in) :: shap(:)     character(len=*) :: routine, matname      if(any(shape(A) /= shap)) then        print *, "In routine " // routine // " matrix " // matname // " has illegal shape ", shape(A)        print *, "Shape should be ", shap        call stop_error("Aborting due to illegal matrix operation")     end if   end subroutine zassert_shape  subroutine qr_fact(A, Q, R)  real(dp), intent(in) :: A(:,:) real(dp), intent(out) :: Q(:,:), R(:,:) integer :: i, lwork, info, K real(dp) :: tau(min(size(A,1),size(A,2))), At(size(A,1), size(A,2)) real(dp), allocatable :: work(:) call assert(size(A,1) >= size(A,2)) K = min(size(A,1),size(A,2)) allocate(work(1)) At = A call dgeqrf(size(A,1), size(A,2), At, size(A,1), tau, work, -1, info) call assert(info == 0) lwork = int(work(1)) deallocate(work) allocate(work(lwork)) call dgeqrf(size(A,1), size(A,2), At, size(A,1), tau, work, size(work), info) if (info /= 0) then    print *, "dgeqrf returned info = ", info    if (info < 0) then       print *, "the ", -info, "-th argument had an illegal value"    end if    call stop_error('dgeqrf error') end if R = At(:K,:) do i = 1, size(tau)-1     R(i+1:,i) = 0 end do call dorgqr(size(A,1), size(A,2), size(tau), At, size(A,1), tau, work, -1, info) call assert(info == 0) lwork = int(work(1)) deallocate(work) allocate(work(lwork)) call dorgqr(size(A,1), size(A,2), size(tau), At, size(A,1), tau, work, &     size(work), info) if (info /= 0) then    print *, "dgeqrf returned info = ", info    if (info < 0) then       print *, "the ", -info, "-th argument had an illegal value"    end if    call stop_error('dgeqrf error') end if Q = At end subroutine  end module linalg 
linalg.f90_comments module linalg   use types, only: dp   use lapack, only: dsyevd, dsygvd, ilaenv, zgetri, zgetrf, zheevd, &        dgeev, zgeev, zhegvd, dgesv, zgesv, dgetrf, dgetri, dgelsy, zgelsy, &        dgesvd, zgesvd, dgeqrf, dorgqr, dpotrf, dtrtrs   use utils, only: stop_error, assert   use constants, only: i_   implicit none   private   public eig, eigvals, eigh, inv, solve, eye, det, lstsq, diag, trace, &        svdvals, svd, qr_fact, cholesky, solve_triangular    ! eigenvalue/-vector problem for general matrices:   interface eig      module procedure deig      module procedure zeig   end interface eig    ! eigenvalue/-vector problem for real symmetric/complex hermitian matrices:   interface eigh      module procedure deigh_generalized      module procedure deigh_generalized_values      module procedure deigh_simple      module procedure zeigh_generalized      module procedure zeigh_simple   end interface eigh    ! eigenvalues for general matrices:   interface eigvals      module procedure deigvals      module procedure zeigvals   end interface eigvals    ! matrix inversion for real/complex matrices:   interface inv      module procedure dinv      module procedure zinv   end interface inv    ! solution to linear systems of equation with real/complex coefficients:   interface solve      module procedure dsolve      module procedure zsolve   end interface solve    interface solve_triangular      module procedure dsolve_triangular   end interface solve_triangular    ! determinants of real/complex square matrices:   interface det      module procedure ddet      module procedure zdet   end interface det    ! least square solutions the real/complex systems of equations of possibly non-square shape:   interface lstsq      module procedure dlstsq      module procedure zlstsq   end interface lstsq    ! construction of square matrices from the diagonal elements:   interface diag      module procedure ddiag      module procedure zdiag   end interface diag    ! trace of real/complex matrices:   interface trace      module procedure dtrace      module procedure ztrace   end interface trace    ! singular values of real/complex matrices:   interface svdvals      module procedure dsvdvals      module procedure zsvdvals   end interface svdvals    ! singular value decomposition of real/complex matrices:   interface svd      module procedure dsvd      module procedure zsvd   end interface svd    ! Cholesky decomposition   interface cholesky      module procedure dcholesky   end interface cholesky    ! assert shape of matrices:   interface assert_shape      module procedure dassert_shape      module procedure zassert_shape   end interface assert_shape  contains    ! TODO: add optional switch for left or right eigenvectors in deig() and zeig()?   subroutine deig(A, lam, c)     real(dp), intent(in) :: A(:, :)  ! matrix for eigenvalue compuation     complex(dp), intent(out) :: lam(:)  ! eigenvalues: A c = lam c     complex(dp), intent(out) :: c(:, :)  ! eigenvectors: A c = lam c; c(i,j) = ith component of jth vec.     ! LAPACK variables for DGEEV:     real(dp), allocatable ::  At(:,:), vl(:,: ), vr(:,:), wi(:), work(:), wr(:)     integer :: info, lda, ldvl, ldvr, lwork, n, i      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     call assert_shape(c, [n, n], "solve", "c")     ldvl = n     ldvr = n     lwork = 8*n  ! TODO: can this size be optimized? query first?     allocate(At(lda,n), wr(n), wi(n), vl(ldvl,n), vr(ldvr,n), work(lwork))     At = A      call dgeev('N', 'V', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &          work, lwork, info)     if(info /= 0) then        print *, "dgeev returned info = ", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements ", info+1, ":", n, "of WR and WI contain eigenvalues which"           print *, "have converged."        end if        call stop_error('eig: dgeev error')     end if      lam = wr + i_*wi     ! as DGEEV has a rather complicated way of returning the eigenvectors,     ! it is necessary to build the complex array of eigenvectors from     ! two real arrays:     do i = 1,n        if(wi(i) > 0.0) then  ! first of two conjugate eigenvalues           c(:, i) = vr(:, i) + i_*vr(:, i+1)        elseif(wi(i) < 0.0_dp) then  ! second of two conjugate eigenvalues           c(:, i) = vr(:, i-1) - i_*vr(:, i)        else           c(:, i) = vr(:, i)        end if     end do   end subroutine deig    subroutine zeig(A, lam, c)     complex(dp), intent(in) :: A(:, :)  ! matrix to solve eigenproblem for     complex(dp), intent(out) :: lam(:)  ! eigenvalues: A c = lam c     complex(dp), intent(out) :: c(:,:)  ! eigenvectors: A c = lam c; c(i,j) = ith component of jth vec.     ! LAPACK variables:     integer :: info, lda, ldvl, ldvr, lwork, n, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: vl(:,:), vr(:,:), work(:)      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     call assert_shape(c, [n, n], "solve", "c")     ldvl = n     ldvr = n     lwork = 8*n  ! TODO: can this size be optimized? query first?     lrwork = 2*n     allocate(vl(ldvl,n), vr(ldvr,n), work(lwork), rwork(lrwork))     c = A     call zgeev('N', 'V', n, c, lda, lam, vl, ldvl, vr, ldvr, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgeev returned info = ", info        if(info < 0) then           print *, "the ",-info, "-th argument had an illegal value."        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements and ", info+1, ":", n, " of W contain eigenvalues which have"           print *, "converged."        end if        call stop_error('eig: zgeev error')     end if     c = vr   end subroutine zeig    function deigvals(A) result(lam)     real(dp), intent(in) :: A(:, :)  ! matrix for eigenvalue compuation     complex(dp), allocatable :: lam(:)  ! eigenvalues: A c = lam c     ! LAPACK variables for DGEEV:     real(dp), allocatable ::  At(:,:), vl(:,: ), vr(:,:), wi(:), work(:), wr(:)     integer :: info, lda, ldvl, ldvr, lwork, n      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     ldvl = n     ldvr = n     lwork = 8*n  ! TODO: can this size be optimized? query first?     allocate(At(lda,n), wr(n), wi(n), vl(ldvl,n), vr(ldvr,n), work(lwork), lam(n))     At = A      call dgeev('N', 'N', n, At, lda, wr, wi, vl, ldvl, vr, ldvr, &          work, lwork, info)     if(info /= 0) then        print *, "dgeev returned info = ", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements ", info+1, ":", n, "of WR and WI contain eigenvalues which"           print *, "have converged."        end if        call stop_error('eigvals: dgeev error')     end if      lam = wr + i_*wi   end function deigvals    function zeigvals(A) result(lam)     complex(dp), intent(in) :: A(:, :)  ! matrix to solve eigenproblem for     complex(dp), allocatable :: lam(:)  ! eigenvalues: A c = lam c     ! LAPACK variables:     integer :: info, lda, ldvl, ldvr, lwork, n, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: At(:,:), vl(:,:), vr(:,:), work(:)      lda = size(A(:,1))     n = size(A(1,:))     call assert_shape(A, [n, n], "solve", "A")     ldvl = n     ldvr = n     lwork = 8*n  ! TODO: can this size be optimized? query first?     lrwork = 2*n     allocate(At(lda,n), vl(ldvl,n), vr(ldvr,n), work(lwork), rwork(lrwork), lam(n))     At = A     call zgeev('N', 'N', n, At, lda, lam, vl, ldvl, vr, ldvr, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgeev returned info = ", info        if(info < 0) then           print *, "the ",-info, "-th argument had an illegal value."        else           print *, "the QR algorithm failed to compute all the"           print *, "eigenvalues, and no eigenvectors have been computed;"           print *, "elements and ", info+1, ":", n, " of W contain eigenvalues which have"           print *, "converged."        end if        call stop_error('eig: zgeev error')     end if   end function zeigvals    subroutine deigh_generalized(Am, Bm, lam, c)     ! solves generalized eigen value problem for all eigenvalues and eigenvectors     ! Am must by symmetric, Bm symmetric positive definite.     ! Only the lower triangular part of Am and Bm is used.     real(dp), intent(in) :: Am(:,:)   ! LHS matrix: Am c = lam Bm c     real(dp), intent(in) :: Bm(:,:)   ! RHS matrix: Am c = lam Bm c     real(dp), intent(out) :: lam(:)   ! eigenvalues: Am c = lam Bm c     real(dp), intent(out) :: c(:,:)   ! eigenvectors: Am c = lam Bm c; c(i,j) = ith component of jth vec.     integer :: n     ! lapack variables     integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: Bmt(:,:), work(:)      ! solve     n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "B")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 1 + 6*n + 2*n**2     liwork = 3 + 5*n     allocate(Bmt(n,n), work(lwork), iwork(liwork))     c = Am; Bmt = Bm  ! Bmt temporaries overwritten by dsygvd     call dsygvd(1,'V','L',n,c,n,Bmt,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsygvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: dsygvd error')     end if   end subroutine deigh_generalized    subroutine deigh_generalized_values(Am, Bm, lam)     ! solves generalized eigen value problem for all eigenvalues     ! Am must by symmetric, Bm symmetric positive definite.     ! Only the upper triangular part of Am and Bm is used.     real(dp), intent(in) :: Am(:,:)   ! LHS matrix: Am c = lam Bm c     real(dp), intent(in) :: Bm(:,:)   ! RHS matrix: Am c = lam Bm c     real(dp), intent(out) :: lam(:)   ! eigenvalues: Am c = lam Bm c     integer :: n     ! lapack variables     integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: work(:)     real(dp) :: c(size(Am, 1), size(Am, 2)), Bmt(size(Bm, 1), size(Bm, 2))      ! solve     n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "B")     lwork = 1 + 2*n     liwork = 1     allocate(work(lwork), iwork(liwork))     c = Am; Bmt = Bm  ! Bmt temporaries overwritten by dsygvd     call dsygvd(1,'N','U',n,c,n,Bmt,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsygvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, " the algorithm failed to converge; "           print *, info, " off-diagonal elements of an intermediate tridiagonal form "           print *, "did not converge to zero"        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: dsygvd error')     end if   end subroutine deigh_generalized_values    subroutine deigh_simple(Am, lam, c)     ! solves eigen value problem for all eigenvalues and eigenvectors     ! Am must by symmetric     ! Only the lower triangular part of Am is used.     real(dp), intent(in) :: Am(:,:)   ! LHS matrix: Am c = lam c     real(dp), intent(out) :: lam(:)   ! eigenvalues: Am c = lam c     real(dp), intent(out) :: c(:,:)   ! eigenvectors: Am c = lam c; c(i,j) = ith component of jth vec.     integer :: n     ! lapack variables     integer :: lwork, liwork, info     integer, allocatable :: iwork(:)     real(dp), allocatable :: work(:)      ! solve     n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 1 + 6*n + 2*n**2     liwork = 3 + 5*n     allocate(work(lwork), iwork(liwork))     c = Am     call dsyevd('V','L',n,c,n,lam,work,lwork,iwork,liwork,info)     if (info /= 0) then        print *, "dsyevd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        end if        call stop_error('eigh: dsyevd error')     end if   end subroutine deigh_simple    subroutine zeigh_generalized(Am, Bm, lam, c)     ! solves generalized eigen value problem for all eigenvalues and eigenvectors     ! Am must by hermitian, Bm hermitian positive definite.     ! Only the lower triangular part of Am and Bm is used.     complex(dp), intent(in) :: Am(:,:)   ! LHS matrix: Am c = lam Bm c     complex(dp), intent(in) :: Bm(:,:)   ! RHS matrix: Am c = lam Bm c     real(dp), intent(out) :: lam(:)      ! eigenvalues: Am c = lam Bm c     complex(dp), intent(out) :: c(:,:)   ! eigenvectors: Am c = lam Bm c; c(i,j) = ith component of jth vec.     ! lapack variables     integer :: info, liwork, lrwork, lwork, n     integer, allocatable :: iwork(:)     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: Bmt(:,:), work(:)      ! solve     n = size(Am,1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(Bm, [n, n], "eigh", "Bm")     call assert_shape(c, [n, n], "eigh", "c")     lwork = 2*n + n**2     lrwork = 1 + 5*N + 2*n**2     liwork = 3 + 5*n     allocate(Bmt(n,n), work(lwork), rwork(lrwork), iwork(liwork))     c = Am; Bmt = Bm  ! Bmt temporary overwritten by zhegvd     call zhegvd(1,'V','L',n,c,n,Bmt,n,lam,work,lwork,rwork,lrwork,iwork,liwork,info)     if (info /= 0) then        print *, "zhegvd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else if (info <= n) then           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "on the submatrix lying in rows and columns", 1.0_dp*info/(n+1)           print *, "through", mod(info, n+1)        else           print *, "The leading minor of order ", info-n, &                "of B is not positive definite. The factorization of B could ", &                "not be completed and no eigenvalues or eigenvectors were computed."        end if        call stop_error('eigh: zhegvd error')     end if   end subroutine zeigh_generalized    subroutine zeigh_simple(Am, lam, c)     ! solves eigen value problem for all eigenvalues and eigenvectors     ! Am must by symmetric     ! Only the lower triangular part of Am is used.     complex(dp), intent(in) :: Am(:,:)   ! LHS matrix: Am c = lam c     real(dp), intent(out) :: lam(:)   ! eigenvalues: Am c = lam c     complex(dp), intent(out) :: c(:,:)   ! eigenvectors: Am c = lam c; c(i,j) = ith component of jth vec.     ! LAPACK variables:     integer :: info, lda, liwork, lrwork, lwork, n     integer, allocatable :: iwork(:)     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: work(:)      ! use LAPACK's zheevd routine     n = size(Am, 1)     call assert_shape(Am, [n, n], "eigh", "Am")     call assert_shape(c, [n, n], "eigh", "c")     lda = max(1, n)     lwork = 2*n + n**2     lrwork = 1 + 5*n + 2*n**2     liwork = 3 + 5*n     allocate(work(lwork), rwork(lrwork), iwork(liwork))     c = Am     call zheevd("V", "L", n, c, lda, lam, work, lwork, rwork, lrwork, &          iwork, liwork, info)     if (info /= 0) then        print *, "zheevd returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the algorithm failed to compute an eigenvalue while working"           print *, "through the submatrix lying in rows and columns through"           print *, info/(n+1), " through ", mod(info, n+1)        end if        call stop_error('eigh: zheevd error')     end if   end subroutine zeigh_simple    function dinv(Am) result(Bm)     real(dp), intent(in) :: Am(:,:)  ! matrix to be inverted     real(dp) :: Bm(size(Am, 1), size(Am, 2))   ! Bm = inv(Am)     real(dp), allocatable :: Amt(:,:), work(:)  ! temporary work arrays      ! LAPACK variables:     integer ::  info, lda, n, lwork, nb     integer, allocatable :: ipiv(:)      ! use LAPACK's dgetrf and dgetri     n = size(Am(1, :))     call assert_shape(Am, [n, n], "inv", "Am")     lda = n     nb = ilaenv(1, 'DGETRI', "UN", n, -1, -1, -1)  ! TODO: check UN param     lwork = n*nb     if (nb < 1) nb = max(1, n)     allocate(Amt(n,n), work(lwork), ipiv(n))     Amt = Am     call dgetrf(n, n, Amt, lda, ipiv, info)     if(info /= 0) then        print *, "dgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: dgetrf error')     end if      call dgetri(n, Amt, n, ipiv, work, lwork, info)     if (info /= 0) then        print *, "dgetri returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; the matrix is"           print *, "singular and its inverse could not be computed."        end if        call stop_error('inv: dgetri error')     end if     Bm = Amt    end function dinv    function zinv(Am) result(Bm)     ! Inverts the general complex matrix Am     complex(dp), intent(in) :: Am(:,:)   ! Matrix to be inverted     complex(dp) :: Bm(size(Am, 1), size(Am, 2))   ! Bm = inv(Am)     integer :: n, nb     ! lapack variables     integer :: lwork, info     complex(dp), allocatable:: Amt(:,:), work(:)     integer, allocatable:: ipiv(:)      n = size(Am, 1)     call assert_shape(Am, [n, n], "inv", "Am")     nb = ilaenv(1, 'ZGETRI', "UN", n, -1, -1, -1)  ! TODO: check UN param     if (nb < 1) nb = max(1, n)     lwork = n*nb     allocate(Amt(n,n), ipiv(n), work(lwork))     Amt = Am     call zgetrf(n, n, Amt, n, ipiv, info)     if (info /= 0) then        print *, "zgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: zgetrf error')     end if     call zgetri(n, Amt, n, ipiv, work, lwork, info)     if (info /= 0) then        print *, "zgetri returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; the matrix is"           print *, "singular and its inverse could not be computed."        end if        call stop_error('inv: zgetri error')     end if     Bm = Amt   end function zinv    function dsolve(A, b) result(x)     ! solves a system of equations A x = b with one right hand side     real(dp), intent(in) :: A(:,:)  ! coefficient matrix A     real(dp), intent(in) :: b(:)  ! right-hand-side A x = b     real(dp), allocatable :: x(:)     ! LAPACK variables:     real(dp), allocatable :: At(:,:), bt(:,:)     integer :: n, info, lda     integer, allocatable :: ipiv(:)      n = size(A(1,:))     lda = size(A(:, 1))  ! TODO: remove lda (which is = n!)     call assert_shape(A, [n, n], "solve", "A")     allocate(At(lda,n), bt(n,1), ipiv(n), x(n))     At = A     bt(:,1) = b(:)     call dgesv(n, 1, At, lda, ipiv, bt, n, info)     if(info /= 0) then        print *, "dgesv returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, so the solution could not be computed."        end if        call stop_error('inv: dgesv error')     endif     x = bt(:,1)   end function dsolve    function zsolve(A, b) result(x)     ! solves a system of equations A x = b with one right hand side     complex(dp), intent(in) :: A(:,:)  ! coefficient matrix A     complex(dp), intent(in) :: b(:)  ! right-hand-side A x = b     complex(dp), allocatable :: x(:)     ! LAPACK variables:     complex(dp), allocatable :: At(:,:), bt(:,:)     integer :: n, info, lda     integer, allocatable :: ipiv(:)      n = size(A(1,:))     lda = size(A(:, 1))  ! TODO: remove lda here, too     call assert_shape(A, [n, n], "solve", "A")     allocate(At(lda,n), bt(n,1), ipiv(n), x(n))     At = A     bt(:,1) = b(:)     call zgesv(n, 1, At, lda, ipiv, bt, n, info)     if(info /= 0) then        print *, "zgesv returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, so the solution could not be computed."        end if        call stop_error('inv: zgesv error')     endif     x = bt(:,1)   end function zsolve    function dsolve_triangular(A, b, trans) result(x)     ! solves a system of equations A x = b with one right hand side     ! A is a lower triangular matrix (only the lower triangle is used)     real(dp), intent(in) :: A(:,:)  ! coefficient matrix A     real(dp), intent(in) :: b(:)  ! right-hand-side A x = b     logical, intent(in), optional :: trans     real(dp) :: x(size(b))     ! LAPACK variables:     real(dp) :: bt(size(b))     integer :: n, info     logical :: trans_     character :: trans_char     trans_ = .false.     if (present(trans)) trans_ = trans     if (trans_) then         trans_char = "T"     else         trans_char = "N"     end if      n = size(A, 1)     call assert_shape(A, [n, n], "solve", "A")     bt = b     call dtrtrs("L", trans_char, "N", n, 1, A, n, bt, n, info)     if(info /= 0) then        print *, "dtrtrs returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "the ", info, "-th diagonal element of A is zero,"           print *, "indicating that the matrix is singular and the solutions"           print *, "X have not been computed."        end if        call stop_error('inv: dgesv error')     endif     x = bt   end function dsolve_triangular    function eye(n) result(A)     ! Returns the identity matrix of size n x n and type real.     integer, intent(in) :: n     real(dp) :: A(n, n)     integer :: i      A = 0     do i = 1, n        A(i, i) = 1     end do   end function eye    function ddet(A) result(x)     ! compute the determinant of a real matrix using an LU factorization     real(dp), intent(in) :: A(:, :)     real(dp) :: x     integer :: i     ! LAPACK variables:     integer :: info, n     integer, allocatable :: ipiv(:)     real(dp), allocatable :: At(:,:)      n = size(A(1,:))     call assert_shape(A, [n, n], "det", "A")     allocate(At(n,n), ipiv(n))     At = A     call dgetrf(n, n, At, n, ipiv, info)     if(info /= 0) then        print *, "dgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('det: dgetrf error')     end if      ! At now contains the LU of the factorization A = PLU     ! as L has unit diagonal entries, the determinant can be computed     ! from the product of U's diagonal entries. Additional sign changes     ! stemming from the permutations P have to be taken into account as well.     x = 1.0_dp     do i = 1,n        if(ipiv(i) /= i) then  ! additional sign change           x = -x*At(i,i)        else           x = x*At(i,i)        endif     end do   end function ddet    function zdet(A) result(x)     ! compute the determinant of a real matrix using an LU factorization     complex(dp), intent(in) :: A(:, :)     complex(dp) :: x     integer :: i     ! LAPACK variables:     integer :: info, n     integer, allocatable :: ipiv(:)     complex(dp), allocatable :: At(:,:)      n = size(A(1,:))     call assert_shape(A, [n, n], "det", "A")     allocate(At(n,n), ipiv(n))     At = A     call zgetrf(n, n, At, n, ipiv, info)     if(info /= 0) then        print *, "zgetrf returned info =", info        if (info < 0) then           print *, "the", -info, "-th argument had an illegal value"        else           print *, "U(", info, ",", info, ") is exactly zero; The factorization"           print *, "has been completed, but the factor U is exactly"           print *, "singular, and division by zero will occur if it is used"           print *, "to solve a system of equations."        end if        call stop_error('inv: zgetrf error')     end if      ! for details on the computation, compare the comment in ddet().     x = 1.0_dp + 0*i_     do i = 1,n        if(ipiv(i) /= i) then  ! additional sign change           x = -x*At(i,i)        else           x = x*At(i,i)        endif     end do   end function zdet    function dlstsq(A, b) result(x)     ! compute least square solution to A x = b for real A, b     real(dp), intent(in) :: A(:,:), b(:)     real(dp), allocatable :: x(:)     ! LAPACK variables:     integer :: info, ldb, lwork, m, n, rank     real(dp) :: rcond     real(dp), allocatable :: work(:), At(:,:), Bt(:,:)     integer, allocatable :: jpvt(:)      m = size(A(:,1)) ! = lda     n = size(A(1,:))     ldb = size(b)     allocate(x(n), At(m,n), Bt(ldb,1), jpvt(n), work(1))     call dgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          -1, info)  ! query optimal workspace size     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))  ! allocate with ideal size     rcond = 0.0_dp     jpvt(:) = 0     Bt(:,1) = b(:)  ! only one right-hand side     At(:,:) = A(:,:)     call dgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          lwork, info)     if(info /= 0) then        print *, "dgelsy returned info = ", info        print *, "the ", -info, "-th argument had an illegal value"        call stop_error('lstsq: dgelsy error')     endif     x(:) = Bt(1:n,1)   end function dlstsq    function zlstsq(A, b) result(x)     ! compute least square solution to A x = b for complex A, b     complex(dp), intent(in) :: A(:,:), b(:)     complex(dp), allocatable :: x(:)     ! LAPACK variables:     integer :: info, ldb, lwork, m, n, rank     real(dp) :: rcond     complex(dp), allocatable :: At(:,:), Bt(:,:), work(:)     real(dp), allocatable :: rwork(:)     integer, allocatable :: jpvt(:)      m = size(A(:,1)) ! = lda     n = size(A(1,:))     ldb = size(b)     allocate(x(n), At(m,n), Bt(ldb,1), jpvt(n), work(1), rwork(2*n))     call zgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          -1, rwork, info)  ! query optimal workspace size     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))  ! allocate with ideal size     rcond = 0.0_dp     jpvt(:) = 0     Bt(:,1) = b(:)  ! only one right-hand side     At(:,:) = A(:,:)     call zgelsy(m, n, 1, At, m, Bt, ldb, jpvt, rcond, rank, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgelsy returned info = ", info        print *, "the ", -info, "-th argument had an illegal value"        call stop_error('lstsq: zgelsy error')     endif     x(:) = Bt(1:n,1)   end function zlstsq    ! TODO: can assumed types help in Xdiag() and Xtrace()?   ! TODO: add optional axis parameter in both xdiag() functions   function ddiag(x) result(A)     ! construct real matrix from diagonal elements     real(dp), intent(in) :: x(:)     real(dp), allocatable :: A(:,:)     integer :: i, n      n = size(x)     allocate(A(n,n))     A(:,:) = 0.0_dp     forall(i=1:n) A(i,i) = x(i)   end function ddiag    function zdiag(x) result(A)     ! construct complex matrix from diagonal elements     complex(dp), intent(in) :: x(:)     complex(dp), allocatable :: A(:,:)     integer :: i, n      n = size(x)     allocate(A(n,n))     A(:,:) = 0*i_     forall(i=1:n) A(i,i) = x(i)   end function zdiag    ! TODO: add optional axis parameter in both xtrace() functions   function dtrace(A) result(t)     ! return trace along the main diagonal     real(dp), intent(in) :: A(:,:)     real(dp) :: t     integer :: i      t = 0.0_dp     do i = 1,minval(shape(A))        t = t + A(i,i)     end do   end function dtrace    function ztrace(A) result(t)     ! return trace along the main diagonal     complex(dp), intent(in) :: A(:,:)     complex(dp) :: t     integer :: i      t = 0*i_     do i = 1,minval(shape(A))        t = t + A(i,i)     end do   end function ztrace    function dsvdvals(A) result(s)     ! compute singular values s_i of a real m x n matrix A     real(dp), intent(in) :: A(:,:)     real(dp), allocatable :: s(:)     ! LAPACK related:     integer :: info, lwork, m, n     real(dp), allocatable :: work(:), At(:,:)     real(dp) :: u(1,1), vt(1,1)  ! not used if only s is to be computed      m = size(A(:,1))  ! = lda     n = size(A(1,:))     allocate(At(m,n), s(min(m,n)))     At(:,:) = A(:, :)  ! A is overwritten in dgesvd      ! query optimal lwork and allocate workspace:     allocate(work(1))     call dgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, -1, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call dgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, lwork, info)     if(info /= 0) then        print *, "dgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "DBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in DGESVD's man page for details."        endif        call stop_error('svdvals: dgesvd error')     endif   end function dsvdvals    function zsvdvals(A) result(s)     ! compute singular values s_i of a real m x n matrix A     complex(dp), intent(in) :: A(:,:)     real(dp), allocatable :: s(:)     ! LAPACK related:     integer :: info, lwork, m, n, lrwork     complex(dp), allocatable :: work(:), At(:,:)     real(dp), allocatable :: rwork(:)     complex(dp) :: u(1,1), vt(1,1)  ! not used if only s is to be computed      m = size(A(:,1))  ! = lda     n = size(A(1,:))     lrwork = 5*min(m,n)     allocate(At(m,n), s(min(m,n)), rwork(lrwork))     At(:,:) = A(:,:)  ! A is overwritten in zgesvd!      ! query optimal lwork and allocate workspace:     allocate(work(1))     call zgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, -1, rwork, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call zgesvd('N', 'N', m, n, At, m, s, u, 1, vt, 1, work, lwork, rwork, info)     if(info /= 0) then        print *, "zgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "ZBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of RWORK"           print *, "in ZGESVD's man page for details."        endif        call stop_error('svdvals: zgesvd error')     endif   end function zsvdvals    subroutine dsvd(A, s, U, Vtransp)     ! compute the singular value decomposition A = U sigma Vtransp of a     ! real m x n matrix A     ! U is m x m     ! Vtransp is n x n     ! s has size min(m, n) --> sigma matrix is (n x m) with sigma_ii = s_i     real(dp), intent(in) :: A(:,:)     real(dp), intent(out) :: s(:), U(:,:), Vtransp(:,:)     ! LAPACK related:     integer :: info, lwork, m, n, ldu     real(dp), allocatable :: work(:), At(:,:)      ! TODO: check shapes here and in other routines?      m = size(A(:,1))  ! = lda     n = size(A(1,:))     ldu = m     allocate(At(m,n))     At(:,:) = A(:,:)  ! use a temporary as dgesvd destroys its input      call assert_shape(U, [m, m], "svd", "U")     call assert_shape(Vtransp, [n, n], "svd", "Vtransp")      ! query optimal lwork and allocate workspace:     allocate(work(1))     call dgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, -1, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call dgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, lwork, info)     if(info /= 0) then        print *, "dgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "DBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in DGESVD's man page for details."        endif        call stop_error('svd: dgesvd error')     endif   end subroutine dsvd    subroutine zsvd(A, s, U, Vtransp)     ! compute the singular value decomposition A = U sigma V^H of a     ! complex m x m matrix A     ! U is m x min(m, n)     ! Vtransp is n x n     ! sigma is m x n with with sigma_ii = s_i     ! note that this routine returns V^H, not V!     complex(dp), intent(in) :: A(:,:)     real(dp), intent(out) :: s(:)     complex(dp), intent(out) :: U(:,:), Vtransp(:,:)     ! LAPACK related:     integer :: info, lwork, m, n, ldu, lrwork     real(dp), allocatable :: rwork(:)     complex(dp), allocatable :: work(:), At(:,:)      ! TODO: check shapes here and in other routines?      m = size(A(:,1))  ! = lda     n = size(A(1,:))     ldu = m     lrwork = 5*min(m,n)     allocate(rwork(lrwork), At(m,n))     At(:,:) = A(:,:)  ! use a temporary as zgesvd destroys its input      call assert_shape(U, [m, m], "svd", "U")     call assert_shape(Vtransp, [n, n], "svd", "Vtransp")      ! query optimal lwork and allocate workspace:     allocate(work(1))     call zgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, -1,&          rwork, info)     lwork = int(real(work(1)))     deallocate(work)     allocate(work(lwork))      call zgesvd('A', 'A', m, n, At, m, s, U, ldu, Vtransp, n, work, &          lwork, rwork, info)     if(info /= 0) then        print *, "zgesvd returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "ZBDSQR did not converge, there are ", info           print *, "superdiagonals of an intermediate bidiagonal form B"           print *, "did not converge to zero. See the description of WORK"           print *, "in DGESVD's man page for details."        endif        call stop_error('svd: zgesvd error')     endif   end subroutine zsvd    function dcholesky(A) result(L)     ! Computes Cholesky decomposition of A     ! A must by symmetric     ! Only the lower triangular part of A is used.     real(dp), intent(in) :: A(:,:)     real(dp) :: L(size(A,1), size(A,1))     ! LAPACK related:     integer :: info, n, i, j     n = size(A,1)     call assert_shape(A, [n, n], "cholesky", "A")     L = A     call dpotrf("L", n, L, n, info)     if(info /= 0) then        print *, "dpotrf returned info = ", info        if(info < 0) then           print *, "the ", -info, "-th argument had an illegal value"        else           print *, "the leading minor of order", info           print *, "is not positive definite, and the factorization could not"           print *, "be completed."        endif        call stop_error('cholesky: dpotrf error')     endif     do j = 1, n         do i = 1, j-1             L(i,j) = 0         end do     end do   end function dcholesky    subroutine dassert_shape(A, shap, routine, matname)     ! make sure a given real matrix has a given shape     real(dp), intent(in) :: A(:,:)     integer, intent(in) :: shap(:)     character(len=*) :: routine, matname      if(any(shape(A) /= shap)) then        print *, "In routine " // routine // " matrix " // matname // " has illegal shape ", shape(A)        print *, "Shape should be ", shap        call stop_error("Aborting due to illegal matrix operation")     end if   end subroutine dassert_shape    subroutine zassert_shape(A, shap, routine, matname)     ! make sure a given real matrix has a given shape     complex(dp), intent(in) :: A(:,:)     integer, intent(in) :: shap(:)     character(len=*) :: routine, matname      if(any(shape(A) /= shap)) then        print *, "In routine " // routine // " matrix " // matname // " has illegal shape ", shape(A)        print *, "Shape should be ", shap        call stop_error("Aborting due to illegal matrix operation")     end if   end subroutine zassert_shape  subroutine qr_fact(A, Q, R) ! Computes a QR factorization of a real matrix A = Q*R real(dp), intent(in) :: A(:,:) real(dp), intent(out) :: Q(:,:), R(:,:) integer :: i, lwork, info, K real(dp) :: tau(min(size(A,1),size(A,2))), At(size(A,1), size(A,2)) real(dp), allocatable :: work(:) call assert(size(A,1) >= size(A,2)) K = min(size(A,1),size(A,2)) allocate(work(1)) At = A call dgeqrf(size(A,1), size(A,2), At, size(A,1), tau, work, -1, info) call assert(info == 0) lwork = int(work(1)) deallocate(work) allocate(work(lwork)) call dgeqrf(size(A,1), size(A,2), At, size(A,1), tau, work, size(work), info) if (info /= 0) then    print *, "dgeqrf returned info = ", info    if (info < 0) then       print *, "the ", -info, "-th argument had an illegal value"    end if    call stop_error('dgeqrf error') end if R = At(:K,:) do i = 1, size(tau)-1     R(i+1:,i) = 0 end do call dorgqr(size(A,1), size(A,2), size(tau), At, size(A,1), tau, work, -1, info) call assert(info == 0) lwork = int(work(1)) deallocate(work) allocate(work(lwork)) call dorgqr(size(A,1), size(A,2), size(tau), At, size(A,1), tau, work, &     size(work), info) if (info /= 0) then    print *, "dgeqrf returned info = ", info    if (info < 0) then       print *, "the ", -info, "-th argument had an illegal value"    end if    call stop_error('dgeqrf error') end if Q = At end subroutine  end module linalg 
mesh.f90_stripped module mesh  use types, only: dp use utils, only: stop_error  implicit none  private public meshexp, meshexp_der, get_meshexp_pars, meshexp_der2, &     linspace, meshgrid  contains  function meshexp(rmin, rmax, a, N) result(mesh)       real(dp), intent(in) :: rmin, rmax     real(dp), intent(in) :: a   integer, intent(in) :: N      real(dp) :: mesh(N+1)            integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then     alpha = (rmax - rmin) / N     do i = 1, N+1         mesh(i) = alpha * (i-1.0_dp) + rmin     end do else     if (N > 1) then         beta = log(a) / (N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             mesh(i) = alpha * (exp(beta*(i-1)) - 1) + rmin         end do     else if (N == 1) then         mesh(1) = rmin         mesh(2) = rmax     else         call stop_error("meshexp: N >= 1 required")     end if end if end function  function meshexp_der(rmin, rmax, a, N) result(Rp)          real(dp), intent(in) :: rmin real(dp), intent(in) :: rmax real(dp), intent(in) :: a integer, intent(in) :: N real(dp) :: Rp(N+1)  integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp_der: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then      call stop_error("meshexp_der: a == 1 not implemented") else     if (N > 1) then         beta = log(a)/(N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             Rp(i) = alpha * beta * exp(beta*(i-1))         end do     else         call stop_error("meshexp_der: N > 1 required")     end if end if end function  function meshexp_der2(rmin, rmax, a, N) result(Rpp)          real(dp), intent(in) :: rmin real(dp), intent(in) :: rmax real(dp), intent(in) :: a integer, intent(in) :: N real(dp) :: Rpp(N+1)  integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp_der2: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then     call stop_error("meshexp_der2: a == 1 not implemented") else     if (N > 1) then         beta = log(a)/(N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             Rpp(i) = alpha * beta**2 * exp(beta*(i-1))         end do     else         call stop_error("meshexp_der2: N > 1 required")     end if end if end function  subroutine get_meshexp_pars(R, rmin, rmax, a, N)     real(dp), intent(in) :: R(:) real(dp), intent(out) :: rmin, rmax, a integer, intent(out) :: N rmin = R(1) rmax = R(size(R)) a = (R(size(R)) - R(size(R)-1)) / (R(2) - R(1)) N = size(R) - 1 end subroutine  function linspace(a, b, n) result(s) real(dp), intent(in) :: a, b integer, intent(in) :: n real(dp) :: s(n) s = meshexp(a, b, 1.0_dp, n-1) end function  subroutine meshgrid(x, y, x2, y2) real(dp), intent(in) :: x(:), y(:) real(dp), intent(out) :: x2(:, :), y2(:, :) x2 = spread(x, 1, size(y)) y2 = spread(y, 2, size(x)) end subroutine  end module 
mesh.f90_comments module mesh  use types, only: dp use utils, only: stop_error  implicit none  private public meshexp, meshexp_der, get_meshexp_pars, meshexp_der2, &     linspace, meshgrid  contains  function meshexp(rmin, rmax, a, N) result(mesh) ! Generates exponential mesh of N elements on [rmin, rmax] ! ! Arguments ! --------- ! ! The domain [rmin, rmax], the mesh will contain both endpoints: real(dp), intent(in) :: rmin, rmax ! ! The ratio of the rightmost to leftmost element lengths in the mesh (for a > 1 ! this means the "largest/smallest"); The only requirement is a > 0. For a == 1 ! a uniform mesh will be returned: real(dp), intent(in) :: a ! ! The number of elements in the mesh: integer, intent(in) :: N ! ! Returns ! ------- ! ! The generated mesh: real(dp) :: mesh(N+1) ! ! Note: Every exponential mesh is fully determined by the set of parameters ! (rmin, rmax, a, N). Use the get_meshexp_pars() subroutine to obtain them ! from the given mesh. ! ! Example ! ------- ! ! real(dp) :: r(11) ! r = meshexp(0._dp, 50._dp, 1e9_dp, 10)  integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then     alpha = (rmax - rmin) / N     do i = 1, N+1         mesh(i) = alpha * (i-1.0_dp) + rmin     end do else     if (N > 1) then         beta = log(a) / (N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             mesh(i) = alpha * (exp(beta*(i-1)) - 1) + rmin         end do     else if (N == 1) then         mesh(1) = rmin         mesh(2) = rmax     else         call stop_error("meshexp: N >= 1 required")     end if end if end function  function meshexp_der(rmin, rmax, a, N) result(Rp) ! Generates dR/dt where R(t) is the mesh returned by meshexp() ! ! Input parameters the same as for meshexp(). The variable "t" is defined by: ! t = 1, 2, ..., N+1 ! So it describes a uniform mesh, with a step size 1, and the corresponding ! physical points are given by the R(t) array. ! ! Output parameters: !     Rp(N+1) ....... dR/dt real(dp), intent(in) :: rmin real(dp), intent(in) :: rmax real(dp), intent(in) :: a integer, intent(in) :: N real(dp) :: Rp(N+1)  integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp_der: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then      call stop_error("meshexp_der: a == 1 not implemented") else     if (N > 1) then         beta = log(a)/(N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             Rp(i) = alpha * beta * exp(beta*(i-1))         end do     else         call stop_error("meshexp_der: N > 1 required")     end if end if end function  function meshexp_der2(rmin, rmax, a, N) result(Rpp) ! Generates d^R/dt^2 where R(t) is the mesh returned by meshexp() ! ! Input parameters the same as for meshexp(). The variable "t" is defined by: ! t = 1, 2, ..., N+1 ! So it describes a uniform mesh, with a step size 1, and the corresponding ! physical points are given by the R(t) array. ! ! Output parameters: !     Rp(N+1) ....... d^2R/dt^2 real(dp), intent(in) :: rmin real(dp), intent(in) :: rmax real(dp), intent(in) :: a integer, intent(in) :: N real(dp) :: Rpp(N+1)  integer :: i real(dp) :: alpha, beta if (a < 0) then     call stop_error("meshexp_der2: a > 0 required") else if (abs(a - 1) < tiny(1.0_dp)) then     call stop_error("meshexp_der2: a == 1 not implemented") else     if (N > 1) then         beta = log(a)/(N-1)         alpha = (rmax - rmin) / (exp(beta*N) - 1)         do i = 1, N+1             Rpp(i) = alpha * beta**2 * exp(beta*(i-1))         end do     else         call stop_error("meshexp_der2: N > 1 required")     end if end if end function  subroutine get_meshexp_pars(R, rmin, rmax, a, N) ! Given any exponential mesh R, it determines the get_mesh()'s parameters ! ! This only looks at the number of elements, the leftmost and the rightmost ! elements (so the middle elements are not checked/taken into account). real(dp), intent(in) :: R(:) real(dp), intent(out) :: rmin, rmax, a integer, intent(out) :: N rmin = R(1) rmax = R(size(R)) a = (R(size(R)) - R(size(R)-1)) / (R(2) - R(1)) N = size(R) - 1 end subroutine  function linspace(a, b, n) result(s) real(dp), intent(in) :: a, b integer, intent(in) :: n real(dp) :: s(n) s = meshexp(a, b, 1.0_dp, n-1) end function  subroutine meshgrid(x, y, x2, y2) real(dp), intent(in) :: x(:), y(:) real(dp), intent(out) :: x2(:, :), y2(:, :) x2 = spread(x, 1, size(y)) y2 = spread(y, 2, size(x)) end subroutine  end module 
optimize.f90_stripped module optimize    use types, only: dp use utils, only: stop_error implicit none private public bisect,secant  interface     real(dp) function func(x)     import :: dp     implicit none     real(dp), intent(in) :: x     end function end interface  contains  real(dp) function bisect(f, a, b, tol) result(c)  procedure(func) :: f real(dp), intent(in) :: a, b, tol real(dp) :: a_, b_, fa, fb, fc a_ = a; b_ = b fa = f(a_) fb = f(b_) if (fa * fb >= 0) then     call stop_error("bisect: f(a) and f(b) must have opposite signs") end if do while (b_ - a_ > tol)     c = (a_ + b_) / 2     fc = f(c)     if (abs(fc) < tiny(1.0_dp)) return        if (fa * fc < 0) then         b_ = c         fb = fc     else         a_ = c         fa = fc     end if end do c = (a_ + b_)/2 end function  real(dp) function secant(f, a,b,tol, maxiter) result (c)  procedure(func) :: f real(dp),intent(in) :: a,b,tol integer,optional :: maxiter  integer :: maxiter_ real(dp) :: xstart, xnext real(dp) :: fstart, fnext integer ::  i  if(present(maxiter)) then     maxiter_ = maxiter else     maxiter_ = 100 endif   xstart = a xnext = b fstart = f(xstart) if(abs(fstart ) < tiny(1.0_dp)) then     c = xstart     return endif fnext = f(xnext) if(abs(fnext ) < tiny(1.0_dp)) then     c = xnext     return endif  do i = 1, maxiter_          if( abs(fnext - fstart) < tiny(1.0_dp)) then        call stop_error("secant: division by zero")     endif     c = (xstart*fnext - xnext*fstart)/(fnext - fstart)     if (abs(c - xnext) < tol) return           xstart = xnext     fstart = fnext     xnext = c     fnext = f(c) enddo  call stop_error("secant: method did not converge") end function secant       end module 
optimize.f90_comments module optimize  ! Optimization algorithms  use types, only: dp use utils, only: stop_error implicit none private public bisect,secant  interface     real(dp) function func(x)     import :: dp     implicit none     real(dp), intent(in) :: x     end function end interface  contains  real(dp) function bisect(f, a, b, tol) result(c) ! Solves f(x) = 0 on the interval [a, b] using the bisection method procedure(func) :: f real(dp), intent(in) :: a, b, tol real(dp) :: a_, b_, fa, fb, fc a_ = a; b_ = b fa = f(a_) fb = f(b_) if (fa * fb >= 0) then     call stop_error("bisect: f(a) and f(b) must have opposite signs") end if do while (b_ - a_ > tol)     c = (a_ + b_) / 2     fc = f(c)     if (abs(fc) < tiny(1.0_dp)) return   ! We need to make sure f(c) is not zero below     if (fa * fc < 0) then         b_ = c         fb = fc     else         a_ = c         fa = fc     end if end do c = (a_ + b_)/2 end function  real(dp) function secant(f, a,b,tol, maxiter) result (c) !Solves f(x) = 0 on using the a and b as starting values procedure(func) :: f real(dp),intent(in) :: a,b,tol integer,optional :: maxiter  integer :: maxiter_ real(dp) :: xstart, xnext real(dp) :: fstart, fnext integer ::  i  if(present(maxiter)) then     maxiter_ = maxiter else     maxiter_ = 100 endif   xstart = a xnext = b fstart = f(xstart) if(abs(fstart ) < tiny(1.0_dp)) then     c = xstart     return endif fnext = f(xnext) if(abs(fnext ) < tiny(1.0_dp)) then     c = xnext     return endif  do i = 1, maxiter_          if( abs(fnext - fstart) < tiny(1.0_dp)) then        call stop_error("secant: division by zero")     endif     c = (xstart*fnext - xnext*fstart)/(fnext - fstart)     if (abs(c - xnext) < tol) return ! root found      !update variables     xstart = xnext     fstart = fnext     xnext = c     fnext = f(c) enddo !max iterations number reached call stop_error("secant: method did not converge") end function secant       end module 
ppm.f90_stripped module ppm    use utils, only: stop_error implicit none private public loadppm, saveppm  contains  subroutine loadppm(filename, img)  character(len=*), intent(in) :: filename    integer, intent(out), allocatable :: img(:, :, :)  character(len=2) :: signature character :: ccode integer :: w, h, i, j, ncol integer :: u, offset open(newunit=u, file=filename, access="stream", form="formatted", status="old") read(u, '(a2)') signature if (signature /= "P6") call stop_error("Invalid format.") read(u, *) w, h read(u, *) ncol if (ncol /= 255) call stop_error("Unsupported color range.") inquire(u, pos=offset) close(u) open(newunit=u, file=filename, access="stream", status="old")  read(u, pos=offset-1) ccode allocate(img(3, w, h)) do j = h, 1, -1     do i = 1, w         read(u) ccode         img(1, i, j) = iachar(ccode)         read(u) ccode         img(2, i, j) = iachar(ccode)         read(u) ccode         img(3, i, j) = iachar(ccode)     end do end do close(u) end subroutine  subroutine saveppm(filename, img)  character(len=*), intent(in) :: filename    integer, intent(in) :: img(:, :, :)  integer :: h, w, i, j integer :: u open(newunit=u, file=filename, status="replace") w = size(img, 2) h = size(img, 3) write(u, '(a2)') "P6" write(u, '(i0," ",i0)') w, h write(u, '(i0)') 255 do j = h, 1, -1     do i = 1, w         write(u, '(3a1)', advance='no') achar(img(:, i, j))     end do end do close(u) end subroutine  end module 
ppm.f90_comments module ppm  ! Module for reading and saving PPM images.  use utils, only: stop_error implicit none private public loadppm, saveppm  contains  subroutine loadppm(filename, img) ! Loads the image 'img' from 'filename' in PPM format. character(len=*), intent(in) :: filename ! img(c, x, y) is the c-component (c=1,2,3 is R, G, B colors) of the ! (x, y) pixel. The image is in the 1st quadrant, so (1, 1) is the lower left ! corner, (w, h) is the upper right corner. integer, intent(out), allocatable :: img(:, :, :)  character(len=2) :: signature character :: ccode integer :: w, h, i, j, ncol integer :: u, offset open(newunit=u, file=filename, access="stream", form="formatted", status="old") read(u, '(a2)') signature if (signature /= "P6") call stop_error("Invalid format.") read(u, *) w, h read(u, *) ncol if (ncol /= 255) call stop_error("Unsupported color range.") inquire(u, pos=offset) close(u) open(newunit=u, file=filename, access="stream", status="old") ! Move the corrent position to "offset": read(u, pos=offset-1) ccode allocate(img(3, w, h)) do j = h, 1, -1     do i = 1, w         read(u) ccode         img(1, i, j) = iachar(ccode)         read(u) ccode         img(2, i, j) = iachar(ccode)         read(u) ccode         img(3, i, j) = iachar(ccode)     end do end do close(u) end subroutine  subroutine saveppm(filename, img) ! Saves the image 'img' into 'filename' in PPM format. character(len=*), intent(in) :: filename ! img(c, x, y) is the c-component (c=1,2,3 is R, G, B colors) of the ! (x, y) pixel. The image is in the 1st quadrant, so (1, 1) is the lower left ! corner, (w, h) is the upper right corner. integer, intent(in) :: img(:, :, :)  integer :: h, w, i, j integer :: u open(newunit=u, file=filename, status="replace") w = size(img, 2) h = size(img, 3) write(u, '(a2)') "P6" write(u, '(i0," ",i0)') w, h write(u, '(i0)') 255 do j = h, 1, -1     do i = 1, w         write(u, '(3a1)', advance='no') achar(img(:, i, j))     end do end do close(u) end subroutine  end module 
sorting.f90_stripped module sorting     use types, only: dp use utils, only: stop_error implicit none private public sort, sortpairs, argsort   interface argsort     module procedure iargsort, rargsort end interface   interface sort     module procedure sortNums, sortINums, sortVecs end interface   interface sortpairs     module procedure sortNumNumPairs, sortINumCNumPairs, &                      sortNumVecPairs, sortINumVecPairs, sortNumCVecPairs, &                      sortNumMatPairs, sortINumMatPairs end interface  contains  subroutine sortNums(nums)  real(dp), intent(inout):: nums(:)    nums = nums(argsort(nums)) end subroutine  subroutine sortINums(nums)  integer, intent(inout):: nums(:)     nums = nums(argsort(nums)) end subroutine  subroutine sortVecs(vecs)  real(dp), intent(inout):: vecs(:,:)  real(dp) len2(size(vecs,2))          integer i do i=1,size(len2)    len2(i)=dot_product(vecs(:,i),vecs(:,i)) end do call sortpairs(len2,vecs) end subroutine  subroutine sortNumNumPairs(nums1, nums2)  real(dp), intent(inout):: nums1(:), nums2(:)   integer :: a(size(nums1)) if (size(nums1) /= size(nums2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums1) nums1 = nums1(a) nums2 = nums2(a) end subroutine  subroutine sortINumCNumPairs(nums1, nums2)  integer, intent(inout):: nums1(:)             complex(dp), intent(inout):: nums2(:)         integer :: a(size(nums1)) if (size(nums1) /= size(nums2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums1) nums1 = nums1(a) nums2 = nums2(a) end subroutine  subroutine sortNumVecPairs(nums, vecs)  real(dp), intent(inout):: nums(:)    real(dp), intent(inout):: vecs(:,:)  integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortINumVecPairs(nums, vecs)  integer, intent(inout):: nums(:)     real(dp), intent(inout):: vecs(:,:)  integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortNumCVecPairs(nums, vecs)  real(dp), intent(inout):: nums(:)    complex(dp), intent(inout):: vecs(:,:)  integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortNumMatPairs(nums, mats)  real(dp), intent(inout):: nums(:)          real(dp), intent(inout):: mats(:,:,:)      integer :: a(size(nums)) if (size(nums) /= size(mats,3)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) mats = mats(:, :, a) end subroutine  subroutine sortINumMatPairs(nums,mats)  integer, intent(inout):: nums(:)           real(dp), intent(inout):: mats(:,:,:)      integer :: a(size(nums)) if (size(nums) /= size(mats,3)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) mats = mats(:, :, a) end subroutine  function iargsort(a) result(b)      integer, intent(in):: a(:)     integer :: b(size(a))                integer :: N                            integer :: i,imin                       integer :: temp                         integer :: a2(size(a)) a2 = a N=size(a) do i = 1, N     b(i) = i end do do i = 1, N-1          imin = minloc(a2(i:),1) + i - 1           if (imin /= i) then         temp = a2(i); a2(i) = a2(imin); a2(imin) = temp         temp = b(i); b(i) = b(imin); b(imin) = temp     end if end do end function  function rargsort(a) result(b)      real(dp), intent(in):: a(:)    integer :: b(size(a))                integer :: N                            integer :: i,imin                       integer :: temp1                        real(dp) :: temp2 real(dp) :: a2(size(a)) a2 = a N=size(a) do i = 1, N     b(i) = i end do do i = 1, N-1          imin = minloc(a2(i:),1) + i - 1          if (imin /= i) then         temp2 = a2(i); a2(i) = a2(imin); a2(imin) = temp2         temp1 = b(i); b(i) = b(imin); b(imin) = temp1     end if end do end function  end module 
sorting.f90_comments module sorting  ! Module for sorting arrays. ! Based on code written by John E. Pask, LLNL.  use types, only: dp use utils, only: stop_error implicit none private public sort, sortpairs, argsort  ! overload argsort interface argsort     module procedure iargsort, rargsort end interface  ! overload sort interface sort     module procedure sortNums, sortINums, sortVecs end interface  ! overload sortpairs interface sortpairs     module procedure sortNumNumPairs, sortINumCNumPairs, &                      sortNumVecPairs, sortINumVecPairs, sortNumCVecPairs, &                      sortNumMatPairs, sortINumMatPairs end interface  contains  subroutine sortNums(nums) ! sorts array of numbers, nums, from smallest to largest real(dp), intent(inout):: nums(:)   ! array of numbers nums = nums(argsort(nums)) end subroutine  subroutine sortINums(nums) ! sorts array of inegers, nums, from smallest to largest integer, intent(inout):: nums(:)    ! array of numbers nums = nums(argsort(nums)) end subroutine  subroutine sortVecs(vecs) ! sorts array of vectors, vecs, by length, from smallest to largest real(dp), intent(inout):: vecs(:,:) ! array of vectors: vecs(i,j) = ith comp. of jth vec. real(dp) len2(size(vecs,2))         ! array of squares of vector lengths integer i do i=1,size(len2)    len2(i)=dot_product(vecs(:,i),vecs(:,i)) end do call sortpairs(len2,vecs) end subroutine  subroutine sortNumNumPairs(nums1, nums2) ! sorts arrays of numbers, nums1 and nums2, according to increasing nums1 real(dp), intent(inout):: nums1(:), nums2(:)  ! arrays of numbers integer :: a(size(nums1)) if (size(nums1) /= size(nums2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums1) nums1 = nums1(a) nums2 = nums2(a) end subroutine  subroutine sortINumCNumPairs(nums1, nums2) ! sorts arrays of numbers, nums1 and nums2, according to increasing nums1 integer, intent(inout):: nums1(:)            ! array of integers complex(dp), intent(inout):: nums2(:)        ! array of complex numbers integer :: a(size(nums1)) if (size(nums1) /= size(nums2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums1) nums1 = nums1(a) nums2 = nums2(a) end subroutine  subroutine sortNumVecPairs(nums, vecs) ! sorts arrays of numbers, nums, and vectors, vecs, according to increasing nums real(dp), intent(inout):: nums(:)   ! array of numbers real(dp), intent(inout):: vecs(:,:) ! array of vectors: vecs(i,j) = ith comp. of jth vec. integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortINumVecPairs(nums, vecs) ! sorts arrays of integers, nums, and vectors, vecs, according to increasing nums integer, intent(inout):: nums(:)    ! array of numbers real(dp), intent(inout):: vecs(:,:) ! array of vectors: vecs(i,j) = ith comp. of jth vec. integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortNumCVecPairs(nums, vecs) ! sorts arrays of numbers, nums, and complex vectors, vecs, according to increasing nums real(dp), intent(inout):: nums(:)   ! array of numbers complex(dp), intent(inout):: vecs(:,:) ! array of vectors: vecs(i,j) = ith comp. of jth vec. integer :: a(size(nums)) if (size(nums) /= size(vecs,2)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) vecs = vecs(:, a) end subroutine  subroutine sortNumMatPairs(nums, mats) ! sorts arrays of numbers, nums, and matrices, mats, according to increasing nums real(dp), intent(inout):: nums(:)         ! array of numbers real(dp), intent(inout):: mats(:,:,:)     ! array of matrices: mats(i,j,n) = (i,j) comp. of nth mat. integer :: a(size(nums)) if (size(nums) /= size(mats,3)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) mats = mats(:, :, a) end subroutine  subroutine sortINumMatPairs(nums,mats) ! sorts arrays of integers, nums, and matrices, mats, according to increasing nums integer, intent(inout):: nums(:)          ! array of numbers real(dp), intent(inout):: mats(:,:,:)     ! array of matrices: mats(i,j,n) = (i,j) comp. of nth mat. integer :: a(size(nums)) if (size(nums) /= size(mats,3)) then     call stop_error("SORTPAIRS ERROR: arrays must be of same length.") end if a = argsort(nums) nums = nums(a) mats = mats(:, :, a) end subroutine  function iargsort(a) result(b) ! Returns the indices that would sort an array. ! ! Arguments ! --------- ! integer, intent(in):: a(:)    ! array of numbers integer :: b(size(a))         ! indices into the array 'a' that sort it ! ! Example ! ------- ! ! iargsort([10, 9, 8, 7, 6])   ! Returns [5, 4, 3, 2, 1]  integer :: N                           ! number of numbers/vectors integer :: i,imin                      ! indices: i, i of smallest integer :: temp                        ! temporary integer :: a2(size(a)) a2 = a N=size(a) do i = 1, N     b(i) = i end do do i = 1, N-1     ! find ith smallest in 'a'     imin = minloc(a2(i:),1) + i - 1      ! swap to position i in 'a' and 'b', if not already there     if (imin /= i) then         temp = a2(i); a2(i) = a2(imin); a2(imin) = temp         temp = b(i); b(i) = b(imin); b(imin) = temp     end if end do end function  function rargsort(a) result(b) ! Returns the indices that would sort an array. ! ! Arguments ! --------- ! real(dp), intent(in):: a(:)   ! array of numbers integer :: b(size(a))         ! indices into the array 'a' that sort it ! ! Example ! ------- ! ! rargsort([4.1_dp, 2.1_dp, 2.05_dp, -1.5_dp, 4.2_dp]) ! Returns [4, 3, 2, 1, 5]  integer :: N                           ! number of numbers/vectors integer :: i,imin                      ! indices: i, i of smallest integer :: temp1                       ! temporary real(dp) :: temp2 real(dp) :: a2(size(a)) a2 = a N=size(a) do i = 1, N     b(i) = i end do do i = 1, N-1     ! find ith smallest in 'a'     imin = minloc(a2(i:),1) + i - 1     ! swap to position i in 'a' and 'b', if not already there     if (imin /= i) then         temp2 = a2(i); a2(i) = a2(imin); a2(imin) = temp2         temp1 = b(i); b(i) = b(imin); b(imin) = temp1     end if end do end function  end module 
special.f90_stripped module special                  use types, only: dp use constants, only: pi, i_ use utils, only: stop_error use optimize, only: bisect use amos implicit none  private public bessel_jn_zeros, spherical_bessel_jn, spherical_bessel_yn, &        spherical_bessel_jn_zeros, &        besselj, bessely, hankel1, hankel2, besseli, besselk, &          airyai, dairyai, airybi, dairybi     interface besselj     module procedure besseljn_real     module procedure besseljv_real     module procedure besseljv_complex end interface besselj   interface bessely     module procedure besselyn_real     module procedure besselyv_real     module procedure besselyv_complex end interface bessely   interface hankel1     module procedure hankel1n_real     module procedure hankel1v_real     module procedure hankel1v_complex end interface hankel1   interface hankel2     module procedure hankel2n_real     module procedure hankel2v_real     module procedure hankel2v_complex end interface hankel2   interface besseli     module procedure besseliv_real     module procedure besseliv_complex end interface besseli   interface besselk     module procedure besselkv_real     module procedure besselkv_complex end interface besselk  contains  function besseljn_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     real(dp) :: res                 if(abs(order) == 0) then         res = bessel_j0(x)     elseif(abs(order) == 1) then         res = bessel_j1(x)     else         res = bessel_jn(abs(order), x)     endif           res = reflect(order)*res end function besseljn_real   function besseljv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx                                resCmplx = besseljv_complex(order, cmplx(x, 0.0_dp, kind=dp))       res = real(resCmplx)   end function besseljv_real   function besseljv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr           callorder = abs(order)      call zbesj(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BUT LOSSES OF SIGNIFCANCE BY ARGUMENT"             print *, "REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "OF          elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("besselj: zbesj error")     endif           if(order < 0.0_dp) then           res = exp(-pi*i_*callorder)*(resReal(1) + i_*resImag(1)) &             & + i_*sin(pi*callorder)*hankel1(callorder, z)     else         res = resReal(1) +i_*resImag(1)     endif end function besseljv_complex   function besselyn_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     real(dp) :: res                 if(abs(order) == 0) then         res = bessel_y0(x)     elseif(abs(order) == 1) then         res = bessel_y1(x)     else         res = bessel_yn(abs(order), x)     endif     res = reflect(order)*res   end function besselyn_real   function besselyv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besselyv_complex(order, x+0*i_)       res = real(resCmplx) end function besselyv_real   function besselyv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: workr(length), worki(length), resReal(length), resImag(length), callorder     integer :: underflows, ierr           callorder = abs(order)      call zbesy(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, workr, worki, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO              print *, "IS TOO SMALL OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("bessely: zbesy error")     endif      if(order < 0.0_dp) then           res = exp(-callorder*pi*i_)*(resReal(1) + i_*resImag(1)) + &             & sin(pi*callorder)*hankel1(callorder, z)     else         res = resReal(1) + i_*resImag(1)     endif end function besselyv_complex   function hankel1n_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     complex(dp) :: res                                if(order == 0) then         res = bessel_j0(x) + i_*bessel_y0(x)     elseif(abs(order) == 1) then         res = reflect(order)*(bessel_j1(x) + i_*bessel_y1(x))     else         res = reflect(order)*(bessel_jn(order, x) + i_*bessel_yn(order, x))     endif end function hankel1n_real   function hankel1v_real(order, x) result(res)     real(dp), intent(in) :: order, x     complex(dp) :: res      res = hankel1v_complex(order, cmplx(x, 0.0_dp, kind=dp)) end function hankel1v_real   function hankel1v_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1, hankelkind=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesh(real(z), aimag(z), callorder, scaling, hankelkind, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("hankel1: zbesh error")     endif           res = Hrotate(1, order)*(resReal(1) + i_*resImag(1)) end function hankel1v_complex   function hankel2n_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     complex(dp) :: res                 if(abs(order) == 0) then         res = bessel_j0(x) - i_*bessel_y0(x)     elseif(abs(order) == 1) then         res = reflect(order)*(bessel_j1(x) - i_*bessel_y1(x))     else         res = reflect(order)*(bessel_jn(order, x) - i_*bessel_yn(order, x))     endif end function hankel2n_real   function hankel2v_real(order, x) result(res)     real(dp), intent(in) :: order, x     complex(dp) :: res      res = hankel2v_complex(order, cmplx(x, 0.0_dp, kind=dp)) end function hankel2v_real   function hankel2v_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1, hankelkind=2     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesh(real(z), aimag(z), callorder, scaling, hankelkind, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("hankel2: zbesh error")     endif           res = Hrotate(2, order)*(resReal(1) + i_*resImag(1)) end function hankel2v_complex   function besseliv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besseliv_complex(order, x+0*i_)     res = real(resCmplx) end function besseliv_real   function besseliv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesi(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("besseli: zbesi error")     endif           if(order < 0.0_dp) then         res = (resReal(1) + i_*resImag(1)) &             & + 2.0_dp/pi*sin(callorder*pi)*besselk(callorder, z)     else         res = resReal(1) + i_*resImag(1)     endif end function besseliv_complex  function besselkv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besselkv_complex(order, x+0*i_)     res = real(resCmplx) end function besselkv_real   function besselkv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr           callorder = abs(order)      call zbesk(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO              print *, "OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("besselk: zbesk error")     endif     res = resReal(1) + i_*resImag(1) end function besselkv_complex   function bessel_j0_zeros(nzeros, eps) result(zeros)    integer, intent(in) :: nzeros real(dp), intent(in) :: eps  real(dp) :: zeros(nzeros) real(dp) :: points(0:nzeros) integer :: n, j           points = [ (n*pi, n = 0, nzeros) ] do j = 1, nzeros     zeros(j) = bisect(f, points(j-1), points(j), eps) end do  contains  real(dp) function f(x) real(dp), intent(in) :: x f = bessel_j0(x) end function  end function   function bessel_jn_zeros(nmax, nzeros, eps) result(zeros)    integer, intent(in) :: nmax, nzeros real(dp), intent(in) :: eps  real(dp) :: zeros(nzeros, 0:nmax)  real(dp) :: points(nmax+nzeros) integer :: n, j points = bessel_j0_zeros(nmax + nzeros, eps) zeros(:, 0) = points(:nzeros) do n = 1, nmax     do j = 1, nmax + nzeros - n         points(j) = bisect(f, points(j), points(j+1), eps)     end do     zeros(:, n) = points(:nzeros) end do  contains  real(dp) function f(x) real(dp), intent(in) :: x f = bessel_jn(n, x) end function  end function   real(dp) function spherical_bessel_jn(n, x) result(r) integer, intent(in) :: n real(dp), intent(in) :: x integer :: nm real(dp) :: sj(0:n), dj(0:n) call sphj(n, x, nm, sj, dj) if (nm /= n) call stop_error("spherical_bessel_jn: sphj didn't converge") r = sj(n) end function  real(dp) function spherical_bessel_yn(n, x) result(r) integer, intent(in) :: n real(dp), intent(in) :: x integer :: nm real(dp) :: sy(0:n), dy(0:n) call sphy(n, x, nm, sy, dy) if (nm /= n) call stop_error("spherical_bessel_yn: sphy didn't converge") r = sy(n) end function   function spherical_bessel_jn_zeros(nmax, nzeros, eps) result(zeros)    integer, intent(in) :: nmax, nzeros real(dp), intent(in) :: eps  real(dp) :: zeros(nzeros, 0:nmax)  real(dp) :: points(nmax+nzeros) integer :: n, j points = [ (n*pi, n = 1, nmax + nzeros) ] zeros(:, 0) = points(:nzeros) do n = 1, nmax     do j = 1, nmax + nzeros - n         points(j) = bisect(f, points(j), points(j+1), eps)     end do     zeros(:, n) = points(:nzeros) end do  contains      real(dp) function f(x)         real(dp), intent(in) :: x         f = spherical_bessel_jn(n, x)     end function f  end function              SUBROUTINE SPHJ(N,X,NM,SJ,                      IMPLICIT          IMPLICIT integer (I-N)                  NM=N         IF (                           SJ(K)=0.0D0                10         END             SJ(0)=1.0D0            IF (N.GT.0) THEN                           ENDIF            RETURN         ENDIF         SJ(0)=                  IF (N.LT.1) THEN            RETURN         ENDIF         SJ(1)=(SJ(0)-         IF (N.GE.2) THEN            SA=SJ(0)            SB=SJ(1)            M=MSTA1(X,200)            IF (M.LT.N) THEN               NM=M            ELSE               M=MSTA2(X,N,15)            ENDIF            F=0.0D0            F0=0.0D0            F1=1.0D0-100                           F=(2.0D0*K+3.0D0)*F1/X-F0               IF (K.LE.NM) SJ(K)=F               F0=F1               F1=F 15         END                         IF (            IF (                           SJ(K)= 20         END          ENDIF                      25      END          RETURN         END          SUBROUTINE SPHY(N,X,NM,SY,                   IMPLICIT          IMPLICIT integer (I-N)                  NM=N         IF (X.LT.1.0D-60) THEN                           SY(K)=-1.0D+300                10         END             RETURN         ENDIF         SY(0)=-         F0=SY(0)                  IF (N.LT.1) THEN            RETURN         ENDIF         SY(1)=(SY(0)-         F1=SY(1)                     F=(2.0D0*K-1.0D0)*F1/X-F0            SY(K)=F            IF (            F0=F1            F1=F 15      END  20      NM=K-1                      25      END          RETURN         END          INTEGER FUNCTION MSTA1(X,MP)                  IMPLICIT          IMPLICIT integer (I-N)         A0=         N0=INT(1.1D0*A0)+1         F0=ENVJ(N0,A0)-MP         N1=N0+5         F1=ENVJ(N1,A0)-MP                     NN=int(N1-(N1-N0)/(1.0D0-F0/F1))            F=ENVJ(NN,A0)-MP            IF(ABS(NN-N1).LT.1) GO TO 20            N0=N1            F0=F1            N1=NN            F1=F  10     END   20     MSTA1=NN         RETURN         END          INTEGER FUNCTION MSTA2(X,N,MP)                   IMPLICIT          IMPLICIT integer (I-N)         A0=         HMP=0.5D0*MP         EJN=ENVJ(N,A0)         IF (EJN.LE.HMP) THEN            OBJ=MP            N0=INT(1.1D0*A0)+1         ELSE            OBJ=HMP+EJN            N0=N         ENDIF         F0=ENVJ(N0,A0)-OBJ         N1=N0+5         F1=ENVJ(N1,A0)-OBJ                     NN=int(N1-(N1-N0)/(1.0D0-F0/F1))            F=ENVJ(NN,A0)-OBJ            IF (ABS(NN-N1).LT.1) GO TO 20            N0=N1            F0=F1            N1=NN            F1=F 10      END  20      MSTA2=NN+10         RETURN         END          real(dp) function envj(n, x) result(r)         integer, intent(in) :: n         real(dp), intent(in) :: x         r = log10(6.28_dp*n)/2 - n*log10(1.36_dp*x/n)         end function    function airyai(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: underflow, ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=0, scaling=1        call zairy(real(z), aimag(z), deriv, scaling, resReal, resImag, underflow, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("airyai: zairy error")     endif     res = resReal + i_*resImag end function airyai    function dairyai(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: underflow, ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=1, scaling=1        call zairy(real(z), aimag(z), deriv, scaling, resReal, resImag, underflow, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function dairyai    function airybi(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=0, scaling=1        call zbiry(real(z), aimag(z), deriv, scaling, resReal, resImag, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function airybi    function dairybi(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=1, scaling=1        call zbiry(real(z), aimag(z), deriv, scaling, resReal, resImag, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO          elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO          elseif(ierr == 3) then             print *, "IERR=3,              print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4,              print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO          endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function dairybi   function Hrotate(hkind, order) result(factor)     integer, intent(in) :: hkind     real(dp), intent(in) :: order     complex(dp) :: factor                 if(order < 0.0_dp) then         if(hkind == 1) then             factor = exp(-pi*order*i_)         elseif(hkind == 2) then             factor = exp(pi*order*i_)         endif     else         factor = (1.0_dp, 0.0_dp)     endif  end function Hrotate   function reflect(order) result(res)     integer, intent(in) :: order     integer :: res      if(order < 0) then         res = (-1)**order     else         res = 1     endif end function  end module 
special.f90_comments module special  ! Special functions: ! This module offers some special functions such as !- spherical Bessel functions !- zeros of real Bessel functions !- Bessel and Hankel functions of complex argument (wrapping the AMOS library !   from http://netlib.org/amos) !- Airy functions Ai and Bi  ! Note on the AMOS wrappers: the AMOS routines generally offer the possibility ! of exponential scaling to remove exponential asymptotic behaviour. ! We do not expose the corresponding switches to the user, however, it is ! straight forward to add those.  ! All references labelled with "NIST" refer to the NIST Handbook of ! Mathematical Functions (2010)  use types, only: dp use constants, only: pi, i_ use utils, only: stop_error use optimize, only: bisect use amos implicit none  private public bessel_jn_zeros, spherical_bessel_jn, spherical_bessel_yn, &        spherical_bessel_jn_zeros, &        besselj, bessely, hankel1, hankel2, besseli, besselk, &  ! note the missing underscores in Bessel functions        airyai, dairyai, airybi, dairybi  ! Airy functions Ai and Bi and their derivatives  ! Bessel J function (first kind) interface besselj     module procedure besseljn_real     module procedure besseljv_real     module procedure besseljv_complex end interface besselj  ! Bessel Y function (second kind) interface bessely     module procedure besselyn_real     module procedure besselyv_real     module procedure besselyv_complex end interface bessely  ! Hankel H function of first kind interface hankel1     module procedure hankel1n_real     module procedure hankel1v_real     module procedure hankel1v_complex end interface hankel1  ! Hankel H function of second kind interface hankel2     module procedure hankel2n_real     module procedure hankel2v_real     module procedure hankel2v_complex end interface hankel2  ! modified Bessel function of first kind interface besseli     module procedure besseliv_real     module procedure besseliv_complex end interface besseli  ! modified Bessel function of second kind interface besselk     module procedure besselkv_real     module procedure besselkv_complex end interface besselk  contains  function besseljn_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     real(dp) :: res      ! convenience function that calls Bessel functions of integer order     ! (intrinsic to F2008)      if(abs(order) == 0) then         res = bessel_j0(x)     elseif(abs(order) == 1) then         res = bessel_j1(x)     else         res = bessel_jn(abs(order), x)     endif      ! apply negative order NIST eq. (10.4.1) if needed:     res = reflect(order)*res end function besseljn_real   function besseljv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      ! here, we do rely in an informed user: if the user wanted Bessel functions     ! of integer order n, he/she should call bessel_jn() (as of F2008) directly.     ! Hence, here we just convert the argument to a complex number and call the     ! AMOS routine     ! TODO: on the long run, wrap the cephes routines!      resCmplx = besseljv_complex(order, cmplx(x, 0.0_dp, kind=dp))  ! negative order is handled in the routine called     res = real(resCmplx)  ! Bessel functions of real arument are real end function besseljv_real   function besseljv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      ! make sure AMOS zbesj() is called with postive order     callorder = abs(order)      call zbesj(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, AIMAG(Z) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE"             print *, "BUT LOSSES OF SIGNIFCANCE BY ARGUMENT"             print *, "REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE"             print *, "OF COMPLETE LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("besselj: zbesj error")     endif      ! take care of negative order if needed:     if(order < 0.0_dp) then  ! use NIST eq. (10.4.7):         res = exp(-pi*i_*callorder)*(resReal(1) + i_*resImag(1)) &             & + i_*sin(pi*callorder)*hankel1(callorder, z)     else         res = resReal(1) +i_*resImag(1)     endif end function besseljv_complex   function besselyn_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     real(dp) :: res      ! convenience function that calls Bessel functions of integer order     ! (intrinsic to F2008)      if(abs(order) == 0) then         res = bessel_y0(x)     elseif(abs(order) == 1) then         res = bessel_y1(x)     else         res = bessel_yn(abs(order), x)     endif     res = reflect(order)*res  ! apply negative order eq. (10.4.1) from NIST end function besselyn_real   function besselyv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besselyv_complex(order, x+0*i_)  ! neg. order handled in the routine called     res = real(resCmplx) end function besselyv_real   function besselyv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: workr(length), worki(length), resReal(length), resImag(length), callorder     integer :: underflows, ierr      ! make sure AMOS zbesy() is called with positive order:     callorder = abs(order)      call zbesy(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, workr, worki, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, FNU IS TOO LARGE OR CABS(Z)"             print *, "IS TOO SMALL OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("bessely: zbesy error")     endif      if(order < 0.0_dp) then  ! apply NIST eq. (10.4.7)         res = exp(-callorder*pi*i_)*(resReal(1) + i_*resImag(1)) + &             & sin(pi*callorder)*hankel1(callorder, z)     else         res = resReal(1) + i_*resImag(1)     endif end function besselyv_complex   function hankel1n_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     complex(dp) :: res      ! There are two linearly independent solutions to Bessel's equation.     ! Thus, the two Hankel functions can be written as superpositions of     ! J and Y, which are taken to be the two linearly independent ones.     ! NIST Handbook (10.4.3)      ! negative order is taken care of according to NIST eq. (10.4.2)     if(order == 0) then         res = bessel_j0(x) + i_*bessel_y0(x)     elseif(abs(order) == 1) then         res = reflect(order)*(bessel_j1(x) + i_*bessel_y1(x))     else         res = reflect(order)*(bessel_jn(order, x) + i_*bessel_yn(order, x))     endif end function hankel1n_real   function hankel1v_real(order, x) result(res)     real(dp), intent(in) :: order, x     complex(dp) :: res      res = hankel1v_complex(order, cmplx(x, 0.0_dp, kind=dp)) end function hankel1v_real   function hankel1v_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1, hankelkind=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesh(real(z), aimag(z), callorder, scaling, hankelkind, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, FNU TOO LARGE OR CABS(Z) TOO SMALL OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("hankel1: zbesh error")     endif      ! take care of negative orders if needed:     res = Hrotate(1, order)*(resReal(1) + i_*resImag(1)) end function hankel1v_complex   function hankel2n_real(order, x) result(res)     integer, intent(in) :: order     real(dp), intent(in) :: x     complex(dp) :: res      ! convenience function that calls Bessel functions of integer order     ! (intrinsic to F2008)      if(abs(order) == 0) then         res = bessel_j0(x) - i_*bessel_y0(x)     elseif(abs(order) == 1) then         res = reflect(order)*(bessel_j1(x) - i_*bessel_y1(x))     else         res = reflect(order)*(bessel_jn(order, x) - i_*bessel_yn(order, x))     endif end function hankel2n_real   function hankel2v_real(order, x) result(res)     real(dp), intent(in) :: order, x     complex(dp) :: res      res = hankel2v_complex(order, cmplx(x, 0.0_dp, kind=dp)) end function hankel2v_real   function hankel2v_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1, hankelkind=2     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesh(real(z), aimag(z), callorder, scaling, hankelkind, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, FNU TOO LARGE OR CABS(Z) TOO SMALL OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("hankel2: zbesh error")     endif      ! take care of neg. orders by Hrotate() if needed:     res = Hrotate(2, order)*(resReal(1) + i_*resImag(1)) end function hankel2v_complex   function besseliv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besseliv_complex(order, x+0*i_)     res = real(resCmplx) end function besseliv_real   function besseliv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      callorder = abs(order)      call zbesi(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, REAL(Z) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("besseli: zbesi error")     endif      ! negative order from NIST Handbook, (10.27.2)     if(order < 0.0_dp) then         res = (resReal(1) + i_*resImag(1)) &             & + 2.0_dp/pi*sin(callorder*pi)*besselk(callorder, z)     else         res = resReal(1) + i_*resImag(1)     endif end function besseliv_complex  function besselkv_real(order, x) result(res)     real(dp), intent(in) :: order, x     real(dp) :: res     complex(dp) :: resCmplx      resCmplx = besselkv_complex(order, x+0*i_)     res = real(resCmplx) end function besselkv_real   function besselkv_complex(order, z) result(res)     real(dp), intent(in) :: order     complex(dp), intent(in) :: z     complex(dp) :: res      integer, parameter :: scaling=1, length=1     real(dp) :: resReal(length), resImag(length), callorder     integer :: underflows, ierr      ! K_{-v} = K_v; NIST Handbook (10.27.3)     callorder = abs(order)      call zbesk(real(z), aimag(z), callorder, scaling, length, resReal, resImag, underflows, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, FNU IS TOO LARGE OR CABS(Z) IS TOO SMALL"             print *, "OR BOTH"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) OR FNU+N-1 LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) OR FNU+N-1 TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("besselk: zbesk error")     endif     res = resReal(1) + i_*resImag(1) end function besselkv_complex   function bessel_j0_zeros(nzeros, eps) result(zeros) ! Calculates zeros of bessel_j0(). ! This function is then used in bessel_jn_zeros() to calculate zeros of j_n(x) ! for n > 0 by simply using the zeros of j_{n-1}(x), as they must lie between. integer, intent(in) :: nzeros real(dp), intent(in) :: eps ! zeros(i) is the i-th zero of bessel_j0(x) real(dp) :: zeros(nzeros) real(dp) :: points(0:nzeros) integer :: n, j ! The zeros of j0(x) must lie between the 'points', as can be shown by: ! !   In [97]: n = 100000; arange(1, n+1) * pi - scipy.special.jn_zeros(0, n) !   Out[97]: !   array([ 0.7367671 ,  0.7631072 ,  0.77105005, ...,  0.78539777, !           0.78539777,  0.78539777]) ! ! For large "x", the asymptotic is j0(x) ~ cos(x - ...), so there it holds and ! for small 'x', it just happens to be the case numerically (see above).  points = [ (n*pi, n = 0, nzeros) ] do j = 1, nzeros     zeros(j) = bisect(f, points(j-1), points(j), eps) end do  contains  real(dp) function f(x) real(dp), intent(in) :: x f = bessel_j0(x) end function  end function   function bessel_jn_zeros(nmax, nzeros, eps) result(zeros) ! Calculates 'nzeros' zeros of bessel_jn() for all n=0, 1, ..., nmax ! It uses the fact that zeros of j_{n-1}(x) lie between zeros of j_n(x) and ! uses bisection to calculate them. integer, intent(in) :: nmax, nzeros real(dp), intent(in) :: eps ! zeros(i, n) is the i-th zero of bessel_jn(n, x) real(dp) :: zeros(nzeros, 0:nmax) ! points holds all zeros of j_{n-1} needed for j_n real(dp) :: points(nmax+nzeros) integer :: n, j points = bessel_j0_zeros(nmax + nzeros, eps) zeros(:, 0) = points(:nzeros) do n = 1, nmax     do j = 1, nmax + nzeros - n         points(j) = bisect(f, points(j), points(j+1), eps)     end do     zeros(:, n) = points(:nzeros) end do  contains  real(dp) function f(x) real(dp), intent(in) :: x f = bessel_jn(n, x) end function  end function   real(dp) function spherical_bessel_jn(n, x) result(r) integer, intent(in) :: n real(dp), intent(in) :: x integer :: nm real(dp) :: sj(0:n), dj(0:n) call sphj(n, x, nm, sj, dj) if (nm /= n) call stop_error("spherical_bessel_jn: sphj didn't converge") r = sj(n) end function  real(dp) function spherical_bessel_yn(n, x) result(r) integer, intent(in) :: n real(dp), intent(in) :: x integer :: nm real(dp) :: sy(0:n), dy(0:n) call sphy(n, x, nm, sy, dy) if (nm /= n) call stop_error("spherical_bessel_yn: sphy didn't converge") r = sy(n) end function   function spherical_bessel_jn_zeros(nmax, nzeros, eps) result(zeros) ! Calculates 'nzeros' zeros of spherical_bessel_jn() for all n=0, 1, ..., nmax ! It uses the fact that zeros of j_{n-1}(x) lie between zeros of j_n(x) and ! uses bisection to calculate them. integer, intent(in) :: nmax, nzeros real(dp), intent(in) :: eps ! zeros(i, n) is the i-th zero of spherical_bessel_jn(n, x) real(dp) :: zeros(nzeros, 0:nmax) ! points holds all zeros of j_{n-1} needed for j_n real(dp) :: points(nmax+nzeros) integer :: n, j points = [ (n*pi, n = 1, nmax + nzeros) ] zeros(:, 0) = points(:nzeros) do n = 1, nmax     do j = 1, nmax + nzeros - n         points(j) = bisect(f, points(j), points(j+1), eps)     end do     zeros(:, n) = points(:nzeros) end do  contains      real(dp) function f(x)         real(dp), intent(in) :: x         f = spherical_bessel_jn(n, x)     end function f  end function   ! The SPHJ, SPHY, MSTA1, MSTA2 routines below are taken from SciPy's specfun.f. ! Authors: Shanjie Zhang and Jianming Jin ! Copyrighted but permission granted to use code in programs.         SUBROUTINE SPHJ(N,X,NM,SJ,DJ) !       ======================================================= !       Purpose: Compute spherical Bessel functions jn(x) and !                their derivatives !       Input :  x --- Argument of jn(x) !                n --- Order of jn(x)  ( n = 0,1, ) !       Output:  SJ(n) --- jn(x) !                DJ(n) --- jn'(x) !                NM --- Highest order computed !       Routines called: !                MSTA1 and MSTA2 for computing the starting !                point for backward recurrence !       ======================================================= !         IMPLICIT DOUBLE PRECISION (A-H,O-Z)         IMPLICIT integer (I-N)         DIMENSION SJ(0:N),DJ(0:N)         NM=N         IF (DABS(X).LT.1.0D-100) THEN            DO 10 K=0,N               SJ(K)=0.0D0               DJ(K)=0.0D0 10         END DO            SJ(0)=1.0D0            IF (N.GT.0) THEN               DJ(1)=.3333333333333333D0            ENDIF            RETURN         ENDIF         SJ(0)=DSIN(X)/X         DJ(0)=(DCOS(X)-DSIN(X)/X)/X         IF (N.LT.1) THEN            RETURN         ENDIF         SJ(1)=(SJ(0)-DCOS(X))/X         IF (N.GE.2) THEN            SA=SJ(0)            SB=SJ(1)            M=MSTA1(X,200)            IF (M.LT.N) THEN               NM=M            ELSE               M=MSTA2(X,N,15)            ENDIF            F=0.0D0            F0=0.0D0            F1=1.0D0-100            DO 15 K=M,0,-1               F=(2.0D0*K+3.0D0)*F1/X-F0               IF (K.LE.NM) SJ(K)=F               F0=F1               F1=F 15         END DO            CS=0.0D0            IF (DABS(SA).GT.DABS(SB)) CS=SA/F            IF (DABS(SA).LE.DABS(SB)) CS=SB/F0            DO 20 K=0,NM               SJ(K)=CS*SJ(K) 20         END DO         ENDIF         DO 25 K=1,NM            DJ(K)=SJ(K-1)-(K+1.0D0)*SJ(K)/X 25      END DO         RETURN         END          SUBROUTINE SPHY(N,X,NM,SY,DY) !       ====================================================== !       Purpose: Compute spherical Bessel functions yn(x) and !                their derivatives !       Input :  x --- Argument of yn(x) ( x  0 ) !                n --- Order of yn(x) ( n = 0,1, ) !       Output:  SY(n) --- yn(x) !                DY(n) --- yn'(x) !                NM --- Highest order computed !       ====================================================== !         IMPLICIT DOUBLE PRECISION (A-H,O-Z)         IMPLICIT integer (I-N)         DIMENSION SY(0:N),DY(0:N)         NM=N         IF (X.LT.1.0D-60) THEN            DO 10 K=0,N               SY(K)=-1.0D+300               DY(K)=1.0D+300 10         END DO            RETURN         ENDIF         SY(0)=-DCOS(X)/X         F0=SY(0)         DY(0)=(DSIN(X)+DCOS(X)/X)/X         IF (N.LT.1) THEN            RETURN         ENDIF         SY(1)=(SY(0)-DSIN(X))/X         F1=SY(1)         DO 15 K=2,N            F=(2.0D0*K-1.0D0)*F1/X-F0            SY(K)=F            IF (DABS(F).GE.1.0D+300) GO TO 20            F0=F1            F1=F 15      END DO 20      NM=K-1         DO 25 K=1,NM            DY(K)=SY(K-1)-(K+1.0D0)*SY(K)/X 25      END DO         RETURN         END          INTEGER FUNCTION MSTA1(X,MP) !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that the magnitude of !                Jn(x) at that point is about 10^(-MP) !       Input :  x     --- Argument of Jn(x) !                MP    --- Value of magnitude !       Output:  MSTA1 --- Starting point !       =================================================== !         IMPLICIT DOUBLE PRECISION (A-H,O-Z)         IMPLICIT integer (I-N)         A0=DABS(X)         N0=INT(1.1D0*A0)+1         F0=ENVJ(N0,A0)-MP         N1=N0+5         F1=ENVJ(N1,A0)-MP         DO 10 IT=1,20            NN=int(N1-(N1-N0)/(1.0D0-F0/F1))            F=ENVJ(NN,A0)-MP            IF(ABS(NN-N1).LT.1) GO TO 20            N0=N1            F0=F1            N1=NN            F1=F  10     END DO  20     MSTA1=NN         RETURN         END          INTEGER FUNCTION MSTA2(X,N,MP) !       =================================================== !       Purpose: Determine the starting point for backward !                recurrence such that all Jn(x) has MP !                significant digits !       Input :  x  --- Argument of Jn(x) !                n  --- Order of Jn(x) !                MP --- Significant digit !       Output:  MSTA2 --- Starting point !       =================================================== !         IMPLICIT DOUBLE PRECISION (A-H,O-Z)         IMPLICIT integer (I-N)         A0=DABS(X)         HMP=0.5D0*MP         EJN=ENVJ(N,A0)         IF (EJN.LE.HMP) THEN            OBJ=MP            N0=INT(1.1D0*A0)+1         ELSE            OBJ=HMP+EJN            N0=N         ENDIF         F0=ENVJ(N0,A0)-OBJ         N1=N0+5         F1=ENVJ(N1,A0)-OBJ         DO 10 IT=1,20            NN=int(N1-(N1-N0)/(1.0D0-F0/F1))            F=ENVJ(NN,A0)-OBJ            IF (ABS(NN-N1).LT.1) GO TO 20            N0=N1            F0=F1            N1=NN            F1=F 10      END DO 20      MSTA2=NN+10         RETURN         END          real(dp) function envj(n, x) result(r)         integer, intent(in) :: n         real(dp), intent(in) :: x         r = log10(6.28_dp*n)/2 - n*log10(1.36_dp*x/n)         end function   ! Ai(z) function airyai(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: underflow, ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=0, scaling=1  ! compute unscaled Ai(z)      call zairy(real(z), aimag(z), deriv, scaling, resReal, resImag, underflow, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, REAL(ZTA) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("airyai: zairy error")     endif     res = resReal + i_*resImag end function airyai   ! d(Ai(z))/dz function dairyai(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: underflow, ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=1, scaling=1  ! compute unscaled d(Ai(z))/dz      call zairy(real(z), aimag(z), deriv, scaling, resReal, resImag, underflow, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, REAL(ZTA) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function dairyai   ! Bi(z) function airybi(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=0, scaling=1  ! compute unscaled Bi(z)      call zbiry(real(z), aimag(z), deriv, scaling, resReal, resImag, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, REAL(Z) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function airybi   ! d(Bi(z))/dz function dairybi(z) result(res)     implicit none     complex(dp), intent(in) :: z     complex(dp) :: res      integer :: ierr     real(dp) :: resReal, resImag     integer, parameter :: deriv=1, scaling=1  ! compute unscaled d(Bi(z))/dz      call zbiry(real(z), aimag(z), deriv, scaling, resReal, resImag, ierr)     if(ierr > 0) then         if(ierr == 1) then             print *, "IERR=1, INPUT ERROR - NO COMPUTATION"         elseif(ierr == 2) then             print *, "IERR=2, OVERFLOW - NO COMPUTATION, REAL(Z) TOO LARGE ON KODE=1"         elseif(ierr == 3) then             print *, "IERR=3, CABS(Z) LARGE - COMPUTATION DONE BUT LOSSES OF SIGNIFCANCE"             print *, "BY ARGUMENT REDUCTION PRODUCE LESS THAN HALF OF MACHINE ACCURACY"         elseif(ierr == 4) then             print *, "IERR=4, CABS(Z) TOO LARGE - NO COMPUTATION BECAUSE OF COMPLETE"             print *, "LOSSES OF SIGNIFICANCE BY ARGUMENT REDUCTION"         elseif(ierr == 5) then             print *, "IERR=5, ERROR - NO COMPUTATION ALGORITHM TERMINATION CONDITION NOT MET"         endif         call stop_error("dairyai: zairy error")     endif     res = resReal + i_*resImag end function dairybi  ! rotate Hankel functions of negative order: function Hrotate(hkind, order) result(factor)     integer, intent(in) :: hkind     real(dp), intent(in) :: order     complex(dp) :: factor      ! NIST Handbook, 10.4.6; note the signs in the exponents     ! (NIST gives formulas for order -v with positive v, our 'order' here is negative)      if(order < 0.0_dp) then         if(hkind == 1) then             factor = exp(-pi*order*i_)         elseif(hkind == 2) then             factor = exp(pi*order*i_)         endif     else         factor = (1.0_dp, 0.0_dp)     endif  end function Hrotate  ! 'reflect' negative integer order Bessel functions if needed function reflect(order) result(res)     integer, intent(in) :: order     integer :: res      if(order < 0) then         res = (-1)**order     else         res = 1     endif end function  end module 
splines.f90_stripped module splines                 use types, only: dp use lapack, only: dgesv, dgbsv use utils, only: stop_error implicit none private public spline3pars, spline3valder, iix, iixmin, iixun, iixexp, poly3, dpoly3, &     d2poly3, spline3, spline3ders  contains  function spline3(x, y, xnew) result(ynew)     real(dp), intent(in) :: x(:), y(:), xnew(:) real(dp) :: ynew(size(xnew)) real(dp) :: c(0:4, size(x)-1) integer :: i, ip  call spline3pars(x, y, [2, 2], [0._dp, 0._dp], c)  ip = 0 do i = 1, size(xnew)     ip = iixmin(xnew(i), x, ip)     ynew(i) = poly3(xnew(i), c(:, ip)) end do end function  subroutine spline3ders(x, y, xnew, ynew, dynew, d2ynew)  real(dp), intent(in) :: x(:), y(:), xnew(:) real(dp), intent(out), optional :: ynew(:), dynew(:), d2ynew(:) real(dp) :: c(0:4, size(x)-1) integer :: i, ip call spline3pars(x, y, [2, 2], [0._dp, 0._dp], c)  ip = 0 do i = 1, size(xnew)     ip = iixmin(xnew(i), x, ip)     if (present(  ynew))   ynew(i) =   poly3(xnew(i), c(:, ip))     if (present( dynew))  dynew(i) =  dpoly3(xnew(i), c(:, ip))     if (present(d2ynew)) d2ynew(i) = d2poly3(xnew(i), c(:, ip)) end do end subroutine  subroutine spline3pars(xi,yi,bctype,bcval,c)   real(dp), intent(in):: xi(:)         real(dp), intent(in):: yi(:)         integer, intent(in):: bctype(2)              real(dp), intent(in):: bcval(2)          real(dp), intent(out):: c(0:,:)              real(dp) As(5,2*size(c,2))              real(dp) bs(2*size(c,2))                real(dp) cs(2*size(c,2))                real(dp) hi(size(c,2))                  real(dp) Ae(4,4)                        real(dp) be(4)                          real(dp) ce(4)                          real(dp) xe(4),ye(4)                    real(dp) d2p1,d2pn                      real(dp) x0                             real(dp) c1,c2,c3,c4                    integer n                               integer i,j,i2  integer ipiv(4),ipiv2(2*size(c,2)) real(dp) bemat(4,1),bmat(2*size(c,2),1) integer info   if (bctype(1) < 1 .or. bctype(1) > 2) call stop_error("spline3pars error: bctype /= 1 or 2.") if (bctype(2) < 1 .or. bctype(2) > 2) call stop_error("spline3pars error: bctype /= 1 or 2.") if (size(c,1) /= 5) call stop_error("spline3pars error: size(c,1) /= 5.") if (size(c,2) /= size(xi)-1) call stop_error("spline3pars error: size(c,2) /= size(xi)-1.") if (size(xi) /= size(yi)) call stop_error("spline3pars error: size(xi) /= size(yi)")   d2p1 = 0 d2pn = 0   n=size(xi) do i=1,n-1    hi(i)=xi(i+1)-xi(i) end do       if(bctype(1)==2) then    if (n < 4) call stop_error("spline3pars error: n < 4")    xe=xi(1:4)    ye=yi(1:4)    x0=xe(1)     do i=1,4       do j=1,4          Ae(i,j) = (xe(i)-x0)**(j-1)       end do    end do    Ae(:,1) = 1        be=ye; bemat(:,1)=be    call dgesv(4, 1, Ae, 4, ipiv, bemat, 4, info)    if (info /= 0) call stop_error("spline3pars error: dgesv error.")    ce=bemat(:,1)    d2p1=2*ce(3) end if     if(bctype(2)==2) then    if (n < 4) call stop_error("spline3pars error: n < 4")    xe=xi(n-3:n)    ye=yi(n-3:n)    x0=xe(4)     do i=1,4       do j=1,4          Ae(i,j) = (xe(i)-x0)**(j-1)       end do    end do    Ae(:,1) = 1        be=ye; bemat(:,1)=be    call dgesv(4, 1, Ae, 4, ipiv, bemat, 4, info)    if (info /= 0) call stop_error("spline3pars error: dgesv error.")    ce=bemat(:,1)    d2pn=2*ce(3) end if   if(bctype(1)==1) d2p1=bcval(1) if(bctype(2)==1) d2pn=bcval(2)       As=0      As(4,1)=6/hi(1)**2 bs(1)=d2p1     do i=2,n-1    i2=2*(i-1)          As(5,i2-1) = 1/hi(i-1)    As(4,i2)   = 2/hi(i-1)    As(3,i2+1) = 2/hi(i)    As(2,i2+2) = 1/hi(i)    As(5,i2)   = 1/hi(i-1)**2    As(4,i2+1) = -1/hi(i)**2    bs(i2) = (yi(i+1) - yi(i))/hi(i) - (yi(i) - yi(i-1))/hi(i-1)    bs(i2+1) = 0 end do      As(4,2*(n-1))=6/hi(n-1)**2 bs(2*(n-1))=d2pn         bmat(:,1)=bs call dgbsv(2*(n-1), 1, 2, 1, As, 5, ipiv2, bmat, 2*(n-1), info) if (info /= 0) call stop_error("spline3pars error: dgbsv error.") cs=bmat(:,1)     do i=1,n-1        c1=yi(i)    c2=yi(i+1)    c3=cs(2*i-1)    c4=cs(2*i)        c(0,i)=xi(i)    c(1,i)=c1    c(2,i)=-(c1-c2+2*c3+c4)/hi(i)    c(3,i)=3*c3/hi(i)**2    c(4,i)=(-c3+c4)/hi(i)**3 end do end subroutine    subroutine spline3valder(x,xi,c,val,der)   real(dp), intent(in):: x             real(dp), intent(in):: xi(:)         real(dp), intent(in):: c(0:,:)               real(dp), intent(out):: val          real(dp), intent(out):: der          integer n                            integer i1   n=size(xi) if (size(c,1) /= 5) call stop_error("spline3 error: size(c,1) /= 5.") if (size(c,2) /= size(xi)-1) call stop_error("spline3 error: size(c,2) /= size(xi)-1.")  i1=iix(x,xi)  val=poly3(x,c(:,i1)) der=dpoly3(x,c(:,i1)) end subroutine    integer function iix(x, xi) result(i1)      real(dp), intent(in) :: x             real(dp), intent(in) :: xi(:)         integer n                             integer i2, ic  n = size(xi) i1 = 1 if (n < 2) then     call stop_error("error in iix: n < 2") elseif (n == 2) then     i1 = 1 elseif (n == 3) then     if (x <= xi(2)) then          i1 = 1     else         i1 = 2     end if elseif (x <= xi(1)) then      i1 = 1 elseif (x <= xi(2)) then      i1 = 1 elseif (x <= xi(3)) then      i1 = 2 elseif (x >= xi(n)) then       i1 = n-1 else          i1 = 3; i2 = n     do         if (i2 - i1 == 1) exit         ic = i1 + (i2 - i1)/2         if (x >= xi(ic)) then             i1 = ic         else             i2 = ic         endif     end do end if end function  integer function iixmin(x, xi, i_min) result(ip)  real(dp), intent(in) :: x, xi(:) integer, intent(in) :: i_min if (i_min >= 1 .and. i_min <= size(xi)-1) then     ip = iix(x, xi(i_min:)) + i_min - 1 else     ip = iix(x, xi) end if end function    function iixun(x,n,x1,xn)     integer iixun                        real(dp), intent(in):: x             integer, intent(in):: n              real(dp), intent(in):: x1            real(dp), intent(in):: xn            integer i   i=int((x-x1)/(xn-x1)*(n-1))+1  if (i<1) i=1 if (i>n-1) i=n-1 iixun=i end function    function iixexp(x,n,x1,alpha,beta)       integer iixexp                       real(dp), intent(in):: x             integer, intent(in):: n              real(dp), intent(in):: x1            real(dp), intent(in):: alpha            real(dp), intent(in):: beta          integer i   i=int(log((x-x1)/alpha + 1)/beta) + 1  if (i<1) i=1 if (i>n-1) i=n-1 iixexp=i end function    function poly3(x,c)  real(dp) poly3 real(dp), intent(in):: x       real(dp), intent(in):: c(0:)   real(dp) dx dx=x-c(0) poly3=c(1)+c(2)*dx+c(3)*dx**2+c(4)*dx**3 end function    function dpoly3(x,c)  real(dp) dpoly3 real(dp), intent(in):: x       real(dp), intent(in):: c(0:)   real(dp) dx dx=x-c(0) dpoly3=c(2)+2*c(3)*dx+3*c(4)*dx**2 end function    function d2poly3(x,c)  real(dp) d2poly3 real(dp), intent(in):: x       real(dp), intent(in):: c(0:)   real(dp) dx dx=x-c(0) d2poly3=2*c(3)+6*c(4)*dx end function  end module 
splines.f90_comments module splines  ! Splines are fully specified by the interpolation points, except that ! at the ends, we have the freedom to prescribe the second derivatives. ! If we know a derivative at an end (exactly), then best is to impose that. ! Otherwise, it is better to use the "consistent" end conditions: the second ! derivative is determined such that it is smooth. ! ! High level API: spline3, spline3ders. ! Low level API: the rest of public soubroutines. ! ! Use the high level API to obtain cubic spline fit with consistent boundary ! conditions and optionally the derivatives. Use the low level API if more fine ! grained control is needed. ! ! This module is based on a code written by John E. Pask, LLNL.  use types, only: dp use lapack, only: dgesv, dgbsv use utils, only: stop_error implicit none private public spline3pars, spline3valder, iix, iixmin, iixun, iixexp, poly3, dpoly3, &     d2poly3, spline3, spline3ders  contains  function spline3(x, y, xnew) result(ynew) ! Takes the function values 'y' on the grid 'x' and returns new values 'ynew' ! at the given grid 'xnew' using cubic splines interpolation with such ! boundary conditions so that the 2nd derivative is consistent with the ! interpolating cubic. real(dp), intent(in) :: x(:), y(:), xnew(:) real(dp) :: ynew(size(xnew)) real(dp) :: c(0:4, size(x)-1) integer :: i, ip ! get spline parameters: 2nd derivs at ends determined by cubic interpolation call spline3pars(x, y, [2, 2], [0._dp, 0._dp], c)  ip = 0 do i = 1, size(xnew)     ip = iixmin(xnew(i), x, ip)     ynew(i) = poly3(xnew(i), c(:, ip)) end do end function  subroutine spline3ders(x, y, xnew, ynew, dynew, d2ynew) ! Just like 'spline', but also calculate 1st and 2nd derivatives real(dp), intent(in) :: x(:), y(:), xnew(:) real(dp), intent(out), optional :: ynew(:), dynew(:), d2ynew(:) real(dp) :: c(0:4, size(x)-1) integer :: i, ip call spline3pars(x, y, [2, 2], [0._dp, 0._dp], c)  ip = 0 do i = 1, size(xnew)     ip = iixmin(xnew(i), x, ip)     if (present(  ynew))   ynew(i) =   poly3(xnew(i), c(:, ip))     if (present( dynew))  dynew(i) =  dpoly3(xnew(i), c(:, ip))     if (present(d2ynew)) d2ynew(i) = d2poly3(xnew(i), c(:, ip)) end do end subroutine  subroutine spline3pars(xi,yi,bctype,bcval,c) ! Returns parameters c defining cubic spline interpolating x-y data xi, yi, with ! boundary conditions specified by bcytpe, bcvals real(dp), intent(in):: xi(:)        ! x values of data real(dp), intent(in):: yi(:)        ! y values of data integer, intent(in):: bctype(2)     ! type of boundary condition at each end:    ! bctype(1) = type at left end, bctype(2) = type at right end.    ! 1 = specified 2nd derivative, 2 = 2nd derivative consistent with interpolating cubic. real(dp), intent(in):: bcval(2)     ! boundary condition values at each end:    ! bcval(1) = value at left end, bcval(2) = value at right end real(dp), intent(out):: c(0:,:)     ! parameters defining spline: c(i,j) = ith parameter of jth    ! spline polynomial, p_j = sum_{i=1}^4 c(i,j) (x-c(0,j))^(i-1), j = 1..n-1, n = # of data pts.    ! dimensions: c(0:4,1:n-1) real(dp) As(5,2*size(c,2))             ! spline eq. matrix -- LAPACK band form real(dp) bs(2*size(c,2))               ! spline eq. rhs vector real(dp) cs(2*size(c,2))               ! spline eq. solution vector real(dp) hi(size(c,2))                 ! spline intervals real(dp) Ae(4,4)                       ! end-cubic eq. matrix real(dp) be(4)                         ! end-cubic eq. rhs vector real(dp) ce(4)                         ! end-cubic eq. solution vector real(dp) xe(4),ye(4)                   ! x,y values at ends real(dp) d2p1,d2pn                     ! 2nd derivatives at ends real(dp) x0                            ! expansion center real(dp) c1,c2,c3,c4                   ! expansion coefficients integer n                              ! number of data points integer i,j,i2 ! lapack variables integer ipiv(4),ipiv2(2*size(c,2)) real(dp) bemat(4,1),bmat(2*size(c,2),1) integer info  ! check input parameters if (bctype(1) < 1 .or. bctype(1) > 2) call stop_error("spline3pars error: bctype /= 1 or 2.") if (bctype(2) < 1 .or. bctype(2) > 2) call stop_error("spline3pars error: bctype /= 1 or 2.") if (size(c,1) /= 5) call stop_error("spline3pars error: size(c,1) /= 5.") if (size(c,2) /= size(xi)-1) call stop_error("spline3pars error: size(c,2) /= size(xi)-1.") if (size(xi) /= size(yi)) call stop_error("spline3pars error: size(xi) /= size(yi)")  ! To get rid of compiler warnings: d2p1 = 0 d2pn = 0  ! initializations n=size(xi) do i=1,n-1    hi(i)=xi(i+1)-xi(i) end do  ! compute interpolating-cubic 2nd derivs at ends, if required    ! left end if(bctype(1)==2) then    if (n < 4) call stop_error("spline3pars error: n < 4")    xe=xi(1:4)    ye=yi(1:4)    x0=xe(1) ! center at end    do i=1,4       do j=1,4          Ae(i,j) = (xe(i)-x0)**(j-1)       end do    end do    Ae(:,1) = 1    ! set 0^0 = 1    be=ye; bemat(:,1)=be    call dgesv(4, 1, Ae, 4, ipiv, bemat, 4, info)    if (info /= 0) call stop_error("spline3pars error: dgesv error.")    ce=bemat(:,1)    d2p1=2*ce(3) end if    ! right end if(bctype(2)==2) then    if (n < 4) call stop_error("spline3pars error: n < 4")    xe=xi(n-3:n)    ye=yi(n-3:n)    x0=xe(4) ! center at end    do i=1,4       do j=1,4          Ae(i,j) = (xe(i)-x0)**(j-1)       end do    end do    Ae(:,1) = 1    ! set 0^0 = 1    be=ye; bemat(:,1)=be    call dgesv(4, 1, Ae, 4, ipiv, bemat, 4, info)    if (info /= 0) call stop_error("spline3pars error: dgesv error.")    ce=bemat(:,1)    d2pn=2*ce(3) end if  ! set 2nd derivs at ends if(bctype(1)==1) d2p1=bcval(1) if(bctype(2)==1) d2pn=bcval(2) !write(*,*) d2p1,d2pn  ! construct spline equations -- LAPACK band form ! basis: phi1 = -(x-x_i)/h_i, phi2 = (x-x_{i+1})/h_i, phi3 = phi1^3-phi1, phi4 = phi2^3-phi2 ! on interval [x_i,x_{i+1}] of length h_i = x_{i+1}-x_i !A=0  ! full matrix As=0    ! left end condition !A(1,1)=6/hi(1)**2   ! full matrix As(4,1)=6/hi(1)**2 bs(1)=d2p1    ! internal knot conditions do i=2,n-1    i2=2*(i-1) !   A(i2,i2-1) = 1/hi(i-1)    ! full matrix ... !   A(i2,i2)   = 2/hi(i-1) !   A(i2,i2+1) = 2/hi(i) !   A(i2,i2+2) = 1/hi(i) !   A(i2+1,i2) = 1/hi(i-1)**2 !   A(i2+1,i2+1) = -1/hi(i)**2    As(5,i2-1) = 1/hi(i-1)    As(4,i2)   = 2/hi(i-1)    As(3,i2+1) = 2/hi(i)    As(2,i2+2) = 1/hi(i)    As(5,i2)   = 1/hi(i-1)**2    As(4,i2+1) = -1/hi(i)**2    bs(i2) = (yi(i+1) - yi(i))/hi(i) - (yi(i) - yi(i-1))/hi(i-1)    bs(i2+1) = 0 end do    ! right end condition    !A(2*(n-1),2*(n-1))=6/hi(n-1)**2 ! full matrix As(4,2*(n-1))=6/hi(n-1)**2 bs(2*(n-1))=d2pn  ! solve spline equations -- full matrix !bmat(:,1)=bs !call dgesv(2*(n-1), 1, A, 2*(n-1), ipiv2, bmat, 2*(n-1), info) !if (info /= 0) call stop_error("spline3pars error: dgesv error.") !cs=bmat(:,1)  ! solve spline equations -- LAPACK band form bmat(:,1)=bs call dgbsv(2*(n-1), 1, 2, 1, As, 5, ipiv2, bmat, 2*(n-1), info) if (info /= 0) call stop_error("spline3pars error: dgbsv error.") cs=bmat(:,1) !write(*,*) cs(1:6) !write(*,*) cs(2*(n-1)-5:2*(n-1))  ! transform to (x-x0)^(i-1) basis and return do i=1,n-1    ! coefficients in spline basis:    c1=yi(i)    c2=yi(i+1)    c3=cs(2*i-1)    c4=cs(2*i)    ! coefficients in (x-x0)^(i-1) basis    c(0,i)=xi(i)    c(1,i)=c1    c(2,i)=-(c1-c2+2*c3+c4)/hi(i)    c(3,i)=3*c3/hi(i)**2    c(4,i)=(-c3+c4)/hi(i)**3 end do end subroutine  !--------------------------------------------------------------------------------------------------!  subroutine spline3valder(x,xi,c,val,der) ! Returns value and 1st derivative of spline defined by knots xi and parameters c ! returned by spline3pars real(dp), intent(in):: x            ! point at which to evaluate spline real(dp), intent(in):: xi(:)        ! spline knots (x values of data) real(dp), intent(in):: c(0:,:)      ! spline parameters: c(i,j) = ith parameter of jth    ! spline polynomial, p_j = sum_{i=1}^4 c(i,j) (x-c(0,j))^(i-1), j = 1..n-1, n = # of data pts.    ! dimensions: c(0:4,1:n-1) real(dp), intent(out):: val         ! value of spline at x real(dp), intent(out):: der         ! 1st derivative of spline at x integer n                           ! number of knots integer i1  ! initialize, check input parameters n=size(xi) if (size(c,1) /= 5) call stop_error("spline3 error: size(c,1) /= 5.") if (size(c,2) /= size(xi)-1) call stop_error("spline3 error: size(c,2) /= size(xi)-1.") ! find interval containing x i1=iix(x,xi) ! return value and derivative val=poly3(x,c(:,i1)) der=dpoly3(x,c(:,i1)) end subroutine  !--------------------------------------------------------------------------------------------------!  integer function iix(x, xi) result(i1) ! Returns index i of interval [xi(i),xi(i+1)] containing x in mesh xi, ! with intervals indexed by left-most points. ! N.B.: x outside [x1,xn] are indexed to nearest end. ! Uses bisection, except if "x" lies in the first or second elements (which is ! often the case) real(dp), intent(in) :: x            ! target value real(dp), intent(in) :: xi(:)        ! mesh, xi(i) < xi(i+1) integer n                            ! number of mesh points integer i2, ic  n = size(xi) i1 = 1 if (n < 2) then     call stop_error("error in iix: n < 2") elseif (n == 2) then     i1 = 1 elseif (n == 3) then     if (x <= xi(2)) then ! first element         i1 = 1     else         i1 = 2     end if elseif (x <= xi(1)) then ! left end     i1 = 1 elseif (x <= xi(2)) then ! first element     i1 = 1 elseif (x <= xi(3)) then ! second element     i1 = 2 elseif (x >= xi(n)) then  ! right end     i1 = n-1 else     ! bisection: xi(i1) <= x < xi(i2)     i1 = 3; i2 = n     do         if (i2 - i1 == 1) exit         ic = i1 + (i2 - i1)/2         if (x >= xi(ic)) then             i1 = ic         else             i2 = ic         endif     end do end if end function  integer function iixmin(x, xi, i_min) result(ip) ! Just like iix, but assumes that x >= xi(i_min) real(dp), intent(in) :: x, xi(:) integer, intent(in) :: i_min if (i_min >= 1 .and. i_min <= size(xi)-1) then     ip = iix(x, xi(i_min:)) + i_min - 1 else     ip = iix(x, xi) end if end function  !--------------------------------------------------------------------------------------------------!  function iixun(x,n,x1,xn) ! Returns index i of interval [x(i),x(i+1)] containing x in uniform mesh defined by !   x(i) = x1 + (i-1)/(n-1)*(xn-x1), i = 1 .. n, ! with intervals indexed by left-most points. ! N.B.: x outside [x1,xn] are indexed to nearest end. integer iixun                       ! index i of interval [x(i),x(i+1)] containing x real(dp), intent(in):: x            ! target value integer, intent(in):: n             ! number of mesh points real(dp), intent(in):: x1           ! initial point of mesh real(dp), intent(in):: xn           ! final point of mesh integer i  ! compute index i=int((x-x1)/(xn-x1)*(n-1))+1 ! reset if ouside 1..n if (i<1) i=1 if (i>n-1) i=n-1 iixun=i end function  !--------------------------------------------------------------------------------------------------!  function iixexp(x,n,x1,alpha,beta) ! Returns index i of interval [x(i),x(i+1)] containing x in exponential mesh defined by !   x(i) = x1 + alpha [ exp(beta(i-1)) - 1 ], i = 1 .. n, ! where alpha = (x(n) - x(1))/[ exp(beta(n-1)) - 1 ], ! beta = log(r)/(n-2), r = (x(n)-x(n-1))/(x(2)-x(1)) = ratio of last to first interval, ! and intervals indexed by left-most points. ! N.B.: x outside [x1,xn] are indexed to nearest end. integer iixexp                      ! index i of interval [x(i),x(i+1)] containing x real(dp), intent(in):: x            ! target value integer, intent(in):: n             ! number of mesh points real(dp), intent(in):: x1           ! initial point of mesh real(dp), intent(in):: alpha        ! mesh parameter: !   x(i) = x1 + alpha [ exp(beta(i-1)) - 1 ], i = 1 .. n, ! where alpha = (x(n) - x(1))/[ exp(beta(n-1)) - 1 ], ! beta = log(r)/(n-2), r = (x(n)-x(n-1))/(x(2)-x(1)) = ratio of last to first interval, real(dp), intent(in):: beta         ! mesh parameter integer i  ! compute index i=int(log((x-x1)/alpha + 1)/beta) + 1 ! reset if outside 1..n if (i<1) i=1 if (i>n-1) i=n-1 iixexp=i end function  !--------------------------------------------------------------------------------------------------!  function poly3(x,c) ! returns value of polynomial \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) poly3 real(dp), intent(in):: x      ! point at which to evaluate polynomial real(dp), intent(in):: c(0:)  ! coefficients: poly = \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) dx dx=x-c(0) poly3=c(1)+c(2)*dx+c(3)*dx**2+c(4)*dx**3 end function  !--------------------------------------------------------------------------------------------------!  function dpoly3(x,c) ! returns 1st derivative of polynomial \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) dpoly3 real(dp), intent(in):: x      ! point at which to evaluate polynomial real(dp), intent(in):: c(0:)  ! coefficients: poly = \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) dx dx=x-c(0) dpoly3=c(2)+2*c(3)*dx+3*c(4)*dx**2 end function  !--------------------------------------------------------------------------------------------------!  function d2poly3(x,c) ! returns 2nd derivative of polynomial \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) d2poly3 real(dp), intent(in):: x      ! point at which to evaluate polynomial real(dp), intent(in):: c(0:)  ! coefficients: poly = \sum_{i=1}^4 c(i) (x-c(0))^(i-1) real(dp) dx dx=x-c(0) d2poly3=2*c(3)+6*c(4)*dx end function  end module 
types.f90_stripped module types implicit none private public dp, hp, ivector, dvector, zvector  integer, parameter :: dp=kind(0.d0), &                                 hp=selected_real_kind(15)   type ivector                           integer, pointer :: vec(:) => null() end type  type dvector                           real(dp), pointer :: vec(:) => null() end type  type zvector                           complex(dp), pointer :: vec(:) => null() end type  end module 
types.f90_comments module types implicit none private public dp, hp, ivector, dvector, zvector  integer, parameter :: dp=kind(0.d0), &          ! double precision                       hp=selected_real_kind(15) ! high precision  type ivector                       ! allocatable integer vector    integer, pointer :: vec(:) => null() end type  type dvector                       ! allocatable real double precision vector    real(dp), pointer :: vec(:) => null() end type  type zvector                       ! allocatable complex double precision vector    complex(dp), pointer :: vec(:) => null() end type  end module 
utils.f90_stripped module utils     use types, only: dp implicit none private public upcase, lowcase, whitechar, blank, numstrings, getstring, &     stop_error, arange, loadtxt, savetxt, newunit, assert, str  interface str     module procedure str_int, str_real, str_real_n end interface  contains  function upcase(s) result(t)  character(*), intent(in) :: s character(len(s)) :: t integer :: i, diff t = s; diff = ichar('A')-ichar('a') do i = 1, len(t)     if (ichar(t(i:i)) >= ichar('a') .and. ichar(t(i:i)) <= ichar('z')) then                  t(i:i) = char(ichar(t(i:i)) + diff)     end if end do end function  function lowcase(s) result(t)  character(*), intent(in) :: s character(len(s)) :: t integer :: i, diff t = s; diff = ichar('A')-ichar('a') do i = 1, len(t)     if (ichar(t(i:i)) >= ichar('A') .and. ichar(t(i:i)) <= ichar('Z')) then                  t(i:i) = char(ichar(t(i:i)) - diff)     end if end do end function  logical function whitechar(char)   character, intent(in) :: char if (iachar(char) == 32 .or. iachar(char) == 9) then     whitechar = .true. else     whitechar = .false. end if end function  logical function blank(string)  character(*), intent(in) :: string integer :: i do i = 1, len(string)     if (.not. whitechar(string(i:i))) exit end do blank = (i>len(string)) end function  integer function numstrings(s) result(n)   character(*), intent(in) :: s     character(len(s)+2) :: t          integer :: i t = " " // s // " " n = 0 do i = 1, len(t)-1     if (whitechar(t(i:i)) .and. .not. whitechar(t(i+1:i+1))) n = n + 1 end do end function    subroutine getstring(s,is,ss)     character(*), intent(in) :: s    integer, intent(inout) :: is                                                                       character(*), intent(out) :: ss  character(len(s)+1) :: t         integer i, i1, i2 logical prevwhite, curwhite if (is <= 0 .or. is > len(s)) then     ss = ""; is = -1; return end if t = s // " " if (is == 1) then     prevwhite = .true. else     prevwhite = whitechar(t(is-1:is-1)) end if i1 = 0; i2 = 0 do i = is, len(t)     curwhite = whitechar(t(i:i))     if (prevwhite .and. .not. curwhite) i1 = i        if (i1>0 .and. curwhite) then                         i2 = i-1; exit     end if     prevwhite=curwhite end do if (i2 > 0) then     ss = t(i1:i2); is = i2+1 else     ss = ""; is = 0 end if end subroutine  integer function newunit(unit) result(n)          integer, intent(out), optional :: unit                 logical inuse integer, parameter :: nmin=10    integer, parameter :: nmax=999   do n = nmin, nmax     inquire(unit=n, opened=inuse)     if (.not. inuse) then         if (present(unit)) unit=n         return     end if end do call stop_error("newunit ERROR: available unit not found.") end function  subroutine stop_error(msg)            character(len=*) :: msg  print *, msg stop 1 end subroutine  subroutine loadtxt(filename, d)       character(len=*), intent(in) :: filename  real(dp), allocatable, intent(out) :: d(:, :)                character :: c integer :: s, ncol, nrow, ios, i logical :: lastwhite real(dp) :: r  open(newunit=s, file=filename, status="old")   ncol = 0 lastwhite = .true. do    read(s, '(a)', advance='no', iostat=ios) c    if (ios /= 0) exit    if (lastwhite .and. .not. whitechar(c)) ncol = ncol + 1    lastwhite = whitechar(c) end do  rewind(s)   nrow = 0 do    read(s, *, iostat=ios) r    if (ios /= 0) exit    nrow = nrow + 1 end do  rewind(s)  allocate(d(nrow, ncol)) do i = 1, nrow     read(s, *) d(i, :) end do close(s) end subroutine  subroutine savetxt(filename, d)      character(len=*), intent(in) :: filename   real(dp), intent(in) :: d(:, :)                   integer :: s, i open(newunit=s, file=filename, status="replace") do i = 1, size(d, 1)     write(s, *) d(i, :) end do close(s) end subroutine  subroutine arange(a, b, dx, u)      real(dp), intent(in) :: a, b, dx real(dp), allocatable, intent(out) :: u(:)       integer :: n, i n = int((b-a) / dx) allocate(u(n)) do i = 1, n     u(i) = a + (i-1)*dx end do end subroutine  subroutine assert(condition)      logical, intent(in) :: condition       if (.not. condition) call stop_error("Assert failed.") end subroutine  pure integer function str_int_len(i) result(sz)  integer, intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s   write(s, '(i0)') i sz = len_trim(s) end function  pure function str_int(i) result(s)  integer, intent(in) :: i character(len=str_int_len(i)) :: s write(s, '(i0)') i end function  pure integer function str_real_len(r, fmt) result(sz)  real(dp), intent(in) :: r character(len=*), intent(in) :: fmt integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s   write(s, fmt) r sz = len_trim(s) end function  pure function str_real(r) result(s)  real(dp), intent(in) :: r character(len=*), parameter :: fmt="(f0.6)" character(len=str_real_len(r, fmt)) :: s write(s, fmt) r end function  pure function str_real_n(r, n) result(s)  real(dp), intent(in) :: r integer, intent(in) :: n character(len=str_real_len(r, "(f0." // str_int(n) // ")")) :: s write(s, "(f0." // str_int(n) // ")") r end function  end module 
utils.f90_comments module utils  ! Various general utilities. ! Based on a code by John E. Pask, LLNL.  use types, only: dp implicit none private public upcase, lowcase, whitechar, blank, numstrings, getstring, &     stop_error, arange, loadtxt, savetxt, newunit, assert, str  interface str     module procedure str_int, str_real, str_real_n end interface  contains  function upcase(s) result(t) ! Returns string 's' in uppercase character(*), intent(in) :: s character(len(s)) :: t integer :: i, diff t = s; diff = ichar('A')-ichar('a') do i = 1, len(t)     if (ichar(t(i:i)) >= ichar('a') .and. ichar(t(i:i)) <= ichar('z')) then         ! if lowercase, make uppercase         t(i:i) = char(ichar(t(i:i)) + diff)     end if end do end function  function lowcase(s) result(t) ! Returns string 's' in lowercase character(*), intent(in) :: s character(len(s)) :: t integer :: i, diff t = s; diff = ichar('A')-ichar('a') do i = 1, len(t)     if (ichar(t(i:i)) >= ichar('A') .and. ichar(t(i:i)) <= ichar('Z')) then         ! if uppercase, make lowercase         t(i:i) = char(ichar(t(i:i)) - diff)     end if end do end function  logical function whitechar(char) ! white character ! returns .true. if char is space (32) or tab (9), .false. otherwise character, intent(in) :: char if (iachar(char) == 32 .or. iachar(char) == 9) then     whitechar = .true. else     whitechar = .false. end if end function  logical function blank(string) ! Returns true if string contains only white characters character(*), intent(in) :: string integer :: i do i = 1, len(string)     if (.not. whitechar(string(i:i))) exit end do blank = (i>len(string)) end function  integer function numstrings(s) result(n) ! Returns number of substrings contained in input string 's' delimited ! by white space. character(*), intent(in) :: s    ! input string character(len(s)+2) :: t         ! temporary string to facilitate analysis integer :: i t = " " // s // " " n = 0 do i = 1, len(t)-1     if (whitechar(t(i:i)) .and. .not. whitechar(t(i+1:i+1))) n = n + 1 end do end function  !--------------------------------------------------------------------------------------------------!  subroutine getstring(s,is,ss) ! Returns first substring ss in string s, delimited by white space, starting at ! index is in s. If ss is found, is is set to (index of last character of ss in ! s) + 1; else is is set to 0. If is is out of range on input, routine ! terminates with is = -1. character(*), intent(in) :: s   ! input string integer, intent(inout) :: is    ! on input: starting index for search for ss in                                 ! s on output: (index of last character of ss in                                 ! s) + 1 character(*), intent(out) :: ss ! first substring in s, starting from index is character(len(s)+1) :: t        ! temporary string to facilitate search integer i, i1, i2 logical prevwhite, curwhite if (is <= 0 .or. is > len(s)) then     ss = ""; is = -1; return end if t = s // " " if (is == 1) then     prevwhite = .true. else     prevwhite = whitechar(t(is-1:is-1)) end if i1 = 0; i2 = 0 do i = is, len(t)     curwhite = whitechar(t(i:i))     if (prevwhite .and. .not. curwhite) i1 = i   ! beginning of substring     if (i1>0 .and. curwhite) then                ! end of substring         i2 = i-1; exit     end if     prevwhite=curwhite end do if (i2 > 0) then     ss = t(i1:i2); is = i2+1 else     ss = ""; is = 0 end if end subroutine  integer function newunit(unit) result(n) ! Returns lowest i/o unit number not in use (to be used in older compilers). ! ! Starting at 10 to avoid lower numbers which are sometimes reserved. ! Note: largest valid unit number may be system-dependent. ! ! Arguments ! --------- ! ! If present, the new unit will be returned into it integer, intent(out), optional :: unit ! ! Example ! ------- ! ! integer :: u ! open(newunit(u), file="log.txt", status="old") ! read(u, *) a, b ! close(u) ! ! In new compilers, just use the "newunit" keyword argument: ! ! integer :: u ! open(newunit=u, file="log.txt", status="old") ! read(u, *) a, b ! close(u)  logical inuse integer, parameter :: nmin=10   ! avoid lower numbers which are sometimes reserved integer, parameter :: nmax=999  ! may be system-dependent do n = nmin, nmax     inquire(unit=n, opened=inuse)     if (.not. inuse) then         if (present(unit)) unit=n         return     end if end do call stop_error("newunit ERROR: available unit not found.") end function  subroutine stop_error(msg) ! Aborts the program with nonzero exit code ! ! The statement "stop msg" will return 0 exit code when compiled using ! gfortran. stop_error() uses the statement "stop 1" which returns an exit code ! 1 and a print statement to print the message. ! ! Example ! ------- ! ! call stop_error("Invalid argument")  character(len=*) :: msg ! Message to print on stdout print *, msg stop 1 end subroutine  subroutine loadtxt(filename, d) ! Loads a 2D array from a text file. ! ! Arguments ! --------- ! ! Filename to load the array from character(len=*), intent(in) :: filename ! The array 'd' will be automatically allocated with the correct dimensions real(dp), allocatable, intent(out) :: d(:, :) ! ! Example ! ------- ! ! real(dp), allocatable :: data(:, :) ! call loadtxt("log.txt", data)  ! 'data' will be automatically allocated ! ! Where 'log.txt' contains for example:: ! !     1 2 3 !     2 4 6 !     8 9 10 !     11 12 13 !     ... ! character :: c integer :: s, ncol, nrow, ios, i logical :: lastwhite real(dp) :: r  open(newunit=s, file=filename, status="old")  ! determine number of columns ncol = 0 lastwhite = .true. do    read(s, '(a)', advance='no', iostat=ios) c    if (ios /= 0) exit    if (lastwhite .and. .not. whitechar(c)) ncol = ncol + 1    lastwhite = whitechar(c) end do  rewind(s)  ! determine number or rows nrow = 0 do    read(s, *, iostat=ios) r    if (ios /= 0) exit    nrow = nrow + 1 end do  rewind(s)  allocate(d(nrow, ncol)) do i = 1, nrow     read(s, *) d(i, :) end do close(s) end subroutine  subroutine savetxt(filename, d) ! Saves a 2D array into a textfile. ! ! Arguments ! --------- ! character(len=*), intent(in) :: filename  ! File to save the array to real(dp), intent(in) :: d(:, :)           ! The 2D array to save ! ! Example ! ------- ! ! real(dp) :: data(3, 2) ! call savetxt("log.txt", data)  integer :: s, i open(newunit=s, file=filename, status="replace") do i = 1, size(d, 1)     write(s, *) d(i, :) end do close(s) end subroutine  subroutine arange(a, b, dx, u) ! Returns an array u = [a, a+dx, a+2*dx, ..., b-dx] ! ! Arguments ! --------- ! real(dp), intent(in) :: a, b, dx real(dp), allocatable, intent(out) :: u(:) ! ! Example ! ------- ! ! real(dp), allocatable :: u(:) ! call arange(1, 5, 1, u)   ! u = [1, 2, 3, 4] integer :: n, i n = int((b-a) / dx) allocate(u(n)) do i = 1, n     u(i) = a + (i-1)*dx end do end subroutine  subroutine assert(condition) ! If condition == .false., it aborts the program. ! ! Arguments ! --------- ! logical, intent(in) :: condition ! ! Example ! ------- ! ! call assert(a == 5)  if (.not. condition) call stop_error("Assert failed.") end subroutine  pure integer function str_int_len(i) result(sz) ! Returns the length of the string representation of 'i' integer, intent(in) :: i integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s ! If 's' is too short (MAX_STR too small), Fortan will abort with: ! "Fortran runtime error: End of record" write(s, '(i0)') i sz = len_trim(s) end function  pure function str_int(i) result(s) ! Converts integer "i" to string integer, intent(in) :: i character(len=str_int_len(i)) :: s write(s, '(i0)') i end function  pure integer function str_real_len(r, fmt) result(sz) ! Returns the length of the string representation of 'i' real(dp), intent(in) :: r character(len=*), intent(in) :: fmt integer, parameter :: MAX_STR = 100 character(MAX_STR) :: s ! If 's' is too short (MAX_STR too small), Fortan will abort with: ! "Fortran runtime error: End of record" write(s, fmt) r sz = len_trim(s) end function  pure function str_real(r) result(s) ! Converts the real number "r" to string with 7 decimal digits. real(dp), intent(in) :: r character(len=*), parameter :: fmt="(f0.6)" character(len=str_real_len(r, fmt)) :: s write(s, fmt) r end function  pure function str_real_n(r, n) result(s) ! Converts the real number "r" to string with 'n' decimal digits. real(dp), intent(in) :: r integer, intent(in) :: n character(len=str_real_len(r, "(f0." // str_int(n) // ")")) :: s write(s, "(f0." // str_int(n) // ")") r end function  end module 
