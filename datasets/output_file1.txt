f08estop.f90_stripped submodule (stdlib_error) f08estop  implicit none  contains  module procedure error_stop               write(stderr,*) msg  if(present(code)) then   select case (code)   case (1)     error stop 1   case (2)     error stop 2   case (77)     error stop 77   case default     write(stderr,*) 'ERROR: code ',code,' was specified.'     error stop   end select else   error stop endif end procedure  end submodule f08estop 
f08estop.f90_comments submodule (stdlib_error) f08estop  implicit none  contains  module procedure error_stop ! Aborts the program with nonzero exit code ! this is a fallback for Fortran 2008 error stop (e.g. Intel 19.1/2020 compiler) ! ! The "stop <character>" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement "error stop", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code "code" may be specified. ! ! Example ! ------- ! ! call error_stop("Invalid argument")  write(stderr,*) msg  if(present(code)) then   select case (code)   case (1)     error stop 1   case (2)     error stop 2   case (77)     error stop 77   case default     write(stderr,*) 'ERROR: code ',code,' was specified.'     error stop   end select else   error stop endif end procedure  end submodule f08estop 
f18estop.f90_stripped submodule (stdlib_error) f18estop  implicit none  contains  module procedure error_stop              if(present(code)) then   write(stderr,*) msg   error stop code else   error stop msg endif end procedure  end submodule f18estop 
f18estop.f90_comments submodule (stdlib_error) f18estop  implicit none  contains  module procedure error_stop ! Aborts the program with nonzero exit code ! ! The "stop <character>" statement generally has return code 0. ! To allow non-zero return code termination with character message, ! error_stop() uses the statement "error stop", which by default ! has exit code 1 and prints the message to stderr. ! An optional integer return code "code" may be specified. ! ! Example ! ------- ! ! call error_stop("Invalid argument")  if(present(code)) then   write(stderr,*) msg   error stop code else   error stop msg endif end procedure  end submodule f18estop 
stdlib_ansi.f90_stripped    module stdlib_ansi     use stdlib_kinds, only : i1 => int8     use stdlib_string_type, only : string_type     implicit none     private      public :: ansi_code     public :: style_reset, style_bold, style_dim, style_italic, style_underline, &         & style_blink, style_blink_fast, style_reverse, style_hidden, style_strikethrough     public :: fg_color_black, fg_color_red, fg_color_green, fg_color_yellow, fg_color_blue, &         & fg_color_magenta, fg_color_cyan, fg_color_white, fg_color_default     public :: bg_color_black, bg_color_red, bg_color_green, bg_color_yellow, bg_color_blue, &         & bg_color_magenta, bg_color_cyan, bg_color_white, bg_color_default      public :: to_string, operator(+), operator(//)             type :: ansi_code         private                  integer(i1) :: style = -1_i1                  integer(i1) :: bg = -1_i1                  integer(i1) :: fg = -1_i1     end type ansi_code            type(ansi_code), parameter :: style_reset = ansi_code(style=0)          type(ansi_code), parameter :: style_bold = ansi_code(style=1)          type(ansi_code), parameter :: style_dim = ansi_code(style=2)          type(ansi_code), parameter :: style_italic = ansi_code(style=3)          type(ansi_code), parameter :: style_underline = ansi_code(style=4)          type(ansi_code), parameter :: style_blink = ansi_code(style=5)          type(ansi_code), parameter :: style_blink_fast = ansi_code(style=6)          type(ansi_code), parameter :: style_reverse = ansi_code(style=7)          type(ansi_code), parameter :: style_hidden = ansi_code(style=8)          type(ansi_code), parameter :: style_strikethrough = ansi_code(style=9)           type(ansi_code), parameter :: fg_color_black = ansi_code(fg=0)          type(ansi_code), parameter :: fg_color_red = ansi_code(fg=1)          type(ansi_code), parameter :: fg_color_green = ansi_code(fg=2)          type(ansi_code), parameter :: fg_color_yellow = ansi_code(fg=3)          type(ansi_code), parameter :: fg_color_blue = ansi_code(fg=4)          type(ansi_code), parameter :: fg_color_magenta = ansi_code(fg=5)          type(ansi_code), parameter :: fg_color_cyan = ansi_code(fg=6)          type(ansi_code), parameter :: fg_color_white = ansi_code(fg=7)          type(ansi_code), parameter :: fg_color_default = ansi_code(fg=9)           type(ansi_code), parameter :: bg_color_black = ansi_code(bg=0)          type(ansi_code), parameter :: bg_color_red = ansi_code(bg=1)          type(ansi_code), parameter :: bg_color_green = ansi_code(bg=2)          type(ansi_code), parameter :: bg_color_yellow = ansi_code(bg=3)          type(ansi_code), parameter :: bg_color_blue = ansi_code(bg=4)          type(ansi_code), parameter :: bg_color_magenta = ansi_code(bg=5)          type(ansi_code), parameter :: bg_color_cyan = ansi_code(bg=6)          type(ansi_code), parameter :: bg_color_white = ansi_code(bg=7)          type(ansi_code), parameter :: bg_color_default = ansi_code(bg=9)       interface to_string                  pure module function to_string_ansi_code(code) result(str)                          type(ansi_code), intent(in) :: code                          character(len=:), allocatable :: str         end function to_string_ansi_code     end interface to_string       interface operator(+)                  pure module function add(lval, rval) result(code)                          type(ansi_code), intent(in) :: lval                          type(ansi_code), intent(in) :: rval                          type(ansi_code) :: code         end function add     end interface operator(+)      interface operator(//)                  pure module function concat_left(lval, code) result(str)                          character(len=*), intent(in) :: lval                          type(ansi_code), intent(in) :: code                          character(len=:), allocatable :: str         end function concat_left                   pure module function concat_right(code, rval) result(str)                          character(len=*), intent(in) :: rval                          type(ansi_code), intent(in) :: code                          character(len=:), allocatable :: str         end function concat_right                   pure module function concat_left_str(lval, code) result(str)                          type(string_type), intent(in) :: lval                          type(ansi_code), intent(in) :: code                          type(string_type) :: str         end function concat_left_str                   pure module function concat_right_str(code, rval) result(str)                          type(string_type), intent(in) :: rval                          type(ansi_code), intent(in) :: code                          type(string_type) :: str         end function concat_right_str     end interface operator(//)  end module stdlib_ansi 
stdlib_ansi.f90_comments ! SPDX-Identifier: MIT  !> Terminal color and style escape sequences module stdlib_ansi     use stdlib_kinds, only : i1 => int8     use stdlib_string_type, only : string_type     implicit none     private      public :: ansi_code     public :: style_reset, style_bold, style_dim, style_italic, style_underline, &         & style_blink, style_blink_fast, style_reverse, style_hidden, style_strikethrough     public :: fg_color_black, fg_color_red, fg_color_green, fg_color_yellow, fg_color_blue, &         & fg_color_magenta, fg_color_cyan, fg_color_white, fg_color_default     public :: bg_color_black, bg_color_red, bg_color_green, bg_color_yellow, bg_color_blue, &         & bg_color_magenta, bg_color_cyan, bg_color_white, bg_color_default      public :: to_string, operator(+), operator(//)        !> Container for terminal escape code     type :: ansi_code         private         !> Style descriptor         integer(i1) :: style = -1_i1         !> Background color descriptor         integer(i1) :: bg = -1_i1         !> Foreground color descriptor         integer(i1) :: fg = -1_i1     end type ansi_code       !> Identifier for reset style     type(ansi_code), parameter :: style_reset = ansi_code(style=0)     !> Identifier for bold style     type(ansi_code), parameter :: style_bold = ansi_code(style=1)     !> Identifier for dim style     type(ansi_code), parameter :: style_dim = ansi_code(style=2)     !> Identifier for italic style     type(ansi_code), parameter :: style_italic = ansi_code(style=3)     !> Identifier for underline style     type(ansi_code), parameter :: style_underline = ansi_code(style=4)     !> Identifier for blink style     type(ansi_code), parameter :: style_blink = ansi_code(style=5)     !> Identifier for (fast) blink style     type(ansi_code), parameter :: style_blink_fast = ansi_code(style=6)     !> Identifier for reverse style     type(ansi_code), parameter :: style_reverse = ansi_code(style=7)     !> Identifier for hidden style     type(ansi_code), parameter :: style_hidden = ansi_code(style=8)     !> Identifier for strikethrough style     type(ansi_code), parameter :: style_strikethrough = ansi_code(style=9)      !> Identifier for black foreground color     type(ansi_code), parameter :: fg_color_black = ansi_code(fg=0)     !> Identifier for red foreground color     type(ansi_code), parameter :: fg_color_red = ansi_code(fg=1)     !> Identifier for green foreground color     type(ansi_code), parameter :: fg_color_green = ansi_code(fg=2)     !> Identifier for yellow foreground color     type(ansi_code), parameter :: fg_color_yellow = ansi_code(fg=3)     !> Identifier for blue foreground color     type(ansi_code), parameter :: fg_color_blue = ansi_code(fg=4)     !> Identifier for magenta foreground color     type(ansi_code), parameter :: fg_color_magenta = ansi_code(fg=5)     !> Identifier for cyan foreground color     type(ansi_code), parameter :: fg_color_cyan = ansi_code(fg=6)     !> Identifier for white foreground color     type(ansi_code), parameter :: fg_color_white = ansi_code(fg=7)     !> Identifier for the default foreground color     type(ansi_code), parameter :: fg_color_default = ansi_code(fg=9)      !> Identifier for black background color     type(ansi_code), parameter :: bg_color_black = ansi_code(bg=0)     !> Identifier for red background color     type(ansi_code), parameter :: bg_color_red = ansi_code(bg=1)     !> Identifier for green background color     type(ansi_code), parameter :: bg_color_green = ansi_code(bg=2)     !> Identifier for yellow background color     type(ansi_code), parameter :: bg_color_yellow = ansi_code(bg=3)     !> Identifier for blue background color     type(ansi_code), parameter :: bg_color_blue = ansi_code(bg=4)     !> Identifier for magenta background color     type(ansi_code), parameter :: bg_color_magenta = ansi_code(bg=5)     !> Identifier for cyan background color     type(ansi_code), parameter :: bg_color_cyan = ansi_code(bg=6)     !> Identifier for white background color     type(ansi_code), parameter :: bg_color_white = ansi_code(bg=7)     !> Identifier for the default background color     type(ansi_code), parameter :: bg_color_default = ansi_code(bg=9)       interface to_string         !> Transform a color code into an actual ANSI escape sequence         pure module function to_string_ansi_code(code) result(str)             !> Color code to be used             type(ansi_code), intent(in) :: code             !> ANSI escape sequence representing the color code             character(len=:), allocatable :: str         end function to_string_ansi_code     end interface to_string       interface operator(+)         !> Add two escape sequences, attributes in the right value override the left value ones.         pure module function add(lval, rval) result(code)             !> First escape code             type(ansi_code), intent(in) :: lval             !> Second escape code             type(ansi_code), intent(in) :: rval             !> Combined escape code             type(ansi_code) :: code         end function add     end interface operator(+)      interface operator(//)         !> Concatenate an escape code with a string and turn it into an actual escape sequence         pure module function concat_left(lval, code) result(str)             !> String to add the escape code to             character(len=*), intent(in) :: lval             !> Escape sequence             type(ansi_code), intent(in) :: code             !> Concatenated string             character(len=:), allocatable :: str         end function concat_left          !> Concatenate an escape code with a string and turn it into an actual escape sequence         pure module function concat_right(code, rval) result(str)             !> String to add the escape code to             character(len=*), intent(in) :: rval             !> Escape sequence             type(ansi_code), intent(in) :: code             !> Concatenated string             character(len=:), allocatable :: str         end function concat_right          !> Concatenate an escape code with a string and turn it into an actual escape sequence         pure module function concat_left_str(lval, code) result(str)             !> String to add the escape code to             type(string_type), intent(in) :: lval             !> Escape sequence             type(ansi_code), intent(in) :: code             !> Concatenated string             type(string_type) :: str         end function concat_left_str          !> Concatenate an escape code with a string and turn it into an actual escape sequence         pure module function concat_right_str(code, rval) result(str)             !> String to add the escape code to             type(string_type), intent(in) :: rval             !> Escape sequence             type(ansi_code), intent(in) :: code             !> Concatenated string             type(string_type) :: str         end function concat_right_str     end interface operator(//)  end module stdlib_ansi 
stdlib_ansi_operator.f90_stripped    submodule (stdlib_ansi) stdlib_ansi_operator     use stdlib_string_type, only : operator(//)     implicit none  contains           pure module function add(lval, rval) result(code)                  type(ansi_code), intent(in) :: lval                  type(ansi_code), intent(in) :: rval                  type(ansi_code) :: code          code%style = merge(rval%style, lval%style, rval%style >= 0)         code%fg = merge(rval%fg, lval%fg, rval%fg >= 0)         code%bg = merge(rval%bg, lval%bg, rval%bg >= 0)     end function add           pure module function concat_left(lval, code) result(str)                  character(len=*), intent(in) :: lval                  type(ansi_code), intent(in) :: code                  character(len=:), allocatable :: str          str = lval // to_string(code)     end function concat_left           pure module function concat_right(code, rval) result(str)                  character(len=*), intent(in) :: rval                  type(ansi_code), intent(in) :: code                  character(len=:), allocatable :: str          str = to_string(code) // rval     end function concat_right           pure module function concat_left_str(lval, code) result(str)                  type(string_type), intent(in) :: lval                  type(ansi_code), intent(in) :: code                  type(string_type) :: str          str = lval // to_string(code)     end function concat_left_str           pure module function concat_right_str(code, rval) result(str)                  type(string_type), intent(in) :: rval                  type(ansi_code), intent(in) :: code                  type(string_type) :: str          str = to_string(code) // rval     end function concat_right_str  end submodule stdlib_ansi_operator 
stdlib_ansi_operator.f90_comments ! SPDX-Identifier: MIT  !> Implementation of the conversion to enumerator and identifier types to strings submodule (stdlib_ansi) stdlib_ansi_operator     use stdlib_string_type, only : operator(//)     implicit none  contains      !> Add two escape sequences, attributes in the right value override the left value ones.     pure module function add(lval, rval) result(code)         !> First escape code         type(ansi_code), intent(in) :: lval         !> Second escape code         type(ansi_code), intent(in) :: rval         !> Combined escape code         type(ansi_code) :: code          code%style = merge(rval%style, lval%style, rval%style >= 0)         code%fg = merge(rval%fg, lval%fg, rval%fg >= 0)         code%bg = merge(rval%bg, lval%bg, rval%bg >= 0)     end function add      !> Concatenate an escape code with a string and turn it into an actual escape sequence     pure module function concat_left(lval, code) result(str)         !> String to add the escape code to         character(len=*), intent(in) :: lval         !> Escape sequence         type(ansi_code), intent(in) :: code         !> Concatenated string         character(len=:), allocatable :: str          str = lval // to_string(code)     end function concat_left      !> Concatenate an escape code with a string and turn it into an actual escape sequence     pure module function concat_right(code, rval) result(str)         !> String to add the escape code to         character(len=*), intent(in) :: rval         !> Escape sequence         type(ansi_code), intent(in) :: code         !> Concatenated string         character(len=:), allocatable :: str          str = to_string(code) // rval     end function concat_right      !> Concatenate an escape code with a string and turn it into an actual escape sequence     pure module function concat_left_str(lval, code) result(str)         !> String to add the escape code to         type(string_type), intent(in) :: lval         !> Escape sequence         type(ansi_code), intent(in) :: code         !> Concatenated string         type(string_type) :: str          str = lval // to_string(code)     end function concat_left_str      !> Concatenate an escape code with a string and turn it into an actual escape sequence     pure module function concat_right_str(code, rval) result(str)         !> String to add the escape code to         type(string_type), intent(in) :: rval         !> Escape sequence         type(ansi_code), intent(in) :: code         !> Concatenated string         type(string_type) :: str          str = to_string(code) // rval     end function concat_right_str  end submodule stdlib_ansi_operator 
stdlib_ansi_to_string.f90_stripped    submodule (stdlib_ansi) stdlib_ansi_to_string     implicit none      character, parameter :: esc = achar(27), chars(0:9) = &         ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]  contains           pure module function to_string_ansi_code(code) result(str)                  type(ansi_code), intent(in) :: code                  character(len=:), allocatable :: str          if (anycolor(code)) then             str = esc // "[0"               if (code%style > 0 .and. code%style < 10) str = str // ";" // chars(code%style)             if (code%fg >= 0 .and. code%fg < 10) str = str // ";3" // chars(code%fg)             if (code%bg >= 0 .and. code%bg < 10) str = str // ";4" // chars(code%bg)             str = str // "m"         else             str = ""         end if     end function to_string_ansi_code           pure function anycolor(code)                  type(ansi_code), intent(in) :: code                  logical :: anycolor          anycolor = code%fg >= 0 .or. code%bg >= 0 .or. code%style >= 0     end function anycolor  end submodule stdlib_ansi_to_string 
stdlib_ansi_to_string.f90_comments ! SPDX-Identifier: MIT  !> Implementation of the conversion to enumerator and identifier types to strings submodule (stdlib_ansi) stdlib_ansi_to_string     implicit none      character, parameter :: esc = achar(27), chars(0:9) = &         ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]  contains      !> Transform a color code into an actual ANSI escape sequence     pure module function to_string_ansi_code(code) result(str)         !> Color code to be used         type(ansi_code), intent(in) :: code         !> ANSI escape sequence representing the color code         character(len=:), allocatable :: str          if (anycolor(code)) then             str = esc // "[0"  ! Always reset the style             if (code%style > 0 .and. code%style < 10) str = str // ";" // chars(code%style)             if (code%fg >= 0 .and. code%fg < 10) str = str // ";3" // chars(code%fg)             if (code%bg >= 0 .and. code%bg < 10) str = str // ";4" // chars(code%bg)             str = str // "m"         else             str = ""         end if     end function to_string_ansi_code      !> Check whether the code describes any color / style or is just a stub     pure function anycolor(code)         !> Escape sequence         type(ansi_code), intent(in) :: code         !> Any color / style is active         logical :: anycolor          anycolor = code%fg >= 0 .or. code%bg >= 0 .or. code%style >= 0     end function anycolor  end submodule stdlib_ansi_to_string 
stdlib_array.f90_stripped      module stdlib_array   implicit none   private    public :: trueloc, falseloc  contains                pure function trueloc(array, lbound) result(loc)          logical, intent(in) :: array(:)          integer, intent(in), optional :: lbound          integer :: loc(count(array))      call logicalloc(loc, array, .true., lbound)   end function trueloc                pure function falseloc(array, lbound) result(loc)          logical, intent(in) :: array(:)          integer, intent(in), optional :: lbound          integer :: loc(count(.not.array))      call logicalloc(loc, array, .false., lbound)   end function falseloc       pure subroutine logicalloc(loc, array, truth, lbound)          integer, intent(out) :: loc(:)          logical, intent(in) :: array(:)          logical, intent(in) :: truth          integer, intent(in), optional :: lbound     integer :: i, pos, offset      offset = 0     if (present(lbound)) offset = lbound - 1      i = 0     do pos = 1, size(array)       if (array(pos).eqv.truth) then         i = i + 1         loc(i) = pos + offset       end if     end do   end subroutine logicalloc  end module stdlib_array 
stdlib_array.f90_comments ! SPDX-Identifier: MIT  !> Module for index manipulation and general array handling !> !> The specification of this module is available [here](../page/specs/stdlib_array.html). module stdlib_array   implicit none   private    public :: trueloc, falseloc  contains    !> Version: experimental   !>   !> Return the positions of the true elements in array.   !> [Specification](../page/specs/stdlib_array.html#trueloc)   pure function trueloc(array, lbound) result(loc)     !> Mask of logicals     logical, intent(in) :: array(:)     !> Lower bound of array to index     integer, intent(in), optional :: lbound     !> Locations of true elements     integer :: loc(count(array))      call logicalloc(loc, array, .true., lbound)   end function trueloc    !> Version: experimental   !>   !> Return the positions of the false elements in array.   !> [Specification](../page/specs/stdlib_array.html#falseloc)   pure function falseloc(array, lbound) result(loc)     !> Mask of logicals     logical, intent(in) :: array(:)     !> Lower bound of array to index     integer, intent(in), optional :: lbound     !> Locations of false elements     integer :: loc(count(.not.array))      call logicalloc(loc, array, .false., lbound)   end function falseloc    !> Return the positions of the truthy elements in array   pure subroutine logicalloc(loc, array, truth, lbound)     !> Locations of truthy elements     integer, intent(out) :: loc(:)     !> Mask of logicals     logical, intent(in) :: array(:)     !> Truthy value     logical, intent(in) :: truth     !> Lower bound of array to index     integer, intent(in), optional :: lbound     integer :: i, pos, offset      offset = 0     if (present(lbound)) offset = lbound - 1      i = 0     do pos = 1, size(array)       if (array(pos).eqv.truth) then         i = i + 1         loc(i) = pos + offset       end if     end do   end subroutine logicalloc  end module stdlib_array 
stdlib_error.f90_stripped module stdlib_error           use, intrinsic :: iso_fortran_env, only: stderr => error_unit use stdlib_optval, only: optval implicit none private  interface      module subroutine error_stop(msg, code)                                             character(*), intent(in) :: msg         integer, intent(in), optional :: code     end subroutine error_stop end interface  public :: check, error_stop  contains  subroutine check(condition, msg, code, warn)                                                                                                                                                                                                                    logical, intent(in) :: condition     character(*), intent(in), optional :: msg     integer, intent(in), optional :: code     logical, intent(in), optional :: warn     character(*), parameter :: msg_default = '      if (.not. condition) then         if (optval(warn, .false.)) then             write(stderr,*) optval(msg, msg_default)         else             call error_stop(optval(msg, msg_default), optval(code, 1))         end if     end if  end subroutine check  end module stdlib_error 
stdlib_error.f90_comments module stdlib_error     !! Provides support for catching and handling errors     !! ([Specification](../page/specs/stdlib_error.html)) use, intrinsic :: iso_fortran_env, only: stderr => error_unit use stdlib_optval, only: optval implicit none private  interface ! f{08,18}estop.f90     module subroutine error_stop(msg, code)         !! version: experimental         !!         !! Provides a call to `error stop` and allows the user to specify a code and message         !! ([Specification](..//page/specs/stdlib_error.html#description_1))         character(*), intent(in) :: msg         integer, intent(in), optional :: code     end subroutine error_stop end interface  public :: check, error_stop  contains  subroutine check(condition, msg, code, warn)     !! version: experimental     !!     !! Checks the value of a logical condition     !! ([Specification](../page/specs/stdlib_error.html#description))     !!     !!##### Behavior     !!     !! If `condition == .false.` and:     !!     !!   * No other arguments are provided, it stops the program with the default     !!     message and exit code `1`;     !!   * `msg` is provided, it prints the value of `msg`;     !!   * `code` is provided, it stops the program with the given exit code;     !!   * `warn` is provided and `.true.`, it doesn't stop the program and prints     !!     the message.     !!     !!##### Examples     !!     !!* If `a /= 5`, stops the program with exit code `1`     !!  and prints `Check failed.`     !!``` fortran     !!  call check(a == 5)     !!```     !!     !!* As above, but prints `a == 5 failed`.     !!``` fortran     !!  call check(a == 5, msg='a == 5 failed.')     !!```     !!     !!* As above, but doesn't stop the program.     !!``` fortran     !!  call check(a == 5, msg='a == 5 failed.', warn=.true.)     !!```     !!     !!* As example #2, but stops the program with exit code `77`     !!``` fortran     !!  call check(a == 5, msg='a == 5 failed.', code=77)     !!```      !     ! Arguments     ! ---------      logical, intent(in) :: condition     character(*), intent(in), optional :: msg     integer, intent(in), optional :: code     logical, intent(in), optional :: warn     character(*), parameter :: msg_default = 'Check failed.'      if (.not. condition) then         if (optval(warn, .false.)) then             write(stderr,*) optval(msg, msg_default)         else             call error_stop(optval(msg, msg_default), optval(code, 1))         end if     end if  end subroutine check  end module stdlib_error 
stdlib_hashmap_chaining.f90_stripped          submodule(stdlib_hashmaps) stdlib_hashmap_chaining         implicit none       character(len=*), parameter ::                                            &         alloc_inv_fault    = "                              "fault.",                                        &         alloc_slots_fault  = "                              "fault.",                                        &         conflicting_key    = "KEY already exists in MAP.",                    &         expand_slots_fail  = "                              "max bits.",                                     &         init_slots_pow_fail = "SLOT_BITS is not between                                "and MAX_BITS.",                                &         invalid_inmap      = "INMAP was not a valid INVERSE index.",          &         map_consist_fault  = "The hash map found a inconsistency."      character(len=*), parameter :: submodule_name = "STDLIB_HASHMAP_CHAINING"      interface expand_slots            module procedure expand_chaining_slots     end interface expand_slots      interface extend_map_entry_pool            module procedure extend_chaining_map_entry_pool     end interface extend_map_entry_pool      interface free_map            module procedure free_chaining_map     end interface free_map      interface free_map_entry_pool             module procedure free_map_entry_pool     end interface free_map_entry_pool      interface get_other_data            module procedure get_other_chaining_data     end interface get_other_data      interface init            module procedure init_chaining_map     end interface init      interface rehash             module procedure rehash_chaining_map     end interface rehash      interface remove            module procedure remove_chaining_entry      end interface remove      interface set_other_data            module procedure set_other_chaining_data     end interface set_other_data  contains         subroutine expand_chaining_slots( map )                type(chaining_hashmap_type), intent(inout) :: map          type(chaining_map_entry_type), pointer    :: current_entry         type(chaining_map_entry_ptr), allocatable :: dummy_slots(:)         integer(int_index)                        :: min_size, new_size         integer(int_index)                        :: old_size, &                                                      slot_index         integer(int32)                            :: bits, &                                                      stat         character(256) :: errmsg         character(*), parameter :: procedure = 'EXPAND_SLOTS'          if ( map % nbits == max_bits ) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 expand_slots_fail         end if          old_size = size(map % slots, kind=int_index)         determine_new_size: if ( map % num_entries <= old_size ) then              new_size = 2*old_size             bits = map % nbits + 1         else               min_size = map % num_entries             new_size = old_size             bits = map % nbits             do                 bits = bits + 1                 new_size = new_size * 2                 if ( bits >= max_bits .OR. new_size >= min_size ) exit             end do         end if determine_new_size          allocate( dummy_slots(0:new_size-1), stat=stat, errmsg=errmsg )         if (stat /= 0) then             write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)             error stop submodule_name // ' % ' // procedure // ': ' // &                 alloc_slots_fault         end if          map % nbits = bits         do slot_index=0, new_size-1             dummy_slots(slot_index) % target => null()          end do          map % total_probes = map % total_probes + map % probe_count         map % probe_count = 0            do slot_index=0, old_size-1             do while( associated(map % slots(slot_index) % target) )                 current_entry => map % slots(slot_index) % target                 map % slots(slot_index) % target => current_entry % next                 call remap( dummy_slots, current_entry, map % nbits )             end do         end do          call move_alloc( dummy_slots, map % slots )      contains          subroutine remap(slots, gentry, bits)             type(chaining_map_entry_ptr), intent(inout)          :: slots(0:)             type(chaining_map_entry_type), intent(inout), target :: gentry             integer(int_hash), intent(in)                        :: bits              integer(int_index)                     :: hash_index             type(chaining_map_entry_type), pointer :: where_loc              hash_index = fibonacci_hash( gentry % hash_val, bits )             where_loc => slots(hash_index) % target             gentry % next => null()               if ( associated( where_loc ) ) then                 do while ( associated(where_loc % next) )                     where_loc => where_loc % next                 end do                 where_loc % next => gentry             else                 slots(hash_index) % target => gentry             end if          end subroutine remap      end subroutine expand_chaining_slots       subroutine extend_chaining_map_entry_pool(map)               type(chaining_hashmap_type), intent(inout) :: map          type(chaining_map_entry_pool), pointer :: pool          allocate(pool)         allocate(pool % more_map_entries(0:pool_size-1))         pool % next = 0          pool % lastpool => map % cache         map % cache => pool      end subroutine extend_chaining_map_entry_pool        module subroutine free_chaining_map( map )               type(chaining_hashmap_type), intent(inout) :: map          integer(int_index) :: i         type(chaining_map_entry_type), pointer :: next          if ( allocated( map % slots ) ) then             remove_slot_links: do i=0, size( map % slots ) - 1                 if ( associated( map % slots(i) % target ) ) then                     map % slots(i) % target => null()                 end if             end do remove_slot_links             deallocate( map % slots )         end if          if ( allocated( map % inverse) ) then             remove_links: do i=1, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     map % inverse(i) % target % next => null()                 end if                 map % inverse(i) % target => null()             end do remove_links             deallocate( map % inverse )         end if          free_free_list: do             if ( associated( map % free_list) ) then                 next => map % free_list % next                 map % free_list => next                 cycle free_free_list             else                 map % num_free = 0                 exit free_free_list             end if         end do free_free_list          if ( associated( map % cache ) ) call free_map_entry_pool(map % cache)          map % num_entries = 0      end subroutine free_chaining_map       recursive subroutine free_map_entry_pool(pool)                type(chaining_map_entry_pool), intent(inout), pointer :: pool          if ( .not.  associated(pool) ) return         call free_map_entry_pool(pool % lastpool)         deallocate( pool )      end subroutine free_map_entry_pool       module subroutine get_all_chaining_keys(map, all_keys)                class(chaining_hashmap_type), intent(in) :: map         type(key_type), allocatable, intent(out) :: all_keys(:)                  integer(int32) :: num_keys         integer(int_index) :: i, key_idx          num_keys = map % entries()         allocate( all_keys(num_keys) )         if ( num_keys == 0 ) return          if( allocated( map % inverse ) ) then             key_idx = 1_int_index             do i=1_int_index, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     all_keys(key_idx) = map % inverse(i) % target % key                     key_idx = key_idx + 1_int_index                 end if             end do          end if      end subroutine get_all_chaining_keys       module subroutine get_other_chaining_data( map, key, other, exists )                  class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(out)               :: other         logical, intent(out), optional              :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'GET_OTHER_DATA'          call in_chain_map(map, inmap, key)         if ( inmap <= 0 .or. &              inmap > size(map % inverse, kind=int_index ) ) then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             if (present(exists) ) exists = .true.             call copy_other( map % inverse(inmap) % target % other, other )         else             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             end if         end if      end subroutine get_other_chaining_data       subroutine in_chain_map(map, inmap, key)                   class(chaining_hashmap_type), intent(inout) :: map         integer(int_index), intent(out)             :: inmap         type(key_type), intent(in)                  :: key          integer(int_hash)                      :: hash_val, hash_index         type(chaining_map_entry_type), pointer :: gentry, pentry, sentry          if ( map % probe_count > inmap_probe_factor * map % call_count ) then             if ( map % nbits < max_bits .AND. &                  map % num_entries > size( map % slots, kind=int_index ) ) then                 call expand_slots(map)             end if         end if         map % call_count = map % call_count + 1         hash_val = map % hasher( key )         hash_index = fibonacci_hash( hash_val, map % nbits )         pentry => map % slots(hash_index) % target         sentry => pentry          climb_chain: do             gentry => pentry             map % probe_count = map % probe_count + 1             if (.not. associated( gentry ) ) then                 inmap = 0                 return             else if ( hash_val == gentry % hash_val ) then                 if ( key == gentry % key ) then                            inmap = gentry % inmap                     return                 end if             end if             pentry => gentry % next         end do climb_chain      end subroutine in_chain_map       module subroutine init_chaining_map( map,        &                                          hasher,     &                                          slots_bits, &                                          status )                        class(chaining_hashmap_type), intent(out)  :: map         procedure(hasher_fun)                      :: hasher         integer, intent(in), optional              :: slots_bits         integer(int32), intent(out), optional      :: status          character(256)          :: errmsg         integer(int_index)      :: index         character(*), parameter :: procedure = 'INIT'         integer(int_index)      :: slots         integer(int32)          :: stat          map % call_count = 0         map % probe_count = 0         map % total_probes = 0          map % hasher => hasher          call free_chaining_map( map )          if ( present(slots_bits) ) then             if ( slots_bits < 6 .OR. slots_bits > max_bits ) then                 if ( present(status) ) then                     status = array_size_error                     return                 else                     error stop submodule_name // ' % ' // procedure // ': ' // &                         init_slots_pow_fail                 end if             end if             map % nbits = slots_bits         else             map % nbits = min( default_bits, max_bits )         end if          slots = 2_int_index**map % nbits          allocate( map % slots(0:slots-1), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present(status) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_slots_fault             end if         end if         do index = 0, size( map % slots, kind=int_index )-1             map % slots(index) % target => null()          end do           allocate( map % inverse(1:slots), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present( status ) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if         end if         do index=1, size(map % inverse, kind=int_index)             map % inverse(index) % target => null()         end do          call extend_map_entry_pool(map)          if (present(status) ) status = success      end subroutine init_chaining_map       pure module function chaining_loading( map )              class(chaining_hashmap_type), intent(in) :: map         real :: chaining_loading          chaining_loading = real( map % num_entries ) / &                            real( size( map % slots, kind=int_index ) )      end function chaining_loading       module subroutine map_chain_entry(map, key, other, conflict)                   class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(in), optional      :: other         logical, intent(out), optional              :: conflict          integer(int_hash)                      :: hash_index         integer(int_hash)                      :: hash_val         integer(int_index)                     :: inmap         type(chaining_map_entry_type), pointer :: new_ent         type(chaining_map_entry_type), pointer :: gentry, pentry, sentry         character(*), parameter :: procedure = 'MAP_ENTRY'          hash_val = map % hasher( key )          if ( map % probe_count > map_probe_factor * map % call_count ) then             call expand_slots(map)         end if         map % call_count = map % call_count + 1         hash_index = fibonacci_hash( hash_val, map % nbits )         pentry => map % slots(hash_index) % target         sentry => pentry          do             gentry => pentry             map % probe_count = map % probe_count + 1             if ( .not. associated( gentry ) ) then                 call allocate_chaining_map_entry( map, new_ent )                 new_ent % hash_val = hash_val                     new_ent % next => map % slots(hash_index) % target                 map % slots(hash_index) % target => new_ent                 call copy_key( key, new_ent % key )                 if ( present(other) ) call copy_other( other, new_ent % other )                  if ( new_ent % inmap == 0 ) then                     map % num_entries = map % num_entries + 1                     inmap = map % num_entries                 else                     inmap = new_ent % inmap                 end if                  if ( inmap == size( map % inverse, kind=int_index ) ) then                     call expand_inverse( map )                 end if                 new_ent % inmap = inmap                 map % inverse(inmap) % target => new_ent                 if ( present(conflict) ) conflict = .false.                  return              else if ( hash_val == gentry % hash_val ) then                 if ( key == gentry % key ) then                     inmap = gentry % inmap                     if ( .not. associated( pentry, sentry ) ) then                                                  pentry => gentry % next                         gentry % next => sentry                         sentry => gentry                     end if                     if ( present(conflict) ) then                         conflict = .true.                     else                         error stop submodule_name // ' % ' // procedure &                                   // ': ' // conflicting_key                     end if                     return                 end if             end if             pentry => gentry % next          end do      contains          subroutine allocate_chaining_map_entry(map, bucket)               type(chaining_hashmap_type), intent(inout)         :: map             type(chaining_map_entry_type), pointer, intent(out) :: bucket              type(chaining_map_entry_pool), pointer :: pool              pool => map % cache             map % num_entries = map % num_entries + 1             if ( associated(map % free_list) ) then                  bucket         => map % free_list                 map % free_list => bucket % next                 map % num_free = map % num_free - 1             else                  if ( pool % next == pool_size ) then                      call extend_map_entry_pool(map)                     pool => map % cache                 end if                 bucket      => pool % more_map_entries(pool % next)                 pool % next =  pool % next + 1                  if ( map % num_entries > &                      size( map % inverse, kind=int_index ) ) &                     then                     call expand_inverse( map )                 end if                 bucket % inmap = map % num_entries             end if          end subroutine allocate_chaining_map_entry           subroutine expand_inverse(map)              type(chaining_hashmap_type), intent(inout) :: map             type(chaining_map_entry_ptr), allocatable  :: dummy_inverse(:)             integer(int32) :: stat             character(256) :: errmsg             character(*), parameter :: procedure = 'MAP_ENTRY'              allocate( dummy_inverse( 1:2*size(map % inverse,     &                                               kind=int_index) ), &                       stat=stat,                                 &                       errmsg=errmsg )             if ( stat /= 0 ) then                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if              dummy_inverse(1:size(map % inverse, kind=int_index)) = &                 map % inverse(:)              call move_alloc( dummy_inverse, map % inverse )          end subroutine expand_inverse      end subroutine map_chain_entry       module subroutine rehash_chaining_map( map, hasher )                class(chaining_hashmap_type), intent(inout) :: map         procedure(hasher_fun)                       :: hasher          integer(int_hash)  :: hash_val         integer(int_index) :: i         integer(int_index) :: index          map % hasher => hasher          do i=0, size( map % slots, kind=int_index ) - 1             map % slots(i) % target => null()         end do          do i=1, map % num_entries + map % num_free             if ( .not. associated( map % inverse(i) % target ) ) cycle             hash_val = map % hasher ( map % inverse(i) % target % key )             map % inverse(i) % target % hash_val = hash_val             index = fibonacci_hash( hash_val, map % nbits )             map % inverse(i) % target % inmap = i             if ( associated( map % slots(index) % target ) ) then                 map % inverse(i) % target % next => map % slots(index) % target                 map % slots(index) % target => map % inverse(i) % target             else                 map % slots(index) % target => map % inverse(i) % target                 map % slots(index) % target % next => null()             end if         end do      end subroutine rehash_chaining_map       module subroutine remove_chaining_entry(map, key, existed)                class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         logical, intent(out), optional              :: existed          type(chaining_map_entry_type), pointer :: bucket, aentry, bentry, centry         integer(int_hash)                      :: hash_val         integer(int_index)                     :: inmap, k, level          call in_chain_map( map, inmap, key )         if ( inmap < 1 .or. inmap > size( map % inverse ) ) then             if ( present( existed ) ) existed = .false.             return         end if          bucket => map % inverse(inmap) % target         if ( .not. associated(bucket) ) then             if ( present( existed ) ) existed = .false.             return         end if         if ( present(existed) ) existed = .true.         hash_val = bucket % hash_val         k = fibonacci_hash( hash_val, map % nbits )         allocate(aentry)         aentry => map % slots(k) % target         if ( associated(aentry) ) then             if ( aentry % inmap == inmap ) then                 bentry => aentry % next                 map % slots(k) % target => bentry                 aentry % next => map % free_list                 map % free_list => aentry                 map % inverse(inmap) % target => null()                 map % num_free = map % num_free + 1                 map % num_entries = map % num_entries - 1                 return             end if         else             return         end if         level = 1         centry => map % slots(k) % target         aentry => aentry % next          FIND_SLOTS_ENTRY:do             if ( .not. associated(aentry) ) return             if ( aentry % inmap == inmap ) exit             centry => aentry             aentry => aentry % next             level = level + 1         end do FIND_SLOTS_ENTRY          bentry => aentry % next         aentry % next => map % free_list         map % free_list => aentry         centry % next => bentry         map % inverse(inmap) % target => null()         map % num_free = map % num_free + 1      end subroutine remove_chaining_entry       module subroutine set_other_chaining_data( map, key, other, exists )                   class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(in)                :: other         logical, intent(out), optional              :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'SET_OTHER_DATA'          call in_chain_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             associate( target => map % inverse(inmap) % target )               call copy_other( other, target % other )               if ( present(exists) ) exists = .true.               return             end associate         else             error stop submodule_name // ' % ' // procedure // ': ' // &                 invalid_inmap         end if      end subroutine set_other_chaining_data       module function total_chaining_depth( map ) result(total_depth)               class(chaining_hashmap_type), intent(in) :: map         integer(int_depth)                       :: total_depth          type(chaining_map_entry_type), pointer :: current_key         integer(int_index) :: slot, slots         integer(int_depth) :: index          total_depth = 0_int_depth         slots = size( map % slots, kind=int_index )         do slot=0, slots-1             current_key => map % slots(slot) % target             index = 0_int_depth             do while( associated(current_key) )                 index = index + 1_int_depth                 total_depth = total_depth + index                 current_key => current_key % next             end do         end do      end function total_chaining_depth       module subroutine chaining_key_test(map, key, present)                 class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         logical, intent(out)                        :: present          integer(int_index) :: inmap          call in_chain_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             present = .false.         else             present = associated( map % inverse(inmap) % target )         end if      end subroutine chaining_key_test   end submodule stdlib_hashmap_chaining 
stdlib_hashmap_chaining.f90_comments !! The module STDLIB_HASHMAP_CHAINING implements a simple separate !! chaining hash map. The implementation is loosely based on a C !! implementation by David Chase, http://chasewoerner.org/src/hasht/, for !! which he has given permission to use in the Fortran Standard Library.  ! Note an error in the code caused attempts to deallocate already deallocated ! entries. This did not cause stat to be non-zero, but did cause system errors, ! on my Mac. I therefore decided to remove all deallocation error reporting.  submodule(stdlib_hashmaps) stdlib_hashmap_chaining !! Version: Experimental !! !! Implements a simple separate chaining hash map.      implicit none  ! Error messages     character(len=*), parameter ::                                            &         alloc_inv_fault    = "CHAINING_HASHMAP_TYPE % INVERSE allocation " // &                              "fault.",                                        &         alloc_slots_fault  = "CHAINING_HASHMAP_TYPE % SLOTS allocation " //   &                              "fault.",                                        &         conflicting_key    = "KEY already exists in MAP.",                    &         expand_slots_fail  = "CHAINING_HASHMAP_TYPE % SLOTS allocation > " // &                              "max bits.",                                     &         init_slots_pow_fail = "SLOT_BITS is not between DEFAULT_BITS " //     &                               "and MAX_BITS.",                                &         invalid_inmap      = "INMAP was not a valid INVERSE index.",          &         map_consist_fault  = "The hash map found a inconsistency."      character(len=*), parameter :: submodule_name = "STDLIB_HASHMAP_CHAINING"      interface expand_slots !! Version: Experimental !! !! Interface to internal procedure that expands the number of map slots.         module procedure expand_chaining_slots     end interface expand_slots      interface extend_map_entry_pool !! Version: Experimental !! !! Interface to internal procedure that expands a chaining map entry pool.         module procedure extend_chaining_map_entry_pool     end interface extend_map_entry_pool      interface free_map !! Version: Experimental !! !! Interface to procedure that finalizes a chaining hash map.         module procedure free_chaining_map     end interface free_map      interface free_map_entry_pool !! Version: Experimental !! !! Interface to internal procedure that finalizes a chaining hash map !! entry pool.         module procedure free_map_entry_pool     end interface free_map_entry_pool      interface get_other_data !! Version: Experimental !! !! Interface to procedure that gets an entry's other data.         module procedure get_other_chaining_data     end interface get_other_data      interface init !! Version: Experimental !! !! Interface to initialization procedure for a chaining hash map.         module procedure init_chaining_map     end interface init      interface rehash !! Version: Experimental !! !! Interface to a procedure that changes the hash function that !! is used to map the keys into a chaining hash map.         module procedure rehash_chaining_map     end interface rehash      interface remove !! Version: Experimental !! !! Interface to a procedure that removes the entry associated with a key         module procedure remove_chaining_entry ! Chase's delent     end interface remove      interface set_other_data !! Version: Experimental !! !! Interface to a procedure that changes the other data associated with a key         module procedure set_other_chaining_data     end interface set_other_data  contains  !  Internal routine to make a duplicate map with more hash slots. !  Note David Chase had pointer returning functions, but the logic did not !  depend on the result value     subroutine expand_chaining_slots( map ) !! Version: Experimental !! !! Internal routine to make a duplicate map with more hash slots. !! Doubles the size of the map % slots array !! Arguments: !!     map - the hash map whose hash slots are to be expanded !         type(chaining_hashmap_type), intent(inout) :: map          type(chaining_map_entry_type), pointer    :: current_entry         type(chaining_map_entry_ptr), allocatable :: dummy_slots(:)         integer(int_index)                        :: min_size, new_size         integer(int_index)                        :: old_size, &                                                      slot_index         integer(int32)                            :: bits, &                                                      stat         character(256) :: errmsg         character(*), parameter :: procedure = 'EXPAND_SLOTS'          if ( map % nbits == max_bits ) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 expand_slots_fail         end if          old_size = size(map % slots, kind=int_index)         determine_new_size: if ( map % num_entries <= old_size ) then ! Expand by factor of two to improve efficiency             new_size = 2*old_size             bits = map % nbits + 1         else ! Expand so the number of slots is no more than 2**max_bits but otherwise ! at least the number of entries             min_size = map % num_entries             new_size = old_size             bits = map % nbits             do                 bits = bits + 1                 new_size = new_size * 2                 if ( bits >= max_bits .OR. new_size >= min_size ) exit             end do         end if determine_new_size          allocate( dummy_slots(0:new_size-1), stat=stat, errmsg=errmsg )         if (stat /= 0) then             write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)             error stop submodule_name // ' % ' // procedure // ': ' // &                 alloc_slots_fault         end if          map % nbits = bits         do slot_index=0, new_size-1             dummy_slots(slot_index) % target => null() ! May be redundant         end do          map % total_probes = map % total_probes + map % probe_count         map % probe_count = 0  ! This maps old slots entries to new slots, but we could also map inverse ! entries to new_slots         do slot_index=0, old_size-1             do while( associated(map % slots(slot_index) % target) )                 current_entry => map % slots(slot_index) % target                 map % slots(slot_index) % target => current_entry % next                 call remap( dummy_slots, current_entry, map % nbits )             end do         end do          call move_alloc( dummy_slots, map % slots )      contains          subroutine remap(slots, gentry, bits)             type(chaining_map_entry_ptr), intent(inout)          :: slots(0:)             type(chaining_map_entry_type), intent(inout), target :: gentry             integer(int_hash), intent(in)                        :: bits              integer(int_index)                     :: hash_index             type(chaining_map_entry_type), pointer :: where_loc              hash_index = fibonacci_hash( gentry % hash_val, bits )             where_loc => slots(hash_index) % target             gentry % next => null() ! May be redundant              if ( associated( where_loc ) ) then                 do while ( associated(where_loc % next) )                     where_loc => where_loc % next                 end do                 where_loc % next => gentry             else                 slots(hash_index) % target => gentry             end if          end subroutine remap      end subroutine expand_chaining_slots       subroutine extend_chaining_map_entry_pool(map) ! gent_pool_new !! Version: Experimental !! !! Add more map_entrys to the pool head !! Arguments: !!     pool - a chaining map entry pool         type(chaining_hashmap_type), intent(inout) :: map          type(chaining_map_entry_pool), pointer :: pool          allocate(pool)         allocate(pool % more_map_entries(0:pool_size-1))         pool % next = 0 ! may be redundant         pool % lastpool => map % cache         map % cache => pool      end subroutine extend_chaining_map_entry_pool   !  Internal final routine to free a map and its memory     module subroutine free_chaining_map( map ) !! Version: Experimental !! !! Frees internal memory of an chaining map !! Arguments: !!     map - the chaining hash map whose memory is to be freed !         type(chaining_hashmap_type), intent(inout) :: map          integer(int_index) :: i         type(chaining_map_entry_type), pointer :: next          if ( allocated( map % slots ) ) then             remove_slot_links: do i=0, size( map % slots ) - 1                 if ( associated( map % slots(i) % target ) ) then                     map % slots(i) % target => null()                 end if             end do remove_slot_links             deallocate( map % slots )         end if          if ( allocated( map % inverse) ) then             remove_links: do i=1, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     map % inverse(i) % target % next => null()                 end if                 map % inverse(i) % target => null()             end do remove_links             deallocate( map % inverse )         end if          free_free_list: do             if ( associated( map % free_list) ) then                 next => map % free_list % next                 map % free_list => next                 cycle free_free_list             else                 map % num_free = 0                 exit free_free_list             end if         end do free_free_list          if ( associated( map % cache ) ) call free_map_entry_pool(map % cache)          map % num_entries = 0      end subroutine free_chaining_map       recursive subroutine free_map_entry_pool(pool) ! gent_pool_free !! Version: Experimental !! !! Recursively descends map entry pool list freeing each element !! Arguments: !!     pool  The map entry pool whose elements are to be freed !         type(chaining_map_entry_pool), intent(inout), pointer :: pool          if ( .not.  associated(pool) ) return         call free_map_entry_pool(pool % lastpool)         deallocate( pool )      end subroutine free_map_entry_pool       module subroutine get_all_chaining_keys(map, all_keys) !! Version: Experimental !! !! Returns all the keys contained in a hash map !! Arguments: !!     map - a chaining hash map !!     all_keys - all the keys contained in a hash map !         class(chaining_hashmap_type), intent(in) :: map         type(key_type), allocatable, intent(out) :: all_keys(:)                  integer(int32) :: num_keys         integer(int_index) :: i, key_idx          num_keys = map % entries()         allocate( all_keys(num_keys) )         if ( num_keys == 0 ) return          if( allocated( map % inverse ) ) then             key_idx = 1_int_index             do i=1_int_index, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     all_keys(key_idx) = map % inverse(i) % target % key                     key_idx = key_idx + 1_int_index                 end if             end do          end if      end subroutine get_all_chaining_keys       module subroutine get_other_chaining_data( map, key, other, exists ) !! Version: Experimental !! !! Returns the other data associated with the inverse table index !! Arguments: !!     map    - a chaining hash map !!     key    - the key associated with a map entry !!     other  - the other data associated with the key !!     exists - a logical flag indicating whether an entry with that key exists !         class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(out)               :: other         logical, intent(out), optional              :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'GET_OTHER_DATA'          call in_chain_map(map, inmap, key)         if ( inmap <= 0 .or. &              inmap > size(map % inverse, kind=int_index ) ) then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             if (present(exists) ) exists = .true.             call copy_other( map % inverse(inmap) % target % other, other )         else             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             end if         end if      end subroutine get_other_chaining_data       subroutine in_chain_map(map, inmap, key) !! Version: Experimental !! !! Returns the index into the INVERSE array associated with the KEY !! Arguments: !!     map   - the hash map of interest !!     inmap - the returned index into the INVERSE array of entry pointers. !!             A value of zero indicates that an entry with that key was not !!             found. !!     key   - the key identifying the entry of interest !         class(chaining_hashmap_type), intent(inout) :: map         integer(int_index), intent(out)             :: inmap         type(key_type), intent(in)                  :: key          integer(int_hash)                      :: hash_val, hash_index         type(chaining_map_entry_type), pointer :: gentry, pentry, sentry          if ( map % probe_count > inmap_probe_factor * map % call_count ) then             if ( map % nbits < max_bits .AND. &                  map % num_entries > size( map % slots, kind=int_index ) ) then                 call expand_slots(map)             end if         end if         map % call_count = map % call_count + 1         hash_val = map % hasher( key )         hash_index = fibonacci_hash( hash_val, map % nbits )         pentry => map % slots(hash_index) % target         sentry => pentry          climb_chain: do             gentry => pentry             map % probe_count = map % probe_count + 1             if (.not. associated( gentry ) ) then                 inmap = 0                 return             else if ( hash_val == gentry % hash_val ) then                 if ( key == gentry % key ) then ! The swap to front seems to confuse gfortran's pointers !                    if ( .not. associated( pentry, sentry ) ) then !                    ! swap to front !                        pentry => gentry % next !                        gentry % next => sentry !                        sentry => gentry !                    end if                     inmap = gentry % inmap                     return                 end if             end if             pentry => gentry % next         end do climb_chain      end subroutine in_chain_map       module subroutine init_chaining_map( map,        &                                          hasher,     &                                          slots_bits, &                                          status ) !! Version: Experimental !! !! Routine to allocate an empty map with HASHER as the hash function, !! 2**SLOTS_BITS initial SIZE(map % slots), and SIZE(map % slots) limited !! to a maximum of 2**MAX_BITS. All fields are initialized. !! Arguments: !!     map         - the chaining hash map to be initialized !!     hasher      - the hash function to be used to map keys to slots !!     slots_bits - the bits of two used to initialize the number of slots !!     status      - an integer error status flag with the allowed values: !!         success - no problems were found !!         alloc_fault - map % slots or map % inverse could not be allocated !!         array_size_error - slots_bits is less than default_bits or !!             greater than max_bits !         class(chaining_hashmap_type), intent(out)  :: map         procedure(hasher_fun)                      :: hasher         integer, intent(in), optional              :: slots_bits         integer(int32), intent(out), optional      :: status          character(256)          :: errmsg         integer(int_index)      :: index         character(*), parameter :: procedure = 'INIT'         integer(int_index)      :: slots         integer(int32)          :: stat          map % call_count = 0         map % probe_count = 0         map % total_probes = 0          map % hasher => hasher          call free_chaining_map( map )          if ( present(slots_bits) ) then             if ( slots_bits < 6 .OR. slots_bits > max_bits ) then                 if ( present(status) ) then                     status = array_size_error                     return                 else                     error stop submodule_name // ' % ' // procedure // ': ' // &                         init_slots_pow_fail                 end if             end if             map % nbits = slots_bits         else             map % nbits = min( default_bits, max_bits )         end if          slots = 2_int_index**map % nbits          allocate( map % slots(0:slots-1), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present(status) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_slots_fault             end if         end if         do index = 0, size( map % slots, kind=int_index )-1             map % slots(index) % target => null() ! May be redundant         end do  ! 5*s from Chase's g_new_map         allocate( map % inverse(1:slots), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present( status ) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if         end if         do index=1, size(map % inverse, kind=int_index)             map % inverse(index) % target => null()         end do          call extend_map_entry_pool(map)          if (present(status) ) status = success      end subroutine init_chaining_map       pure module function chaining_loading( map ) !! Version: Experimental !! !! Returns the number of entries relative to slots in a hash map !! Arguments: !!      map - a chaining hash map         class(chaining_hashmap_type), intent(in) :: map         real :: chaining_loading          chaining_loading = real( map % num_entries ) / &                            real( size( map % slots, kind=int_index ) )      end function chaining_loading       module subroutine map_chain_entry(map, key, other, conflict) !! Version: Experimental !! !! Inserts an entry into the hash table !! Arguments: !!     map      - the hash table of interest !!     key      - the key identifying the entry !!     other    - other data associated with the key !!     conflict - logical flag indicating whether the entry key conflicts !!                 with an existing key !         class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(in), optional      :: other         logical, intent(out), optional              :: conflict          integer(int_hash)                      :: hash_index         integer(int_hash)                      :: hash_val         integer(int_index)                     :: inmap         type(chaining_map_entry_type), pointer :: new_ent         type(chaining_map_entry_type), pointer :: gentry, pentry, sentry         character(*), parameter :: procedure = 'MAP_ENTRY'          hash_val = map % hasher( key )          if ( map % probe_count > map_probe_factor * map % call_count ) then             call expand_slots(map)         end if         map % call_count = map % call_count + 1         hash_index = fibonacci_hash( hash_val, map % nbits )         pentry => map % slots(hash_index) % target         sentry => pentry          do             gentry => pentry             map % probe_count = map % probe_count + 1             if ( .not. associated( gentry ) ) then                 call allocate_chaining_map_entry( map, new_ent )                 new_ent % hash_val = hash_val ! Adding to tail of chain doesn't work on gfortran !                new_ent % next => sentry !                sentry => new_ent ! Adding to head of chain works on gfortran                 new_ent % next => map % slots(hash_index) % target                 map % slots(hash_index) % target => new_ent                 call copy_key( key, new_ent % key )                 if ( present(other) ) call copy_other( other, new_ent % other )                  if ( new_ent % inmap == 0 ) then                     map % num_entries = map % num_entries + 1                     inmap = map % num_entries                 else                     inmap = new_ent % inmap                 end if                  if ( inmap == size( map % inverse, kind=int_index ) ) then                     call expand_inverse( map )                 end if                 new_ent % inmap = inmap                 map % inverse(inmap) % target => new_ent                 if ( present(conflict) ) conflict = .false.                  return              else if ( hash_val == gentry % hash_val ) then                 if ( key == gentry % key ) then                     inmap = gentry % inmap                     if ( .not. associated( pentry, sentry ) ) then                         ! Swap to front                         pentry => gentry % next                         gentry % next => sentry                         sentry => gentry                     end if                     if ( present(conflict) ) then                         conflict = .true.                     else                         error stop submodule_name // ' % ' // procedure &                                   // ': ' // conflicting_key                     end if                     return                 end if             end if             pentry => gentry % next          end do      contains          subroutine allocate_chaining_map_entry(map, bucket) ! Chases gent_malloc !         allocates a hash bucket             type(chaining_hashmap_type), intent(inout)         :: map             type(chaining_map_entry_type), pointer, intent(out) :: bucket              type(chaining_map_entry_pool), pointer :: pool              pool => map % cache             map % num_entries = map % num_entries + 1             if ( associated(map % free_list) ) then !             Get hash bucket from free_list                 bucket         => map % free_list                 map % free_list => bucket % next                 map % num_free = map % num_free - 1             else !             Get hash bucket from pool                 if ( pool % next == pool_size ) then !                 Expand pool                     call extend_map_entry_pool(map)                     pool => map % cache                 end if                 bucket      => pool % more_map_entries(pool % next)                 pool % next =  pool % next + 1 ! 0s based                 if ( map % num_entries > &                      size( map % inverse, kind=int_index ) ) &                     then                     call expand_inverse( map )                 end if                 bucket % inmap = map % num_entries             end if          end subroutine allocate_chaining_map_entry           subroutine expand_inverse(map) !         Increase size of map % inverse             type(chaining_hashmap_type), intent(inout) :: map             type(chaining_map_entry_ptr), allocatable  :: dummy_inverse(:)             integer(int32) :: stat             character(256) :: errmsg             character(*), parameter :: procedure = 'MAP_ENTRY'              allocate( dummy_inverse( 1:2*size(map % inverse,     &                                               kind=int_index) ), &                       stat=stat,                                 &                       errmsg=errmsg )             if ( stat /= 0 ) then                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if              dummy_inverse(1:size(map % inverse, kind=int_index)) = &                 map % inverse(:)              call move_alloc( dummy_inverse, map % inverse )          end subroutine expand_inverse      end subroutine map_chain_entry       module subroutine rehash_chaining_map( map, hasher ) !! Version: Experimental !! !! Changes the hashing method of the table entries to that of HASHER. !! Arguments: !!     map    the table to be rehashed !!     hasher the hasher function to be used for the table !         class(chaining_hashmap_type), intent(inout) :: map         procedure(hasher_fun)                       :: hasher          integer(int_hash)  :: hash_val         integer(int_index) :: i         integer(int_index) :: index          map % hasher => hasher          do i=0, size( map % slots, kind=int_index ) - 1             map % slots(i) % target => null()         end do          do i=1, map % num_entries + map % num_free             if ( .not. associated( map % inverse(i) % target ) ) cycle             hash_val = map % hasher ( map % inverse(i) % target % key )             map % inverse(i) % target % hash_val = hash_val             index = fibonacci_hash( hash_val, map % nbits )             map % inverse(i) % target % inmap = i             if ( associated( map % slots(index) % target ) ) then                 map % inverse(i) % target % next => map % slots(index) % target                 map % slots(index) % target => map % inverse(i) % target             else                 map % slots(index) % target => map % inverse(i) % target                 map % slots(index) % target % next => null()             end if         end do      end subroutine rehash_chaining_map       module subroutine remove_chaining_entry(map, key, existed) !! Remove the entry, if any, that has the key !! Arguments: !!    map     - the table from which the entry is to be removed !!    key     - the key to an entry !!    existed - a logical flag indicating whether an entry with the key !!              was present in the original map !         class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         logical, intent(out), optional              :: existed          type(chaining_map_entry_type), pointer :: bucket, aentry, bentry, centry         integer(int_hash)                      :: hash_val         integer(int_index)                     :: inmap, k, level          call in_chain_map( map, inmap, key )         if ( inmap < 1 .or. inmap > size( map % inverse ) ) then             if ( present( existed ) ) existed = .false.             return         end if          bucket => map % inverse(inmap) % target         if ( .not. associated(bucket) ) then             if ( present( existed ) ) existed = .false.             return         end if         if ( present(existed) ) existed = .true.         hash_val = bucket % hash_val         k = fibonacci_hash( hash_val, map % nbits )         allocate(aentry)         aentry => map % slots(k) % target         if ( associated(aentry) ) then             if ( aentry % inmap == inmap ) then                 bentry => aentry % next                 map % slots(k) % target => bentry                 aentry % next => map % free_list                 map % free_list => aentry                 map % inverse(inmap) % target => null()                 map % num_free = map % num_free + 1                 map % num_entries = map % num_entries - 1                 return             end if         else             return         end if         level = 1         centry => map % slots(k) % target         aentry => aentry % next          FIND_SLOTS_ENTRY:do             if ( .not. associated(aentry) ) return             if ( aentry % inmap == inmap ) exit             centry => aentry             aentry => aentry % next             level = level + 1         end do FIND_SLOTS_ENTRY          bentry => aentry % next         aentry % next => map % free_list         map % free_list => aentry         centry % next => bentry         map % inverse(inmap) % target => null()         map % num_free = map % num_free + 1      end subroutine remove_chaining_entry       module subroutine set_other_chaining_data( map, key, other, exists ) !! Version: Experimental !! !! Change the other data associated with the key !! Arguments: !!     map    - the map with the entry of interest !!     key    - the key to the entry inthe map !!     other  - the new data to be associated with the key !!     exists - a logical flag indicating whether the key is already entered !!              in the map !         class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         type(other_type), intent(in)                :: other         logical, intent(out), optional              :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'SET_OTHER_DATA'          call in_chain_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             associate( target => map % inverse(inmap) % target )               call copy_other( other, target % other )               if ( present(exists) ) exists = .true.               return             end associate         else             error stop submodule_name // ' % ' // procedure // ': ' // &                 invalid_inmap         end if      end subroutine set_other_chaining_data       module function total_chaining_depth( map ) result(total_depth) !! Version: Experimental !! !! Returns the total number of ones based offsets of slot entries from !! their slot index for a hash map !! Arguments: !!     map - an chaining hash map         class(chaining_hashmap_type), intent(in) :: map         integer(int_depth)                       :: total_depth          type(chaining_map_entry_type), pointer :: current_key         integer(int_index) :: slot, slots         integer(int_depth) :: index          total_depth = 0_int_depth         slots = size( map % slots, kind=int_index )         do slot=0, slots-1             current_key => map % slots(slot) % target             index = 0_int_depth             do while( associated(current_key) )                 index = index + 1_int_depth                 total_depth = total_depth + index                 current_key => current_key % next             end do         end do      end function total_chaining_depth       module subroutine chaining_key_test(map, key, present) !! Version: Experimental !! !! Returns a logical flag indicating whether KEY is present in the hash map !! Arguments: !!     map     - the hash map of interest !!     key     - the key of interest !!     present - a logical flag indicating whether key is present in map !         class(chaining_hashmap_type), intent(inout) :: map         type(key_type), intent(in)                  :: key         logical, intent(out)                        :: present          integer(int_index) :: inmap          call in_chain_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             present = .false.         else             present = associated( map % inverse(inmap) % target )         end if      end subroutine chaining_key_test   end submodule stdlib_hashmap_chaining 
stdlib_hashmap_open.f90_stripped          submodule(stdlib_hashmaps) stdlib_hashmap_open      use, intrinsic :: iso_fortran_env, only: &         character_storage_size,              &         error_unit      use stdlib_hashmap_wrappers      implicit none       character(len=*), parameter ::                                             &         alloc_inv_fault     = "OPEN_HASHMAP_TYPE % INVERSE allocation fault.", &         alloc_key_fault     = "KEY allocation fault.",                         &         alloc_slots_fault   = "OPEN_HASHMAP_TYPE % SLOTS allocation fault.",   &         conflicting_key     = "KEY already exists in MAP.",                    &         expand_slots_fail   = "OPEN_HASHMAP_TYPE % SLOTS allocation > " //     &                               "MAX_BITS.",                                     &         init_slots_pow_fail = "SLOTS_BITS is not between                                "and MAX_BITS.",                                 &         invalid_inmap       = "INMAP was not a valid INVERSE index.",          &         map_consist_fault   = "The hash map found an inconsistency."      character(*), parameter :: submodule_name = 'STDLIB_HASHMAP_OPEN'       interface expand_slots            module procedure expand_open_slots     end interface expand_slots      interface extend_map_entry_pool            module procedure extend_open_map_entry_pool     end interface extend_map_entry_pool      interface free_map            module procedure free_open_map     end interface free_map      interface free_map_entry_pool             module procedure free_map_entry_pool     end interface free_map_entry_pool      interface get_other_data            module procedure get_other_open_data     end interface get_other_data      interface  init            module procedure init_open_map     end interface init      interface rehash             module procedure rehash_open_map     end interface rehash      interface remove            module procedure remove_open_entry     end interface remove      interface set_other_data            module procedure set_other_open_data     end interface set_other_data  contains       subroutine expand_open_slots( map )                type(open_hashmap_type), intent(inout) :: map          integer(int_hash)               :: base_slot         integer(int_index), allocatable :: dummy_slots(:)         integer(int_index)              :: inv_index,  &                                            new_size,   &                                            offset,     &                                            old_size,   &                                            test_slot         integer(int32)                  :: bits,      &                                            stat          character(256) :: errmsg         character(*), parameter :: procedure = 'EXPAND_SLOTS'          if ( map % nbits == max_bits ) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 expand_slots_fail         end if          old_size = size(map % slots, kind=int_index)          new_size = 2*old_size         bits = map % nbits + 1          allocate( dummy_slots(0:new_size-1), stat=stat, errmsg=errmsg )         if (stat /= 0) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 alloc_slots_fault         end if          map % nbits = bits          dummy_slots(:) = 0         map % index_mask = new_size-1          map % total_probes = map % total_probes + map % probe_count         map % probe_count = 0          REMAP_SLOTS: do inv_index=1_int_index, &             map % num_entries + map % num_free             associate( inverse => map % inverse(inv_index) )               if ( associated(inverse % target) ) then                   base_slot = fibonacci_hash( inverse % target % hash_val, &                                               map % nbits )                   offset = 0                   FIND_EMPTY_SLOT: do                       test_slot = iand( int( base_slot + offset, int_hash), &                                         map % index_mask )                       if ( dummy_slots(test_slot) == 0 ) then                           dummy_slots(test_slot) = inv_index                           exit FIND_EMPTY_SLOT                       end if                       offset = offset + 1                   end do FIND_EMPTY_SLOT               end if             end associate         end do REMAP_SLOTS          call move_alloc( dummy_slots, map % slots )      end subroutine expand_open_slots       subroutine extend_open_map_entry_pool(pool)               type(open_map_entry_pool), intent(inout), pointer :: pool          type(open_map_entry_pool), pointer :: map_entry_pool_head          allocate(map_entry_pool_head)         allocate(map_entry_pool_head % more_map_entries(0:pool_size-1))         map_entry_pool_head % lastpool => pool         pool => map_entry_pool_head         pool % next = 0      end subroutine extend_open_map_entry_pool       recursive subroutine free_map_entry_pool(pool)                 type(open_map_entry_pool), intent(inout), pointer :: pool          type(open_map_entry_pool), pointer :: lastpool          if ( associated(pool) ) then             lastpool => pool % lastpool             pool % lastpool => null()             deallocate( pool )              call free_map_entry_pool( lastpool )         end if      end subroutine free_map_entry_pool       module subroutine free_open_map( map )               type(open_hashmap_type), intent(inout) :: map          type(open_map_entry_list), pointer :: free_list         integer(int_index) :: i          if ( allocated( map % slots ) ) then             deallocate( map % slots )         end if          if ( allocated( map % inverse ) ) then              remove_links: do i=1, size( map % inverse, kind=int_index )                 map % inverse(i) % target => null()             end do remove_links             deallocate( map % inverse )         end if          free_free_list: do while( map % num_free > 0 )             free_list => map % free_list             map % free_list => map % free_list % next             free_list % next => null()             free_list % target => null()             map % num_free = map % num_free - 1         end do free_free_list         map % num_free = 0          if ( associated( map % cache ) ) call free_map_entry_pool(map % cache)          map % num_entries = 0      end subroutine free_open_map       module subroutine get_all_open_keys(map, all_keys)                class(open_hashmap_type), intent(in) :: map         type(key_type), allocatable, intent(out) :: all_keys(:)                  integer(int32) :: num_keys         integer(int_index) :: i, key_idx          num_keys = map % entries()         allocate( all_keys(num_keys) )         if ( num_keys == 0 ) return          if ( allocated( map % inverse) ) then             key_idx = 1_int_index             do i=1_int_index, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     all_keys(key_idx) = map % inverse(i) % target % key                     key_idx = key_idx + 1_int_index                 end if             end do          end if      end subroutine get_all_open_keys       module subroutine get_other_open_data( map, key, other, exists )                  class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(out)           :: other         logical, intent(out), optional          :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'GET_OTHER_DATA'          call in_open_map(map, inmap, key)         if ( inmap <= 0 .or. &             inmap > map % num_entries + map % num_free ) then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             if ( present(exists) ) exists = .true.             call copy_other( map % inverse(inmap) % target % other, other )         else             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             end if         end if      end subroutine get_other_open_data       subroutine in_open_map(map, inmap, key)                  class(open_hashmap_type), intent(inout) :: map         integer(int_index), intent(out)         :: inmap         type(key_type), intent(in)              :: key          character(*), parameter :: procedure = 'IN_MAP'         integer(int_hash) :: &             base_slot,       &             hash_val,        &             test_slot         integer(int_index) :: &             offset          hash_val = map % hasher( key )          if ( map % probe_count > inmap_probe_factor * map % call_count .or. &              map % num_entries >= load_factor *                             &              size( map % slots, kind=int_index ) ) then             if ( map % nbits < max_bits ) &                  call expand_slots(map)         end if          map % call_count = map % call_count + 1         base_slot = fibonacci_hash( hash_val, map % nbits )         offset = 0_int_index         PROBE_SLOTS: do             test_slot = iand( base_slot + offset, map % index_mask )             map % probe_count = map % probe_count + 1             inmap = map % slots( test_slot )             if ( inmap == 0 ) then                 return             else if ( inmap < 0 .or. &                  inmap > map % num_entries + map % num_free ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             else if ( .not. associated( map % inverse(inmap) % target ) ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             else                 associate( inverse => map % inverse(inmap) )                   if ( hash_val == inverse % target % hash_val ) then                       if ( key == inverse % target % key ) then                           return                       end if                   end if                 end associate             end if             offset = offset + 1_int_index         end do PROBE_SLOTS      end subroutine in_open_map       module subroutine init_open_map( map,         &                                      hasher,      &                                      slots_bits,  &                                      status )                        class(open_hashmap_type), intent(out)      :: map         procedure(hasher_fun)                      :: hasher         integer, intent(in), optional              :: slots_bits         integer(int32), intent(out), optional      :: status          character(256)          :: errmsg         integer(int_index)      :: i         character(*), parameter :: procedure = 'INIT'         integer(int_index)      :: slots         integer(int32)          :: stat         type(open_map_entry_pool), pointer :: map_entry_pool_head          map % call_count = 0         map % probe_count = 0         map % total_probes = 0          map % hasher => hasher          if ( present(slots_bits) ) then             if ( slots_bits < default_bits .OR. &                  slots_bits > max_bits ) then                 if ( present(status) ) then                     status = array_size_error                     return                 else                     error stop submodule_name // ' % ' // procedure // ': ' // &                         init_slots_pow_fail                 end if             end if             map % nbits = slots_bits         else             map % nbits = min( default_bits, max_bits )         end if          slots = 2_int32**map % nbits         map % index_mask = slots - 1          allocate( map % slots(0:slots-1), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present(status) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_slots_fault             end if         end if          do i=0, size( map % slots, kind=int_index ) -  1             map % slots(i) = 0          end do           allocate( map % inverse(1:ceiling(load_factor*slots, &                   kind=int_index)),                          &                   stat=stat,                                 &                   errmsg=errmsg )         if ( stat /= 0 ) then             if ( present( status ) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if         end if          do i=1, size(map % inverse, kind=int_index)             map % inverse(i) % target => null()         end do          do while(associated(map % cache))             map_entry_pool_head => map % cache             map % cache => map_entry_pool_head % lastpool             map_entry_pool_head % lastpool => null()             deallocate( map_entry_pool_head % more_map_entries )             deallocate( map_entry_pool_head )         end do          call extend_map_entry_pool(map % cache)          if (present(status) ) status = success      end subroutine init_open_map       pure module function open_loading( map )              class(open_hashmap_type), intent(in) :: map         real :: open_loading          open_loading = real( map % num_entries ) / &                        size( map % slots, kind=int_index )      end function open_loading       module subroutine map_open_entry(map, key, other, conflict)                   class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(in), optional  :: other         logical, intent(out), optional          :: conflict          type(open_map_entry_type), pointer :: new_ent         integer(int_hash)  :: base_slot         integer(int_hash)  :: hash_val         integer(int_index) :: inmap, offset, test_slot         character(*), parameter :: procedure = 'MAP_ENTRY'          hash_val = map % hasher( key )          if ( map % probe_count > map_probe_factor * map % call_count .or.   &              map % num_entries >= load_factor * size( map % slots,          &                                                       kind=int_index) ) then             call expand_slots(map)         end if         map % call_count = map % call_count  + 1         base_slot = fibonacci_hash( hash_val, map % nbits )          offset = 0         PROBE_SUCCESSIVE_SLOTS: do             map % probe_count = map % probe_count + 1             test_slot = iand( base_slot + offset, map % index_mask )             inmap = map % slots(test_slot)             if ( inmap == 0 ) then                 call allocate_open_map_entry(map, new_ent)                 new_ent % hash_val = hash_val                 call copy_key( key, new_ent % key )                 if ( present( other ) ) &                     call copy_other( other, new_ent % other )                 inmap = new_ent % inmap                 map % inverse( inmap ) % target => new_ent                 map % slots( test_slot ) = inmap                 if ( present(conflict) ) conflict = .false.                 return             else if ( inmap < 0 .or. &                 inmap > map % num_entries + map % num_free ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             else if (.not. associated( map % inverse(inmap) % target ) ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             else                 associate( target => map % inverse(inmap) % target )                   if ( hash_val == target % hash_val ) then                       if ( key == target % key ) then                                                      if ( present(conflict) ) then                               conflict = .true.                           else                               error stop submodule_name // ' % ' // procedure &                                   // ': ' // conflicting_key                           end if                           return                       end if                   end if                 end associate             end if             offset = offset + 1         end do PROBE_SUCCESSIVE_SLOTS      contains          subroutine allocate_open_map_entry(map, bucket)              type(open_hashmap_type), intent(inout) :: map             type(open_map_entry_type), pointer, intent(out) :: bucket             type(open_map_entry_list), pointer :: free_list             type(open_map_entry_pool), pointer :: pool             character(*), parameter :: procedure_name = "ALLOCATE_MAP_ENTRY"              pool => map % cache             map % num_entries = map % num_entries + 1             if ( associated(map % free_list) ) then                  free_list => map % free_list                 bucket => free_list % target                 map % free_list => free_list % next                 free_list % target => null()                 free_list % next => null()                 if (bucket % inmap <= 0) &                     error stop submodule_name // " % " // procedure_name // &                     ": Failed consistency check: BUCKET % INMAP <= 0"                 map % num_free = map % num_free - 1             else                  if ( pool % next == pool_size ) then                      call extend_map_entry_pool(map % cache)                     pool => map % cache                 end if                 bucket      => pool % more_map_entries(pool % next)                 pool % next =  pool % next + 1                  if ( map % num_entries >                     &                      size( map % inverse, kind=int_index ) ) then                     call expand_inverse( map )                 end if                 if ( map % num_entries <= 0 ) &                     error stop submodule_name // " % " // procedure_name // &                     ": Failed consistency check: MAP % NUM_ENTRIES <= 0."                 bucket % inmap = map % num_entries             end if          end subroutine allocate_open_map_entry          subroutine expand_inverse(map)              type(open_hashmap_type), intent(inout) :: map             type(open_map_entry_ptr), allocatable   :: dummy_inverse(:)              integer(int32) :: stat             character(256) :: errmsg              allocate( dummy_inverse(1:2*size(map % inverse, kind=int_index)), &                       stat=stat, errmsg=errmsg )             if ( stat /= 0 ) then                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if             dummy_inverse(1:size(map % inverse, kind=int_index)) = &                 map % inverse(:)              call move_alloc( dummy_inverse, map % inverse )          end subroutine expand_inverse      end subroutine map_open_entry       module subroutine rehash_open_map( map, hasher )                class(open_hashmap_type), intent(inout) :: map         procedure(hasher_fun)                   :: hasher          integer(int_hash)       :: base_slot         integer(int_hash)       :: hash_val         integer(int_index)      :: i, test_slot, offset          map % hasher => hasher          map % slots = 0          do i=1, map % num_entries + map % num_free             if ( .not. associated( map % inverse(i) % target ) ) cycle             hash_val = map % hasher( map % inverse(i) % target % key )             map % inverse(i) % target % hash_val = hash_val             base_slot = fibonaccI_hash( hash_val, map % nbits )             offset = 0             FIND_EMPTY_SLOT: do                 test_slot = iand( int( base_slot + offset, int_hash ), &                                   map % index_mask )                 if ( map % slots(test_slot) == 0 ) then                     map % slots(test_slot) = i                     exit FIND_EMPTY_SLOT                 end if                 offset = offset + 1             end do FIND_EMPTY_SLOT         end do      end subroutine rehash_open_map       module subroutine remove_open_entry(map, key, existed)                class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         logical, intent(out), optional          :: existed          type(open_map_entry_list), pointer :: aentry         type(open_map_entry_type), pointer :: bucket         integer(int_index)                 :: base_slot         integer(int_index)                 :: current_index         integer(int_index)                 :: current_slot         integer(int_index)                 :: empty_slot         integer(int_index)                 :: inmap         logical                            :: overlap         integer(int_index)                 :: slot_index          overlap = .false.         call in_open_map( map, inmap, key )         if ( inmap < 1 .or. inmap > size( map % inverse ) ) then             if ( present( existed ) ) existed = .false.             return         end if          bucket => map % inverse(inmap) % target         if ( associated(bucket) ) then             base_slot = fibonacci_hash( bucket % hash_val, map % nbits )             if ( present(existed) ) existed = .true.         else             if ( present( existed ) ) existed = .false.             return         end if           current_slot = base_slot         search_for_inmap: do             slot_index = map % slots(current_slot)             if ( slot_index == inmap ) then                 allocate(aentry)                 aentry % target => map % inverse(inmap) % target                 aentry % next => map % free_list                 map % free_list => aentry                 map % num_free = map % num_free + 1                 map % slots( current_slot ) = 0                 map % inverse(inmap) % target => null()                 map % num_entries = map % num_entries - 1                 empty_slot = current_slot                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( map % slots(current_slot) == 0 ) return                 if ( current_slot == 0 ) overlap = .true.                 exit search_for_inmap             else                 if ( map % slots(current_slot) == 0 ) return                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( current_slot == 0 ) overlap = .true.                 cycle search_for_inmap             end if         end do search_for_inmap            find_run_start: do             base_slot = iand( map % index_mask, base_slot - 1 )             if ( base_slot == map % index_mask ) then                 if ( map % slots(base_slot) == 0 ) then                     base_slot = 0                     exit find_run_start                 else                     overlap = .true.                     cycle find_run_start                 end if             else if ( map % slots(base_slot) == 0 ) then                 base_slot = iand( map % index_mask, base_slot + 1 )                 exit find_run_start             else                 cycle find_run_start             end if         end do find_run_start           fill_empty_slots: do             bucket => map % inverse(map % slots(current_slot) ) % target             current_index = fibonacci_hash( bucket % hash_val, &                                             map % nbits )             if ( overlap .and. empty_slot < base_slot ) then                 if ( ( current_index >= base_slot .and. &                        current_index <= map % index_mask ) .or. &                      ( current_index >= 0 .and. &                        current_index <= empty_slot ) ) then                     map % slots( empty_slot ) = map % slots( current_slot )                     map % slots( current_slot ) = 0                     empty_slot = current_slot                 end if                 current_slot = iand( map % index_mask, current_slot + 1 )             else                 if ( current_index >= base_slot .and. &                      current_index <= empty_slot ) then                     map % slots( empty_slot ) = map % slots( current_slot )                     map % slots( current_slot ) = 0                     empty_slot = current_slot                 end if                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( current_slot == 0 ) overlap = .true.             end if             if ( map % slots( current_slot ) == 0 ) exit fill_empty_slots         end do fill_empty_slots      end subroutine remove_open_entry       module subroutine set_other_open_data( map, key, other, exists )                   class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(in)            :: other         logical, intent(out),optional           :: exists          integer(int_index) :: inmap          character(*), parameter :: procedure = 'SET_OTHER_DATA'          call in_open_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             associate( target => map % inverse(inmap) % target )               call copy_other( other, target % other )               if ( present(exists) ) exists = .true.               return             end associate         else             error stop submodule_name // ' % ' // procedure // ': ' // &                 invalid_inmap         end if      end subroutine set_other_open_data       module function total_open_depth( map ) result(total_depth)               class(open_hashmap_type), intent(in) :: map         integer(int64) :: total_depth          integer(int_index) :: inv_index, slot, slots         integer(int_hash)  :: index          total_depth = 0_int64         slots = size( map % slots, kind=int_index )         do slot=0, slots-1             if ( map % slots( slot ) == 0 ) cycle             inv_index = map % slots( slot )             if ( inv_index <= 0 ) cycle             associate( inverse => map % inverse( inv_index ))               index = fibonacci_hash( inverse % target % hash_val, &                                       map % nbits )             end associate             total_depth = total_depth + &                 iand( slot - index, map % index_mask ) + 1_int64         end do      end function total_open_depth       module subroutine open_key_test(map, key, present)                class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         logical, intent(out)                    :: present          integer(int_index) :: inmap          call in_open_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             present = .false.         else             present = associated( map % inverse(inmap) % target )         end if      end subroutine open_key_test  end submodule stdlib_hashmap_open 
stdlib_hashmap_open.f90_comments !! The module, STDLIB_HASHMAP_OPEN implements a simple open addressing hash !! map using linear addressing. The implementation is loosely based on a !! C implementation by David Chase, http://chasewoerner.org/src/hasht/, for !! which he has given permission to use in the Fortran Standard Library.  ! Note an error in the code caused attempts to deallocate already deallocated ! entries. This did not cause stat to be non-zero, but did cause system errors, ! on my Mac. I therefore decided to remove all deallocation error reporting.  submodule(stdlib_hashmaps) stdlib_hashmap_open      use, intrinsic :: iso_fortran_env, only: &         character_storage_size,              &         error_unit      use stdlib_hashmap_wrappers      implicit none  ! Error messages     character(len=*), parameter ::                                             &         alloc_inv_fault     = "OPEN_HASHMAP_TYPE % INVERSE allocation fault.", &         alloc_key_fault     = "KEY allocation fault.",                         &         alloc_slots_fault   = "OPEN_HASHMAP_TYPE % SLOTS allocation fault.",   &         conflicting_key     = "KEY already exists in MAP.",                    &         expand_slots_fail   = "OPEN_HASHMAP_TYPE % SLOTS allocation > " //     &                               "MAX_BITS.",                                     &         init_slots_pow_fail = "SLOTS_BITS is not between DEFAULT_BITS " //     &                               "and MAX_BITS.",                                 &         invalid_inmap       = "INMAP was not a valid INVERSE index.",          &         map_consist_fault   = "The hash map found an inconsistency."      character(*), parameter :: submodule_name = 'STDLIB_HASHMAP_OPEN'       interface expand_slots !! Version: Experimental !! !! Interface to internal procedure that expands an open map's slots.         module procedure expand_open_slots     end interface expand_slots      interface extend_map_entry_pool !! Version: Experimental !! !! Interface to internal procedure that expands an open map entry pool.         module procedure extend_open_map_entry_pool     end interface extend_map_entry_pool      interface free_map !! Version: Experimental !! !! Interface to procedure that finalizes an open hash map.         module procedure free_open_map     end interface free_map      interface free_map_entry_pool !! Version: Experimental !! !! Interface to internal procedure that finalizes an open hash map !! entry pool.         module procedure free_map_entry_pool     end interface free_map_entry_pool      interface get_other_data !! Version: Experimental !! !! Interface to procedure that gets an entry's other data.         module procedure get_other_open_data     end interface get_other_data      interface  init !! Version: Experimental !! !! Interface to initialization procedure for an open hash map.         module procedure init_open_map     end interface init      interface rehash !! Version: Experimental !! !! Interface to a procedure that changes the hash function that !! is used to map the keys into an open hash map.         module procedure rehash_open_map     end interface rehash      interface remove !! Version: Experimental !! !! Interface to a procedure that removees an entry from an open hash map.         module procedure remove_open_entry     end interface remove      interface set_other_data !! Version: Experimental !! !! Interface to a procedure that changes the other data associated with a key         module procedure set_other_open_data     end interface set_other_data  contains       subroutine expand_open_slots( map ) !! Version: Experimental !! !! Internal routine to make a duplicate map with more hash slots. !! Doubles the size of the map % slots array !! Arguments: !!     map - the hash table whose hash slots are to be expanded !         type(open_hashmap_type), intent(inout) :: map          integer(int_hash)               :: base_slot         integer(int_index), allocatable :: dummy_slots(:)         integer(int_index)              :: inv_index,  &                                            new_size,   &                                            offset,     &                                            old_size,   &                                            test_slot         integer(int32)                  :: bits,      &                                            stat          character(256) :: errmsg         character(*), parameter :: procedure = 'EXPAND_SLOTS'          if ( map % nbits == max_bits ) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 expand_slots_fail         end if          old_size = size(map % slots, kind=int_index)          new_size = 2*old_size         bits = map % nbits + 1          allocate( dummy_slots(0:new_size-1), stat=stat, errmsg=errmsg )         if (stat /= 0) then             error stop submodule_name // ' % ' // procedure // ': ' // &                 alloc_slots_fault         end if          map % nbits = bits          dummy_slots(:) = 0         map % index_mask = new_size-1          map % total_probes = map % total_probes + map % probe_count         map % probe_count = 0          REMAP_SLOTS: do inv_index=1_int_index, &             map % num_entries + map % num_free             associate( inverse => map % inverse(inv_index) )               if ( associated(inverse % target) ) then                   base_slot = fibonacci_hash( inverse % target % hash_val, &                                               map % nbits )                   offset = 0                   FIND_EMPTY_SLOT: do                       test_slot = iand( int( base_slot + offset, int_hash), &                                         map % index_mask )                       if ( dummy_slots(test_slot) == 0 ) then                           dummy_slots(test_slot) = inv_index                           exit FIND_EMPTY_SLOT                       end if                       offset = offset + 1                   end do FIND_EMPTY_SLOT               end if             end associate         end do REMAP_SLOTS          call move_alloc( dummy_slots, map % slots )      end subroutine expand_open_slots       subroutine extend_open_map_entry_pool(pool) ! gent_pool_new !! Version: Experimental !! !! Add more map_entrys to the pool head !! Arguments: !!     pool - an open map entry pool         type(open_map_entry_pool), intent(inout), pointer :: pool          type(open_map_entry_pool), pointer :: map_entry_pool_head          allocate(map_entry_pool_head)         allocate(map_entry_pool_head % more_map_entries(0:pool_size-1))         map_entry_pool_head % lastpool => pool         pool => map_entry_pool_head         pool % next = 0      end subroutine extend_open_map_entry_pool       recursive subroutine free_map_entry_pool(pool) ! gent_pool_free !! Version: Experimental !! Note the freeing of allocated memory may be unnecessary !! !! Recursively descends map entry pool list freeing each element !! Arguments: !!     pool  The map entry pool whose elements are to be freed !         type(open_map_entry_pool), intent(inout), pointer :: pool          type(open_map_entry_pool), pointer :: lastpool          if ( associated(pool) ) then             lastpool => pool % lastpool             pool % lastpool => null()             deallocate( pool ) !         Trace component pointers/lists             call free_map_entry_pool( lastpool )         end if      end subroutine free_map_entry_pool       module subroutine free_open_map( map ) !! Version: Experimental !! !! Frees internal memory of an open map !! Arguments: !!     map - the open hash map whose memory is to be freed !         type(open_hashmap_type), intent(inout) :: map          type(open_map_entry_list), pointer :: free_list         integer(int_index) :: i          if ( allocated( map % slots ) ) then             deallocate( map % slots )         end if          if ( allocated( map % inverse ) ) then              remove_links: do i=1, size( map % inverse, kind=int_index )                 map % inverse(i) % target => null()             end do remove_links             deallocate( map % inverse )         end if          free_free_list: do while( map % num_free > 0 )             free_list => map % free_list             map % free_list => map % free_list % next             free_list % next => null()             free_list % target => null()             map % num_free = map % num_free - 1         end do free_free_list         map % num_free = 0          if ( associated( map % cache ) ) call free_map_entry_pool(map % cache)          map % num_entries = 0      end subroutine free_open_map       module subroutine get_all_open_keys(map, all_keys) !! Version: Experimental !! !! Returns all the keys contained in a hash map !! Arguments: !!     map - an open hash map !!     all_keys - all the keys contained in a hash map !         class(open_hashmap_type), intent(in) :: map         type(key_type), allocatable, intent(out) :: all_keys(:)                  integer(int32) :: num_keys         integer(int_index) :: i, key_idx          num_keys = map % entries()         allocate( all_keys(num_keys) )         if ( num_keys == 0 ) return          if ( allocated( map % inverse) ) then             key_idx = 1_int_index             do i=1_int_index, size( map % inverse, kind=int_index )                 if ( associated( map % inverse(i) % target ) ) then                     all_keys(key_idx) = map % inverse(i) % target % key                     key_idx = key_idx + 1_int_index                 end if             end do          end if      end subroutine get_all_open_keys       module subroutine get_other_open_data( map, key, other, exists ) !! Version: Experimental !! !! Returns the other data associated with the inverse table index !! Arguments: !!     map   - an open hash table !!     key   - the key associated with a map entry !!     other - the other data associated with the key !!     exists - a logical flag indicating whether an entry with that key exists !         class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(out)           :: other         logical, intent(out), optional          :: exists          integer(int_index) :: inmap         character(*), parameter :: procedure = 'GET_OTHER_DATA'          call in_open_map(map, inmap, key)         if ( inmap <= 0 .or. &             inmap > map % num_entries + map % num_free ) then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             if ( present(exists) ) exists = .true.             call copy_other( map % inverse(inmap) % target % other, other )         else             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             end if         end if      end subroutine get_other_open_data       subroutine in_open_map(map, inmap, key) ! Chase's inmap !! Version: Experimental !! !! Returns the index into the INVERSE array associated with the KEY !! Arguments: !!     map   - the hash map of interest !!     inmap - the returned index into the INVERSE array of entry pointers !!     key   - the key identifying the entry of interest !         class(open_hashmap_type), intent(inout) :: map         integer(int_index), intent(out)         :: inmap         type(key_type), intent(in)              :: key          character(*), parameter :: procedure = 'IN_MAP'         integer(int_hash) :: &             base_slot,       &             hash_val,        &             test_slot         integer(int_index) :: &             offset          hash_val = map % hasher( key )          if ( map % probe_count > inmap_probe_factor * map % call_count .or. &              map % num_entries >= load_factor *                             &              size( map % slots, kind=int_index ) ) then             if ( map % nbits < max_bits ) &                  call expand_slots(map)         end if          map % call_count = map % call_count + 1         base_slot = fibonacci_hash( hash_val, map % nbits )         offset = 0_int_index         PROBE_SLOTS: do             test_slot = iand( base_slot + offset, map % index_mask )             map % probe_count = map % probe_count + 1             inmap = map % slots( test_slot )             if ( inmap == 0 ) then                 return             else if ( inmap < 0 .or. &                  inmap > map % num_entries + map % num_free ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             else if ( .not. associated( map % inverse(inmap) % target ) ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     map_consist_fault             else                 associate( inverse => map % inverse(inmap) )                   if ( hash_val == inverse % target % hash_val ) then                       if ( key == inverse % target % key ) then                           return                       end if                   end if                 end associate             end if             offset = offset + 1_int_index         end do PROBE_SLOTS      end subroutine in_open_map       module subroutine init_open_map( map,         &                                      hasher,      &                                      slots_bits,  &                                      status ) !! Version: Experimental !! !! Routine to allocate an empty map with HASHER as the hash function, !! 2**SLOTS_BITS initial SIZE(map % slots), and SIZE(map % slots) limited to a !! maximum of 2**MAX_BITS. All fields are initialized. !! Arguments: !!     map         - the open hash maap to be initialized !!     hasher      - the hash function to be used to map keys to slots !!     slots_bits  - the number of bits used to map to the slots !!     status      - an integer error status flag with the allowed values: !!         success - no problems were found !!         alloc_fault - map % slots or map % inverse could not be allocated !!         array_size_error - slots_bits is less than default_bitd or !!             greater than max_bits          class(open_hashmap_type), intent(out)      :: map         procedure(hasher_fun)                      :: hasher         integer, intent(in), optional              :: slots_bits         integer(int32), intent(out), optional      :: status          character(256)          :: errmsg         integer(int_index)      :: i         character(*), parameter :: procedure = 'INIT'         integer(int_index)      :: slots         integer(int32)          :: stat         type(open_map_entry_pool), pointer :: map_entry_pool_head          map % call_count = 0         map % probe_count = 0         map % total_probes = 0          map % hasher => hasher          if ( present(slots_bits) ) then             if ( slots_bits < default_bits .OR. &                  slots_bits > max_bits ) then                 if ( present(status) ) then                     status = array_size_error                     return                 else                     error stop submodule_name // ' % ' // procedure // ': ' // &                         init_slots_pow_fail                 end if             end if             map % nbits = slots_bits         else             map % nbits = min( default_bits, max_bits )         end if          slots = 2_int32**map % nbits         map % index_mask = slots - 1          allocate( map % slots(0:slots-1), stat=stat, errmsg=errmsg )         if ( stat /= 0 ) then             if ( present(status) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_slots_fault             end if         end if          do i=0, size( map % slots, kind=int_index ) -  1             map % slots(i) = 0 ! May be redundant         end do  !! 5*s from Chase's g_new_map         allocate( map % inverse(1:ceiling(load_factor*slots, &                   kind=int_index)),                          &                   stat=stat,                                 &                   errmsg=errmsg )         if ( stat /= 0 ) then             if ( present( status ) ) then                 status = alloc_fault                 return             else                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if         end if          do i=1, size(map % inverse, kind=int_index)             map % inverse(i) % target => null()         end do          do while(associated(map % cache))             map_entry_pool_head => map % cache             map % cache => map_entry_pool_head % lastpool             map_entry_pool_head % lastpool => null()             deallocate( map_entry_pool_head % more_map_entries )             deallocate( map_entry_pool_head )         end do          call extend_map_entry_pool(map % cache)          if (present(status) ) status = success      end subroutine init_open_map       pure module function open_loading( map ) !! Version: Experimental !! !! Returns the number of entries relative to slots in a hash map !! Arguments: !!       map - an open hash map         class(open_hashmap_type), intent(in) :: map         real :: open_loading          open_loading = real( map % num_entries ) / &                        size( map % slots, kind=int_index )      end function open_loading       module subroutine map_open_entry(map, key, other, conflict) !! Version: Experimental !! !! Inserts an entry into the hash table !!  Arguments: !!      map     the hash table of interest !!      key      - the key identifying the entry !!      other    - other data associated with the key !!      conflict - logical flag indicating whether the entry key conflicts !!                 with an existing key !         class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(in), optional  :: other         logical, intent(out), optional          :: conflict          type(open_map_entry_type), pointer :: new_ent         integer(int_hash)  :: base_slot         integer(int_hash)  :: hash_val         integer(int_index) :: inmap, offset, test_slot         character(*), parameter :: procedure = 'MAP_ENTRY'          hash_val = map % hasher( key )          if ( map % probe_count > map_probe_factor * map % call_count .or.   &              map % num_entries >= load_factor * size( map % slots,          &                                                       kind=int_index) ) then             call expand_slots(map)         end if         map % call_count = map % call_count  + 1         base_slot = fibonacci_hash( hash_val, map % nbits )          offset = 0         PROBE_SUCCESSIVE_SLOTS: do             map % probe_count = map % probe_count + 1             test_slot = iand( base_slot + offset, map % index_mask )             inmap = map % slots(test_slot)             if ( inmap == 0 ) then                 call allocate_open_map_entry(map, new_ent)                 new_ent % hash_val = hash_val                 call copy_key( key, new_ent % key )                 if ( present( other ) ) &                     call copy_other( other, new_ent % other )                 inmap = new_ent % inmap                 map % inverse( inmap ) % target => new_ent                 map % slots( test_slot ) = inmap                 if ( present(conflict) ) conflict = .false.                 return             else if ( inmap < 0 .or. &                 inmap > map % num_entries + map % num_free ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             else if (.not. associated( map % inverse(inmap) % target ) ) then                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             else                 associate( target => map % inverse(inmap) % target )                   if ( hash_val == target % hash_val ) then                       if ( key == target % key ) then                           ! entry already exists                           if ( present(conflict) ) then                               conflict = .true.                           else                               error stop submodule_name // ' % ' // procedure &                                   // ': ' // conflicting_key                           end if                           return                       end if                   end if                 end associate             end if             offset = offset + 1         end do PROBE_SUCCESSIVE_SLOTS      contains          subroutine allocate_open_map_entry(map, bucket) !         allocates a hash bucket             type(open_hashmap_type), intent(inout) :: map             type(open_map_entry_type), pointer, intent(out) :: bucket             type(open_map_entry_list), pointer :: free_list             type(open_map_entry_pool), pointer :: pool             character(*), parameter :: procedure_name = "ALLOCATE_MAP_ENTRY"              pool => map % cache             map % num_entries = map % num_entries + 1             if ( associated(map % free_list) ) then !             Get hash bucket from free_list                 free_list => map % free_list                 bucket => free_list % target                 map % free_list => free_list % next                 free_list % target => null()                 free_list % next => null()                 if (bucket % inmap <= 0) &                     error stop submodule_name // " % " // procedure_name // &                     ": Failed consistency check: BUCKET % INMAP <= 0"                 map % num_free = map % num_free - 1             else !             Get hash bucket from pool                 if ( pool % next == pool_size ) then !         Expand pool                     call extend_map_entry_pool(map % cache)                     pool => map % cache                 end if                 bucket      => pool % more_map_entries(pool % next)                 pool % next =  pool % next + 1 ! 0s based -> post-increment                 if ( map % num_entries >                     &                      size( map % inverse, kind=int_index ) ) then                     call expand_inverse( map )                 end if                 if ( map % num_entries <= 0 ) &                     error stop submodule_name // " % " // procedure_name // &                     ": Failed consistency check: MAP % NUM_ENTRIES <= 0."                 bucket % inmap = map % num_entries             end if          end subroutine allocate_open_map_entry          subroutine expand_inverse(map) !!     Increase size of map % inverse             type(open_hashmap_type), intent(inout) :: map             type(open_map_entry_ptr), allocatable   :: dummy_inverse(:)              integer(int32) :: stat             character(256) :: errmsg              allocate( dummy_inverse(1:2*size(map % inverse, kind=int_index)), &                       stat=stat, errmsg=errmsg )             if ( stat /= 0 ) then                 write(error_unit, '(a)') 'Allocation ERRMSG: ' // trim(errmsg)                 error stop submodule_name // ' % ' // procedure // ': ' // &                     alloc_inv_fault             end if             dummy_inverse(1:size(map % inverse, kind=int_index)) = &                 map % inverse(:)              call move_alloc( dummy_inverse, map % inverse )          end subroutine expand_inverse      end subroutine map_open_entry       module subroutine rehash_open_map( map, hasher ) !! Version: Experimental !! !! Changes the hashing method of the table entries to that of HASHER. !! Arguments: !!     map      the table to be rehashed !!     hasher the hasher function to be used for the table !         class(open_hashmap_type), intent(inout) :: map         procedure(hasher_fun)                   :: hasher          integer(int_hash)       :: base_slot         integer(int_hash)       :: hash_val         integer(int_index)      :: i, test_slot, offset          map % hasher => hasher          map % slots = 0          do i=1, map % num_entries + map % num_free             if ( .not. associated( map % inverse(i) % target ) ) cycle             hash_val = map % hasher( map % inverse(i) % target % key )             map % inverse(i) % target % hash_val = hash_val             base_slot = fibonaccI_hash( hash_val, map % nbits )             offset = 0             FIND_EMPTY_SLOT: do                 test_slot = iand( int( base_slot + offset, int_hash ), &                                   map % index_mask )                 if ( map % slots(test_slot) == 0 ) then                     map % slots(test_slot) = i                     exit FIND_EMPTY_SLOT                 end if                 offset = offset + 1             end do FIND_EMPTY_SLOT         end do      end subroutine rehash_open_map       module subroutine remove_open_entry(map, key, existed) !! Remove the entry, if any, that has the key !! Arguments: !!    map     - the table from which the entry is to be removed !!    key     - the key to an entry !!    existed - a logical flag indicating whether an entry with the key !!              was present in the original map !         class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         logical, intent(out), optional          :: existed          type(open_map_entry_list), pointer :: aentry         type(open_map_entry_type), pointer :: bucket         integer(int_index)                 :: base_slot         integer(int_index)                 :: current_index         integer(int_index)                 :: current_slot         integer(int_index)                 :: empty_slot         integer(int_index)                 :: inmap         logical                            :: overlap         integer(int_index)                 :: slot_index          overlap = .false.         call in_open_map( map, inmap, key )         if ( inmap < 1 .or. inmap > size( map % inverse ) ) then             if ( present( existed ) ) existed = .false.             return         end if          bucket => map % inverse(inmap) % target         if ( associated(bucket) ) then             base_slot = fibonacci_hash( bucket % hash_val, map % nbits )             if ( present(existed) ) existed = .true.         else             if ( present( existed ) ) existed = .false.             return         end if  ! Find slot associated with inmap and nullify the pointer         current_slot = base_slot         search_for_inmap: do             slot_index = map % slots(current_slot)             if ( slot_index == inmap ) then                 allocate(aentry)                 aentry % target => map % inverse(inmap) % target                 aentry % next => map % free_list                 map % free_list => aentry                 map % num_free = map % num_free + 1                 map % slots( current_slot ) = 0                 map % inverse(inmap) % target => null()                 map % num_entries = map % num_entries - 1                 empty_slot = current_slot                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( map % slots(current_slot) == 0 ) return                 if ( current_slot == 0 ) overlap = .true.                 exit search_for_inmap             else                 if ( map % slots(current_slot) == 0 ) return                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( current_slot == 0 ) overlap = .true.                 cycle search_for_inmap             end if         end do search_for_inmap  ! Have found slot and stored it in free_list, now may need to iteratively ! swap to fill holes. First search backwards to find start of run.         find_run_start: do             base_slot = iand( map % index_mask, base_slot - 1 )             if ( base_slot == map % index_mask ) then                 if ( map % slots(base_slot) == 0 ) then                     base_slot = 0                     exit find_run_start                 else                     overlap = .true.                     cycle find_run_start                 end if             else if ( map % slots(base_slot) == 0 ) then                 base_slot = iand( map % index_mask, base_slot + 1 )                 exit find_run_start             else                 cycle find_run_start             end if         end do find_run_start  ! Search forward for entry to fill empty slot         fill_empty_slots: do             bucket => map % inverse(map % slots(current_slot) ) % target             current_index = fibonacci_hash( bucket % hash_val, &                                             map % nbits )             if ( overlap .and. empty_slot < base_slot ) then                 if ( ( current_index >= base_slot .and. &                        current_index <= map % index_mask ) .or. &                      ( current_index >= 0 .and. &                        current_index <= empty_slot ) ) then                     map % slots( empty_slot ) = map % slots( current_slot )                     map % slots( current_slot ) = 0                     empty_slot = current_slot                 end if                 current_slot = iand( map % index_mask, current_slot + 1 )             else                 if ( current_index >= base_slot .and. &                      current_index <= empty_slot ) then                     map % slots( empty_slot ) = map % slots( current_slot )                     map % slots( current_slot ) = 0                     empty_slot = current_slot                 end if                 current_slot = iand( map % index_mask, current_slot + 1 )                 if ( current_slot == 0 ) overlap = .true.             end if             if ( map % slots( current_slot ) == 0 ) exit fill_empty_slots         end do fill_empty_slots      end subroutine remove_open_entry       module subroutine set_other_open_data( map, key, other, exists ) !! Version: Experimental !! !! Change the other data associated with the key !! Arguments: !!     map    - the map with the entry of interest !!     key    - the key to the entry inthe map !!     other  - the new data to be associated with the key !!     exists - a logical flag indicating whether the key is already entered !!              in the map !         class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         type(other_type), intent(in)            :: other         logical, intent(out),optional           :: exists          integer(int_index) :: inmap          character(*), parameter :: procedure = 'SET_OTHER_DATA'          call in_open_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             if ( present(exists) ) then                 exists = .false.                 return             else                 error stop submodule_name // ' % ' // procedure // ': ' // &                     invalid_inmap             end if         else if ( associated( map % inverse(inmap) % target ) ) then             associate( target => map % inverse(inmap) % target )               call copy_other( other, target % other )               if ( present(exists) ) exists = .true.               return             end associate         else             error stop submodule_name // ' % ' // procedure // ': ' // &                 invalid_inmap         end if      end subroutine set_other_open_data       module function total_open_depth( map ) result(total_depth) !! Version: Experimental !! !! Returns the total number of ones based offsets of slot entries from !! their slot index for a hash map !! Arguments: !!     map - an open hash map         class(open_hashmap_type), intent(in) :: map         integer(int64) :: total_depth          integer(int_index) :: inv_index, slot, slots         integer(int_hash)  :: index          total_depth = 0_int64         slots = size( map % slots, kind=int_index )         do slot=0, slots-1             if ( map % slots( slot ) == 0 ) cycle             inv_index = map % slots( slot )             if ( inv_index <= 0 ) cycle             associate( inverse => map % inverse( inv_index ))               index = fibonacci_hash( inverse % target % hash_val, &                                       map % nbits )             end associate             total_depth = total_depth + &                 iand( slot - index, map % index_mask ) + 1_int64         end do      end function total_open_depth       module subroutine open_key_test(map, key, present) !! Version: Experimental !! !! Returns a logical flag indicating whether KEY exists in the hash map !! Arguments: !!     map - the hash map of interest !!     key - the key of interest !         class(open_hashmap_type), intent(inout) :: map         type(key_type), intent(in)              :: key         logical, intent(out)                    :: present          integer(int_index) :: inmap          call in_open_map( map, inmap, key )         if ( inmap <= 0 .or. inmap > size( map % inverse, kind=int_index ) ) &             then             present = .false.         else             present = associated( map % inverse(inmap) % target )         end if      end subroutine open_key_test  end submodule stdlib_hashmap_open 
stdlib_hashmap_wrappers.f90_stripped      module stdlib_hashmap_wrappers      use, intrinsic :: iso_fortran_env, only : &         character_storage_size      use stdlib_hash_32bit      use stdlib_kinds, only : &         int8,                &         int16,               &         int32,               &         int64,               &         dp      implicit none      private       public ::                    &         copy_key,                &         copy_other,              &         fibonacci_hash,          &         fnv_1_hasher,            &         fnv_1a_hasher,           &         free_key,                &         free_other,              &         get,                     &         hasher_fun,              &         operator(==),            &         seeded_nmhash32_hasher,  &         seeded_nmhash32x_hasher, &         seeded_water_hasher,     &         set       public ::      &         key_type,  &         other_type       public ::   &         int_hash      integer, parameter ::               &          bits_int8  = bit_size(0_int8)      integer, parameter ::                   &         bits_char = character_storage_size, &         bytes_char = bits_char/bits_int8      character(*), parameter :: module_name = "STDLIB_HASHMAP_WRAPPERS"      type :: key_type             integer(int8), allocatable :: value(:)     end type key_type      abstract interface            pure function hasher_fun( key )  result(hash_value)             import key_type, int_hash             type(key_type), intent(in)    :: key             integer(int_hash)             :: hash_value         end function hasher_fun     end interface      type :: other_type             class(*), allocatable :: value     end type other_type      interface get          module procedure get_char_key,   &                          get_int8_key,   &                          get_other      end interface get       interface operator(==)         module procedure equal_keys     end interface operator(==)      interface set          module procedure set_char_key,   &                          set_int8_key,   &                          set_other      end interface set  contains       pure subroutine copy_key( old_key, new_key )                 type(key_type), intent(in)  :: old_key         type(key_type), intent(out) :: new_key          new_key % value = old_key % value      end subroutine copy_key       subroutine copy_other( other_in, other_out )                 type(other_type), intent(in)  :: other_in         type(other_type), intent(out) :: other_out          allocate(other_out % value, source = other_in % value )      end subroutine copy_other       function equal_keys( key1, key2 ) result(test)                  logical                    :: test         type(key_type), intent(in) :: key1         type(key_type), intent(in) :: key2          if ( size(key1 % value, kind=int64) /= &              size(key2 % value, kind=int64) ) then             test = .false.             return         end if          if ( all( key1 % value == key2 % value ) ) then             test = .true.         else             test = .false.         end if      end function equal_keys       subroutine free_key( key )                type(key_type), intent(inout) :: key          if ( allocated( key % value ) ) deallocate( key % value )      end subroutine free_key       subroutine free_other( other )                type(other_type), intent(inout) :: other          if ( allocated( other % value) ) deallocate( other % value )      end subroutine free_other       subroutine get_char_key( key, value )               type(key_type), intent(in)             :: key         character(:), allocatable, intent(out) :: value         character(*), parameter :: procedure = "GET"          integer(int64) :: key_as_char         integer(int64) :: key_size          key_size = size( key % value, kind=int64 )         select case( bytes_char )         case(1)             key_as_char = key_size         case(2)             if ( iand( key_size, 1_int64 ) > 0 ) then                 error stop module_name // " % " // procedure // &                           ": Internal Error at stdlib_hashmaps: " // &                            "System uses 2 bytes per character, so " // &                            "key_size can't be an odd number."             end if             key_as_char = ishft( key_size, -1 )         case(4)             if ( iand( key_size, 3_int64) > 0 ) then                 error stop module_name // " % " // procedure // &                           ": Internal Error at stdlib_hashmaps: " // &                            "System uses 4 bytes per character, and " // &                            "key_size is not a multiple of four."             end if             key_as_char = ishft( key_size, -2 )         case default             error stop module_name // " % " // procedure // &                        ": Internal Error: " // &                        "System doesn't use a power of two for its " // &                        "character size as expected by stdlib_hashmaps."         end select          allocate( character( len=key_as_char ) :: value )          value(1:key_as_char) = transfer( key % value, value )      end subroutine get_char_key      subroutine get_other( other, value )               type(other_type), intent(in)       :: other         class(*), allocatable, intent(out) :: value          allocate(value, source=other % value)      end subroutine get_other       subroutine get_int8_key( key, value )               type(key_type), intent(in)              :: key         integer(int8), allocatable, intent(out) :: value(:)          value = key % value      end subroutine get_int8_key       subroutine set_char_key( key, value )               type(key_type), intent(out) :: key         character(*), intent(in)    :: value          key % value = transfer( value, key % value, &                                 bytes_char * len( value ) )      end subroutine set_char_key       subroutine set_other( other, value )               type(other_type), intent(out) :: other         class(*), intent(in)          :: value          allocate(other % value, source=value)      end subroutine set_other       subroutine set_int8_key( key, value )               type(key_type), intent(out) :: key         integer(int8), intent(in)   :: value(:)          key % value = value      end subroutine set_int8_key       pure function fnv_1_hasher( key )              type(key_type), intent(in)    :: key         integer(int_hash)             :: fnv_1_hasher          fnv_1_hasher = fnv_1_hash( key % value )      end function fnv_1_hasher       pure function fnv_1a_hasher( key )                type(key_type), intent(in)    :: key         integer(int_hash)             :: fnv_1a_hasher          fnv_1a_hasher = fnv_1a_hash( key % value )      end function fnv_1a_hasher       pure function seeded_nmhash32_hasher( key )                 type(key_type), intent(in)    :: key         integer(int_hash)             :: seeded_nmhash32_hasher          seeded_nmhash32_hasher = nmhash32( key % value, &             int( z'      end function seeded_nmhash32_hasher       pure function seeded_nmhash32x_hasher( key )                type(key_type), intent(in)    :: key         integer(int_hash)             :: seeded_nmhash32x_hasher          seeded_nmhash32x_hasher = nmhash32x( key % value, &             int( z'      end function seeded_nmhash32x_hasher       pure function seeded_water_hasher( key )                type(key_type), intent(in)  :: key         integer(int_hash)           :: seeded_water_hasher          seeded_water_hasher = water_hash( key % value, &             int( z'      end function seeded_water_hasher   end module stdlib_hashmap_wrappers 
stdlib_hashmap_wrappers.f90_comments !! The module STDLIB_HASHMAP_WRAPPERS provides wrappers for various !! entities used by the hash map procedures. These include wrappers for the !! `key` and `other` data, and hashing procedures to operate on entities of !! the `key_type`.  module stdlib_hashmap_wrappers      use, intrinsic :: iso_fortran_env, only : &         character_storage_size      use stdlib_hash_32bit      use stdlib_kinds, only : &         int8,                &         int16,               &         int32,               &         int64,               &         dp      implicit none      private  !! Public procedures     public ::                    &         copy_key,                &         copy_other,              &         fibonacci_hash,          &         fnv_1_hasher,            &         fnv_1a_hasher,           &         free_key,                &         free_other,              &         get,                     &         hasher_fun,              &         operator(==),            &         seeded_nmhash32_hasher,  &         seeded_nmhash32x_hasher, &         seeded_water_hasher,     &         set  !! Public types     public ::      &         key_type,  &         other_type  !! Public integers     public ::   &         int_hash      integer, parameter ::               & ! Should be 8         bits_int8  = bit_size(0_int8)      integer, parameter ::                   &         bits_char = character_storage_size, &         bytes_char = bits_char/bits_int8      character(*), parameter :: module_name = "STDLIB_HASHMAP_WRAPPERS"      type :: key_type !! Version: Experimental !! !! A wrapper type for the key's true type !        private         integer(int8), allocatable :: value(:)     end type key_type      abstract interface !! Version: Experimental !! !! Abstract interface to a 64 bit hash function operating on a KEY_TYPE         pure function hasher_fun( key )  result(hash_value)             import key_type, int_hash             type(key_type), intent(in)    :: key             integer(int_hash)             :: hash_value         end function hasher_fun     end interface      type :: other_type !! Version: Experimental !! !! A wrapper type for the other data's true type !        private         class(*), allocatable :: value     end type other_type      interface get          module procedure get_char_key,   &                          get_int8_key,   &                          get_other      end interface get       interface operator(==)         module procedure equal_keys     end interface operator(==)      interface set          module procedure set_char_key,   &                          set_int8_key,   &                          set_other      end interface set  contains       pure subroutine copy_key( old_key, new_key ) !! Version: Experimental !! !! Copies the contents of the key, old_key, to the key, new_key !! ([Specifications](../page/specs/stdlib_hashmaps.html#copy_key-returns-a-copy-of-the-key)) !! !! Arguments: !!     old_key - the input key !!     new_key - the output copy of old_key         type(key_type), intent(in)  :: old_key         type(key_type), intent(out) :: new_key          new_key % value = old_key % value      end subroutine copy_key       subroutine copy_other( other_in, other_out ) !! Version: Experimental !! !! Copies the other data, other_in, to the variable, other_out !! ([Specifications](../page/specs/stdlib_hashmaps.html#copy_other-returns-a-copy-of-the-other-data)) !! !! Arguments: !!     other_in  - the input data !!     other_out - the output data         type(other_type), intent(in)  :: other_in         type(other_type), intent(out) :: other_out          allocate(other_out % value, source = other_in % value )      end subroutine copy_other       function equal_keys( key1, key2 ) result(test) ! Chase's tester !! Version: Experimental !! !! Compares two keys for equality !! ([Specifications](../page/specs/stdlib_hashmaps.html#operator(==)-compares-two-keys-for-equality)) !! !! Arguments: !!     key1 - the first key !!     key2 - the second key         logical                    :: test         type(key_type), intent(in) :: key1         type(key_type), intent(in) :: key2          if ( size(key1 % value, kind=int64) /= &              size(key2 % value, kind=int64) ) then             test = .false.             return         end if          if ( all( key1 % value == key2 % value ) ) then             test = .true.         else             test = .false.         end if      end function equal_keys       subroutine free_key( key ) !! Version: Experimental !! !! Frees the memory in a key !! ([Specifications](../page/specs/stdlib_hashmaps.html#free_key-frees-the-memory-associated-with-a-key)) !! !! Arguments: !!     key  - the key         type(key_type), intent(inout) :: key          if ( allocated( key % value ) ) deallocate( key % value )      end subroutine free_key       subroutine free_other( other ) !! Version: Experimental !! !! Frees the memory in the other data !! ([Specifications](../page/specs/stdlib_hashmaps.html#free_other-frees-the-memory-associated-with-other-data)) !! !! Arguments: !!     other  - the other data         type(other_type), intent(inout) :: other          if ( allocated( other % value) ) deallocate( other % value )      end subroutine free_other       subroutine get_char_key( key, value ) !! Version: Experimental !! !! Gets the contents of the key as a CHARACTER string !! Arguments: !!     key   - the input key !!     value - the contents of key mapped to a CHARACTER string         type(key_type), intent(in)             :: key         character(:), allocatable, intent(out) :: value         character(*), parameter :: procedure = "GET"          integer(int64) :: key_as_char         integer(int64) :: key_size          key_size = size( key % value, kind=int64 )         select case( bytes_char )         case(1)             key_as_char = key_size         case(2)             if ( iand( key_size, 1_int64 ) > 0 ) then                 error stop module_name // " % " // procedure // &                           ": Internal Error at stdlib_hashmaps: " // &                            "System uses 2 bytes per character, so " // &                            "key_size can't be an odd number."             end if             key_as_char = ishft( key_size, -1 )         case(4)             if ( iand( key_size, 3_int64) > 0 ) then                 error stop module_name // " % " // procedure // &                           ": Internal Error at stdlib_hashmaps: " // &                            "System uses 4 bytes per character, and " // &                            "key_size is not a multiple of four."             end if             key_as_char = ishft( key_size, -2 )         case default             error stop module_name // " % " // procedure // &                        ": Internal Error: " // &                        "System doesn't use a power of two for its " // &                        "character size as expected by stdlib_hashmaps."         end select          allocate( character( len=key_as_char ) :: value )          value(1:key_as_char) = transfer( key % value, value )      end subroutine get_char_key      subroutine get_other( other, value ) !! Version: Experimental !! !! Gets the contents of the other as a CLASS(*) string !! Arguments: !!     other - the input other data !!     value - the contents of other mapped to a CLASS(*) variable         type(other_type), intent(in)       :: other         class(*), allocatable, intent(out) :: value          allocate(value, source=other % value)      end subroutine get_other       subroutine get_int8_key( key, value ) !! Version: Experimental !! !! Gets the contents of the key as an INTEGER(INT8) vector !! Arguments: !!     key   - the input key !!     value - the contents of key mapped to an INTEGER(INT8) vector         type(key_type), intent(in)              :: key         integer(int8), allocatable, intent(out) :: value(:)          value = key % value      end subroutine get_int8_key       subroutine set_char_key( key, value ) !! Version: Experimental !! !! Sets the contents of the key from a CHARACTER string !! Arguments: !!     key   - the output key !!     value - the input CHARACTER string         type(key_type), intent(out) :: key         character(*), intent(in)    :: value          key % value = transfer( value, key % value, &                                 bytes_char * len( value ) )      end subroutine set_char_key       subroutine set_other( other, value ) !! Version: Experimental !! !! Sets the contents of the other data from a CLASS(*) variable !! Arguments: !!     other - the output other data !!     value - the input CLASS(*) variable         type(other_type), intent(out) :: other         class(*), intent(in)          :: value          allocate(other % value, source=value)      end subroutine set_other       subroutine set_int8_key( key, value ) !! Version: Experimental !! !! Sets the contents of the key from an INTEGER(INT8) vector !! Arguments: !!     key   - the output key !!     value - the input INTEGER(INT8) vector         type(key_type), intent(out) :: key         integer(int8), intent(in)   :: value(:)          key % value = value      end subroutine set_int8_key       pure function fnv_1_hasher( key ) !! Version: Experimental !! !! Hashes a key with the FNV_1 algorithm !! Arguments: !!     key  - the key to be hashed         type(key_type), intent(in)    :: key         integer(int_hash)             :: fnv_1_hasher          fnv_1_hasher = fnv_1_hash( key % value )      end function fnv_1_hasher       pure function fnv_1a_hasher( key ) !! Version: Experimental !! !! Hashes a key with the FNV_1a algorithm !! ([Specifications](../page/specs/stdlib_hashmaps.html#fnv_1a_hasher-calculates-a-hash-code-from-a-key)) !! !! Arguments: !!     key  - the key to be hashed         type(key_type), intent(in)    :: key         integer(int_hash)             :: fnv_1a_hasher          fnv_1a_hasher = fnv_1a_hash( key % value )      end function fnv_1a_hasher       pure function seeded_nmhash32_hasher( key ) !! Version: Experimental !! !! Hashes a key with the NMHASH32 hash algorithm !! ([Specifications](../page/specs/stdlib_hashmaps.html#seeded_nmhash32_hasher-calculates-a-hash-code-from-a-key)) !! !! Arguments: !!     key  - the key to be hashed !!     seed - the seed (unused) for the hashing algorithm         type(key_type), intent(in)    :: key         integer(int_hash)             :: seeded_nmhash32_hasher          seeded_nmhash32_hasher = nmhash32( key % value, &             int( z'DEADBEEF', int32 ) )      end function seeded_nmhash32_hasher       pure function seeded_nmhash32x_hasher( key ) !! Version: Experimental !! !! Hashes a key with the NMHASH32X hash algorithm !! ([Specifications](../page/specs/stdlib_hashmaps.html#seeded_nmhash32x_hasher-calculates-a-hash-code-from-a-key)) !! Arguments: !!     key  - the key to be hashed !!     seed - the seed (unused) for the hashing algorithm         type(key_type), intent(in)    :: key         integer(int_hash)             :: seeded_nmhash32x_hasher          seeded_nmhash32x_hasher = nmhash32x( key % value, &             int( z'DEADBEEF', int32 ) )      end function seeded_nmhash32x_hasher       pure function seeded_water_hasher( key ) !! Version: Experimental !! !! Hashes a key with the waterhash algorithm !! ([Specifications](../page/specs/stdlib_hashmaps.html#seeded_water_hasher-calculates-a-hash-code-from-a-key)) !! !! Arguments: !!     key  - the key to be hashed         type(key_type), intent(in)  :: key         integer(int_hash)           :: seeded_water_hasher          seeded_water_hasher = water_hash( key % value, &             int( z'DEADBEEF1EADBEEF', int64 ) )      end function seeded_water_hasher   end module stdlib_hashmap_wrappers 
stdlib_hashmaps.f90_stripped      module stdlib_hashmaps      use, intrinsic :: iso_fortran_env, only: &         character_storage_size,              &         error_unit      use stdlib_kinds, only: &         dp,                 &         int8,               &         int16,              &         int32,              &         int64      use stdlib_hashmap_wrappers      implicit none      private       public ::                  &         chaining_hashmap_type, &         hashmap_type,          &         open_hashmap_type       integer, parameter ::        &         inmap_probe_factor = 10, &         map_probe_factor   =  5       integer, parameter, public :: &         default_bits =  6,        &         max_bits     = 30       integer, parameter, public :: &         int_calls  = int64,       &         int_depth  = int64,       &         int_index  = int32,       &         int_probes = int64       integer, parameter, public ::  &         success = 0,               &         alloc_fault = 1,           &         array_size_error = 2       integer, parameter ::             &          int8_bits = bit_size(0_int8), &         char_bits = character_storage_size       real, parameter, public ::      &         load_factor = 0.5625       integer(int32), parameter :: pool_size = 64      character(*), parameter, private :: module_name = 'STDLIB_HASHMAPS'      type, abstract :: hashmap_type             private         integer(int_calls) :: call_count = 0          integer(int_calls) :: probe_count = 0          integer(int_calls) :: total_probes = 0          integer(int_index) :: num_entries = 0          integer(int_index) :: num_free = 0          integer(int32)     :: nbits = default_bits          procedure(hasher_fun), pointer, nopass :: hasher => fnv_1_hasher       contains          procedure, non_overridable, pass(map) :: calls         procedure, non_overridable, pass(map) :: entries         procedure, non_overridable, pass(map) :: map_probes         procedure, non_overridable, pass(map) :: num_slots         procedure, non_overridable, pass(map) :: slots_bits         procedure(get_all_keys), deferred, pass(map) :: get_all_keys         procedure(get_other), deferred, pass(map)    :: get_other_data         procedure(init_map), deferred, pass(map)     :: init         procedure(key_test), deferred, pass(map)     :: key_test         procedure(loading), deferred, pass(map)      :: loading         procedure(map_entry), deferred, pass(map)    :: map_entry         procedure(rehash_map), deferred, pass(map)   :: rehash         procedure(remove_entry), deferred, pass(map) :: remove         procedure(set_other), deferred, pass(map)    :: set_other_data         procedure(total_depth), deferred, pass(map)  :: total_depth      end type hashmap_type       abstract interface          subroutine get_all_keys(map, all_keys)                      import hashmap_type, key_type             class(hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_keys          subroutine get_other( map, key, other, exists )                      import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             type(other_type), intent(out)      :: other             logical, intent(out), optional     :: exists         end subroutine get_other          subroutine init_map( map,         &                              hasher,      &                              slots_bits,  &                              status )                               import hashmap_type, hasher_fun, int32             class(hashmap_type), intent(out)     :: map             procedure(hasher_fun)                 :: hasher             integer, intent(in), optional         :: slots_bits             integer(int32), intent(out), optional :: status         end subroutine init_map          subroutine key_test(map, key, present)                       import hashmap_type, key_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             logical, intent(out)               :: present         end subroutine key_test          pure function loading( map )                    import hashmap_type             class(hashmap_type), intent(in) :: map             real :: loading         end function loading          subroutine map_entry(map, key, other, conflict)                  import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout)     :: map             type(key_type), intent(in)             :: key             type(other_type), intent(in), optional :: other             logical, intent(out), optional         :: conflict         end subroutine map_entry          subroutine rehash_map( map, hasher )                    import hashmap_type, hasher_fun             class(hashmap_type), intent(inout) :: map             procedure(hasher_fun)              :: hasher         end subroutine rehash_map          subroutine remove_entry(map, key, existed)                       import hashmap_type, key_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             logical, intent(out), optional     :: existed         end subroutine remove_entry          subroutine set_other( map, key, other, exists )                        import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             type(other_type), intent(in)       :: other             logical, intent(out), optional     :: exists         end subroutine set_other          function total_depth( map )                    import hashmap_type, int64             class(hashmap_type), intent(in) :: map             integer(int64)                   :: total_depth         end function total_depth      end interface        type :: chaining_map_entry_type               private         integer(int_hash)  :: hash_val          type(key_type)     :: key          type(other_type)   :: other          integer(int_index) :: inmap          type(chaining_map_entry_type), pointer :: next => null()      end type chaining_map_entry_type       type chaining_map_entry_ptr             type(chaining_map_entry_type), pointer :: target => null()     end type chaining_map_entry_ptr       type :: chaining_map_entry_pool             private          integer(int_index)                         :: next = 0         type(chaining_map_entry_type), allocatable :: more_map_entries(:)         type(chaining_map_entry_pool), pointer     :: lastpool => null()     end type chaining_map_entry_pool       type, extends(hashmap_type) :: chaining_hashmap_type             private         type(chaining_map_entry_pool), pointer    :: cache => null()          type(chaining_map_entry_type), pointer    :: free_list => null()          type(chaining_map_entry_ptr), allocatable :: inverse(:)          type(chaining_map_entry_ptr), allocatable :: slots(:)      contains         procedure :: get_all_keys => get_all_chaining_keys         procedure :: get_other_data => get_other_chaining_data         procedure :: init => init_chaining_map         procedure :: loading => chaining_loading         procedure :: map_entry => map_chain_entry         procedure :: rehash => rehash_chaining_map         procedure :: remove => remove_chaining_entry         procedure :: set_other_data => set_other_chaining_data         procedure :: total_depth => total_chaining_depth         procedure :: key_test => chaining_key_test         final     :: free_chaining_map     end type chaining_hashmap_type       interface          module subroutine free_chaining_map( map )                   type(chaining_hashmap_type), intent(inout) :: map         end subroutine free_chaining_map           module subroutine get_all_chaining_keys(map, all_keys)                    class(chaining_hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_chaining_keys           module subroutine get_other_chaining_data( map, key, other, exists )                      class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             type(other_type), intent(out)               :: other             logical, intent(out), optional              :: exists         end subroutine get_other_chaining_data           module subroutine init_chaining_map( map,       &                                              hasher,    &                                              slots_bits, &                                              status )                            class(chaining_hashmap_type), intent(out)  :: map             procedure(hasher_fun)                      :: hasher             integer, intent(in), optional              :: slots_bits             integer(int32), intent(out), optional      :: status         end subroutine init_chaining_map           module subroutine chaining_key_test(map, key, present)                     class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             logical, intent(out)                        :: present         end subroutine chaining_key_test           pure module function chaining_loading( map )                  class(chaining_hashmap_type), intent(in) :: map             real :: chaining_loading         end function chaining_loading           module subroutine map_chain_entry(map, key, other, conflict)                      class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)             :: key             type(other_type), intent(in), optional :: other             logical, intent(out), optional         :: conflict         end subroutine map_chain_entry           module subroutine rehash_chaining_map( map, hasher )                    class(chaining_hashmap_type), intent(inout) :: map             procedure(hasher_fun)                       :: hasher         end subroutine rehash_chaining_map           module subroutine remove_chaining_entry(map, key, existed)                      class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             logical, intent(out), optional              :: existed         end subroutine remove_chaining_entry           module subroutine set_other_chaining_data( map, key, other, exists )                       class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             type(other_type), intent(in)                :: other             logical, intent(out), optional              :: exists         end subroutine set_other_chaining_data           module function total_chaining_depth( map ) result(total_depth)                   class(chaining_hashmap_type), intent(in) :: map             integer(int_depth)                       :: total_depth         end function total_chaining_depth      end interface        type :: open_map_entry_type             private         integer(int_hash) :: hash_val          type(key_type)    :: key          type(other_type)  :: other          integer(int_index) :: inmap      end type open_map_entry_type      type :: open_map_entry_list            private         type(open_map_entry_type), pointer :: target => null()         type(open_map_entry_list), pointer :: next => null()     end type open_map_entry_list       type open_map_entry_ptr             type(open_map_entry_type), pointer :: target => null()     end type open_map_entry_ptr       type :: open_map_entry_pool            private         integer(int_index)                     :: next = 0          type(open_map_entry_type), allocatable :: more_map_entries(:)         type(open_map_entry_pool), pointer     :: lastpool => null()     end type open_map_entry_pool       type, extends(hashmap_type) :: open_hashmap_type            private         integer(int_index) :: index_mask = 2_int_index**default_bits-1          type(open_map_entry_pool), pointer    :: cache => null()          type(open_map_entry_list), pointer    :: free_list => null()          type(open_map_entry_ptr), allocatable  :: inverse(:)          integer(int_index), allocatable        :: slots(:)      contains         procedure :: get_all_keys => get_all_open_keys         procedure :: get_other_data => get_other_open_data         procedure :: init => init_open_map         procedure :: loading => open_loading         procedure :: map_entry => map_open_entry         procedure :: rehash => rehash_open_map         procedure :: remove => remove_open_entry         procedure :: set_other_data => set_other_open_data         procedure :: total_depth => total_open_depth         procedure :: key_test => open_key_test         final     :: free_open_map     end type open_hashmap_type      interface          module subroutine free_open_map( map )                   type(open_hashmap_type), intent(inout) :: map         end subroutine free_open_map           module subroutine get_all_open_keys(map, all_keys)                    class(open_hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_open_keys           module subroutine get_other_open_data( map, key, other, exists )                      class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(out)           :: other             logical, intent(out), optional          :: exists         end subroutine get_other_open_data           module subroutine init_open_map( map,         &                                          hasher,      &                                          slots_bits,  &                                          status )                            class(open_hashmap_type), intent(out)      :: map             procedure(hasher_fun)                      :: hasher             integer, intent(in), optional              :: slots_bits             integer(int32), intent(out), optional      :: status         end subroutine init_open_map           module subroutine open_key_test(map, key, present)                     class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             logical, intent(out)                    :: present         end subroutine open_key_test           pure module function open_loading( map )                  class(open_hashmap_type), intent(in) :: map             real :: open_loading         end function open_loading           module subroutine map_open_entry(map, key, other, conflict)                       class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(in), optional  :: other             logical, intent(out), optional          :: conflict         end subroutine map_open_entry           module subroutine rehash_open_map( map, hasher )                    class(open_hashmap_type), intent(inout) :: map             procedure(hasher_fun)                   :: hasher         end subroutine rehash_open_map           module subroutine remove_open_entry(map, key, existed)                    class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             logical, intent(out), optional          :: existed         end subroutine remove_open_entry           module subroutine set_other_open_data( map, key, other, exists )                       class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(in)            :: other             logical, intent(out), optional          :: exists         end subroutine set_other_open_data           module function total_open_depth( map ) result(total_depth)                   class(open_hashmap_type), intent(in) :: map             integer(int64) :: total_depth         end function total_open_depth      end interface  contains      pure function calls( map )                class(hashmap_type), intent(in) :: map         integer(int_calls)              :: calls          calls = map % call_count      end function calls      pure function entries( map )                class(hashmap_type), intent(in) :: map         integer(int_index) :: entries          entries = map % num_entries      end function entries       pure function map_probes( map )                class(hashmap_type), intent(in) :: map         integer(int_calls) :: map_probes          map_probes = map % total_probes + map % probe_count      end function map_probes       pure function num_slots( map )                class(hashmap_type), intent(in) :: map         integer(int_index)              :: num_slots          num_slots = 2**map % nbits      end function num_slots       pure function slots_bits( map )                 class(hashmap_type), intent(in) :: map         integer                              :: slots_bits          slots_bits = map % nbits      end function slots_bits   end module stdlib_hashmaps 
stdlib_hashmaps.f90_comments !! The module, STDLIB_HASH_MAPS, implements two hash maps: !! CHAINING_HASH_MAP_TYPE, a separate chaining hash map; and OPEN_HASH_MAP_TYPE, !! an open addressing hash map using linear addressing. The two hash maps are !! implementations of the abstract type, HASH_MAP_TYPE.  module stdlib_hashmaps      use, intrinsic :: iso_fortran_env, only: &         character_storage_size,              &         error_unit      use stdlib_kinds, only: &         dp,                 &         int8,               &         int16,              &         int32,              &         int64      use stdlib_hashmap_wrappers      implicit none      private  !! Public data_types     public ::                  &         chaining_hashmap_type, &         hashmap_type,          &         open_hashmap_type  !! Values that parameterize David Chase's empirical SLOT expansion code     integer, parameter ::        &         inmap_probe_factor = 10, &         map_probe_factor   =  5  !! Values that parameterize the SLOTS table size     integer, parameter, public :: &         default_bits =  6,        &         max_bits     = 30  !! KIND values used to parameterixe the hash map and its procedures     integer, parameter, public :: &         int_calls  = int64,       &         int_depth  = int64,       &         int_index  = int32,       &         int_probes = int64  !! Error codes returned by the hash map procedures     integer, parameter, public ::  &         success = 0,               &         alloc_fault = 1,           &         array_size_error = 2  ! The number of bits used by various types     integer, parameter ::             & ! Should be 8         int8_bits = bit_size(0_int8), &         char_bits = character_storage_size  !! The hash map load factor     real, parameter, public ::      &         load_factor = 0.5625  !! The size of the pools of allocated map entries     integer(int32), parameter :: pool_size = 64      character(*), parameter, private :: module_name = 'STDLIB_HASHMAPS'      type, abstract :: hashmap_type !! Version: Experimental !! !! Type implementing an abstract hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-hashmap_type-abstract-type))         private         integer(int_calls) :: call_count = 0 !! Number of calls         integer(int_calls) :: probe_count = 0 !! Number of probes since last expansion         integer(int_calls) :: total_probes = 0 !! Cumulative number of probes         integer(int_index) :: num_entries = 0 !! Number of entries         integer(int_index) :: num_free = 0 !! Number of elements in the free_list         integer(int32)     :: nbits = default_bits !! Number of bits used to address the slots         procedure(hasher_fun), pointer, nopass :: hasher => fnv_1_hasher !! Hash function      contains          procedure, non_overridable, pass(map) :: calls         procedure, non_overridable, pass(map) :: entries         procedure, non_overridable, pass(map) :: map_probes         procedure, non_overridable, pass(map) :: num_slots         procedure, non_overridable, pass(map) :: slots_bits         procedure(get_all_keys), deferred, pass(map) :: get_all_keys         procedure(get_other), deferred, pass(map)    :: get_other_data         procedure(init_map), deferred, pass(map)     :: init         procedure(key_test), deferred, pass(map)     :: key_test         procedure(loading), deferred, pass(map)      :: loading         procedure(map_entry), deferred, pass(map)    :: map_entry         procedure(rehash_map), deferred, pass(map)   :: rehash         procedure(remove_entry), deferred, pass(map) :: remove         procedure(set_other), deferred, pass(map)    :: set_other_data         procedure(total_depth), deferred, pass(map)  :: total_depth      end type hashmap_type       abstract interface          subroutine get_all_keys(map, all_keys) !! Version: Experimental !! !! Returns the all keys contained in a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#get_all_keys-returns-all-the-keys-contained-in-a-map)) !! !! Arguments: !!     map - a hash map !!     all_keys - all the keys contained in a hash map !             import hashmap_type, key_type             class(hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_keys          subroutine get_other( map, key, other, exists ) !! Version: Experimental !! !! Returns the other data associated with the inverse table index !! Arguments: !!     map    - a hash map !!     key    - the key associated with a map entry !!     other  - the other data associated with the key !!     exists - a logical flag indicating whether an entry with that key exists !             import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             type(other_type), intent(out)      :: other             logical, intent(out), optional     :: exists         end subroutine get_other          subroutine init_map( map,         &                              hasher,      &                              slots_bits,  &                              status ) !! Version: Experimental !! !! Routine to allocate an empty map with HASHER as the hash function, !! 2**SLOTS_BITS initial SIZE(map % slots), SIZE(map % slots) limited to a !! maximum of 2**MAX_BITS, and with up to LOAD_FACTOR * SIZE(map % slots), !! map % inverse elements. All fields are initialized. !! Arguments: !!     map         - the hash maap to be initialized !!     hasher      - the hash function to be used to map keys to slots !!     slots_bits   - the number of bits initially used to map to the slots !!     status      - an integer error status flag with the allowed values: !!         success - no problems were found !!         alloc_fault - map % slots or map % inverse could not be allocated !!         array_size_error - slots_bits or max_bits is less than !!             default_bits or greater than strict_max_bits !!         real_value_error - load_factor is less than 0.375 or greater than !!             0.875 !             import hashmap_type, hasher_fun, int32             class(hashmap_type), intent(out)     :: map             procedure(hasher_fun)                 :: hasher             integer, intent(in), optional         :: slots_bits             integer(int32), intent(out), optional :: status         end subroutine init_map          subroutine key_test(map, key, present) !! Version: Experimental !! !! Returns a logical flag indicating whether KEY exists in the hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#key_test-indicates-whether-key-is-present)) !! !! Arguments: !!     map     - the hash map of interest !!     key     - the key of interest !!     present - a flag indicating whether key is present in the map !             import hashmap_type, key_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             logical, intent(out)               :: present         end subroutine key_test          pure function loading( map ) !! Version: Experimental !! !! Returns the number of entries relative to slots in a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#loading-returns-the-ratio-of-entries-to-slots)) !! !! Arguments: !!       map - a hash map             import hashmap_type             class(hashmap_type), intent(in) :: map             real :: loading         end function loading          subroutine map_entry(map, key, other, conflict) !! Version: Experimental !! !! Inserts an entry into the hash table !! ([Specifications](../page/specs/stdlib_hashmaps.html#map_entry-inserts-an-entry-into-the-hash-map)) !!             import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout)     :: map             type(key_type), intent(in)             :: key             type(other_type), intent(in), optional :: other             logical, intent(out), optional         :: conflict         end subroutine map_entry          subroutine rehash_map( map, hasher ) !! Version: Experimental !! !! Changes the hashing method of the table entries to that of HASHER. !! Arguments: !!     map      the table to be rehashed !!     hasher the hasher function to be used for the table !             import hashmap_type, hasher_fun             class(hashmap_type), intent(inout) :: map             procedure(hasher_fun)              :: hasher         end subroutine rehash_map          subroutine remove_entry(map, key, existed) ! Chase's delent !! Version: Experimental !! !! Remove the entry, if any, that has the key !! Arguments: !!    map     - the table from which the entry is to be removed !!    key     - the key to an entry !!    existed - a logical flag indicating whether an entry with the key !!              was present in the original map !             import hashmap_type, key_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             logical, intent(out), optional     :: existed         end subroutine remove_entry          subroutine set_other( map, key, other, exists ) !! Version: Experimental !! !! Change the other data associated with the key !! Arguments: !!     map    - the map with the entry of interest !!     key    - the key to the entry inthe map !!     other  - the new data to be associated with the key !!     exists - a logical flag indicating whether the key is already entered !!              in the map !! !             import hashmap_type, key_type, other_type             class(hashmap_type), intent(inout) :: map             type(key_type), intent(in)         :: key             type(other_type), intent(in)       :: other             logical, intent(out), optional     :: exists         end subroutine set_other          function total_depth( map ) !! Version: Experimental !! !! Returns the total number of ones based offsets of slot entriesyy from !! their slot index for a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#total_depth-returns-the-total-depth-of-the-hash-map-entries)) !! Arguments: !!     map - a hash map             import hashmap_type, int64             class(hashmap_type), intent(in) :: map             integer(int64)                   :: total_depth         end function total_depth      end interface  !! API for the chaining_hashmap_type      type :: chaining_map_entry_type  ! Hash entry !! Version: Experimental !! !! Chaining hash map entry type !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-chaining_map_entry_type-derived-type))         private         integer(int_hash)  :: hash_val !! Full hash value         type(key_type)     :: key !! The entry's key         type(other_type)   :: other !! Other entry data         integer(int_index) :: inmap !! Index into inverse table         type(chaining_map_entry_type), pointer :: next => null() !! Next bucket     end type chaining_map_entry_type       type chaining_map_entry_ptr !! Version: Experimental !! !! Wrapper for a pointer to a chaining map entry type object !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-chaining_map_entry_type_ptr-derived-type))         type(chaining_map_entry_type), pointer :: target => null()     end type chaining_map_entry_ptr       type :: chaining_map_entry_pool !! Version: Experimental !! !! Type implementing a pool of allocated `chaining_map_entry_type` !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-chaining_map_entry_pool-derived-type))         private ! Index of next bucket         integer(int_index)                         :: next = 0         type(chaining_map_entry_type), allocatable :: more_map_entries(:)         type(chaining_map_entry_pool), pointer     :: lastpool => null()     end type chaining_map_entry_pool       type, extends(hashmap_type) :: chaining_hashmap_type !! Version: Experimental !! !! Type implementing the `chaining_hashmap_type` types !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-chaining_hashmap_type-derived-type))         private         type(chaining_map_entry_pool), pointer    :: cache => null() !! Pool of allocated chaining_map_entry_type objects         type(chaining_map_entry_type), pointer    :: free_list => null() !! free list of map entries         type(chaining_map_entry_ptr), allocatable :: inverse(:) !! Array of bucket lists (inverses) Note max_elts=size(inverse)         type(chaining_map_entry_ptr), allocatable :: slots(:) !! Array of bucket lists Note # slots=size(slots)     contains         procedure :: get_all_keys => get_all_chaining_keys         procedure :: get_other_data => get_other_chaining_data         procedure :: init => init_chaining_map         procedure :: loading => chaining_loading         procedure :: map_entry => map_chain_entry         procedure :: rehash => rehash_chaining_map         procedure :: remove => remove_chaining_entry         procedure :: set_other_data => set_other_chaining_data         procedure :: total_depth => total_chaining_depth         procedure :: key_test => chaining_key_test         final     :: free_chaining_map     end type chaining_hashmap_type       interface          module subroutine free_chaining_map( map ) !! Version: Experimental !! !! Frees internal memory of an chaining map !! Arguments: !!     map - the chaining hash map whose memory is to be freed !             type(chaining_hashmap_type), intent(inout) :: map         end subroutine free_chaining_map           module subroutine get_all_chaining_keys(map, all_keys) !! Version: Experimental !! !! Returns all the keys contained in a hashmap !! Arguments: !!     map - an chaining hash map !!     all_keys - all the keys contained in a hash map !             class(chaining_hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_chaining_keys           module subroutine get_other_chaining_data( map, key, other, exists ) !! Version: Experimental !! !! Returns the other data associated with the inverse table index !! Arguments: !!     map   - a chaining hash table !!     key   - the key associated with a map entry !!     other - the other data associated with the key !!     exists - a logical flag indicating whether an entry with that key exists !             class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             type(other_type), intent(out)               :: other             logical, intent(out), optional              :: exists         end subroutine get_other_chaining_data           module subroutine init_chaining_map( map,       &                                              hasher,    &                                              slots_bits, &                                              status ) !! Version: Experimental !! !! Routine to allocate an empty map with HASHER as the hash function, !! 2**SLOTS_BITS initial SIZE(map % slots), and SIZE(map % slots) limited !! to a maximum of 2**MAX_BITS. All fields are initialized. !! Arguments: !!     map       - the chaining hash map to be initialized !!     hasher    - the hash function to be used to map keys to slots !!     slots_bits - the bits of two used to initialize the number of slots !!     status    - an integer error status flag with the allowed values: !!         success - no problems were found !!         alloc_fault - map % slots or map % inverse could not be allocated !!         array_size_error - slots_bits is less than default_bits or !!             greater than max_bits !             class(chaining_hashmap_type), intent(out)  :: map             procedure(hasher_fun)                      :: hasher             integer, intent(in), optional              :: slots_bits             integer(int32), intent(out), optional      :: status         end subroutine init_chaining_map           module subroutine chaining_key_test(map, key, present) !! Version: Experimental !! !! Returns a logical flag indicating whether KEY is present in the hash map !! Arguments: !!     map     - the hash map of interest !!     key     - the key of interest !!     present - a logical flag indicating whether key is present in map !             class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             logical, intent(out)                        :: present         end subroutine chaining_key_test           pure module function chaining_loading( map ) !! Version: Experimental !! !! Returns the number of entries relative to slots in a hash map !! Arguments: !!      map - a chaining hash map             class(chaining_hashmap_type), intent(in) :: map             real :: chaining_loading         end function chaining_loading           module subroutine map_chain_entry(map, key, other, conflict) ! !     Inserts an entry innto the hash map !     Arguments: !!      map      - the hash table of interest !!      key      - the key identifying the entry !!      other    - other data associated with the key !!      conflict - logical flag indicating whether the entry key conflicts !!                 with an existing key !             class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)             :: key             type(other_type), intent(in), optional :: other             logical, intent(out), optional         :: conflict         end subroutine map_chain_entry           module subroutine rehash_chaining_map( map, hasher ) !! Version: Experimental !! !! Changes the hashing method of the table entries to that of HASHER. !! Arguments: !!     map    the table to be rehashed !!     hasher the hasher function to be used for the table !             class(chaining_hashmap_type), intent(inout) :: map             procedure(hasher_fun)                       :: hasher         end subroutine rehash_chaining_map           module subroutine remove_chaining_entry(map, key, existed) !! Version: Experimental !! !! Remove the entry, if any, that has the key !! Arguments: !!    map     - the table from which the entry is to be removed !!    key     - the key to an entry !!    existed - a logical flag indicating whether an entry with the key !!              was present in the original map !             class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             logical, intent(out), optional              :: existed         end subroutine remove_chaining_entry           module subroutine set_other_chaining_data( map, key, other, exists ) !! Version: Experimental !! !! Change the other data associated with the key !! Arguments: !!     map    - the map with the entry of interest !!     key    - the key to the entry inthe map !!     other  - the new data to be associated with the key !!     exists - a logical flag indicating whether the key is already entered !!              in the map !             class(chaining_hashmap_type), intent(inout) :: map             type(key_type), intent(in)                  :: key             type(other_type), intent(in)                :: other             logical, intent(out), optional              :: exists         end subroutine set_other_chaining_data           module function total_chaining_depth( map ) result(total_depth) !! Version: Experimental !! !! Returns the total number of ones based offsets of slot entries from !! their slot index for a hash map !! Arguments: !!     map - an chaining hash map             class(chaining_hashmap_type), intent(in) :: map             integer(int_depth)                       :: total_depth         end function total_chaining_depth      end interface  !! API for the open_hashmap_type      type :: open_map_entry_type !! Version: Experimental !! !! Open hash map entry type !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-open_map_entry_type-derived-type))         private         integer(int_hash) :: hash_val !! Full hash value         type(key_type)    :: key !! Hash entry key         type(other_type)  :: other !! Other entry data         integer(int_index) :: inmap !! Index into inverse table     end type open_map_entry_type      type :: open_map_entry_list !! Version: Experimental !! !! Open hash map entry type         private         type(open_map_entry_type), pointer :: target => null()         type(open_map_entry_list), pointer :: next => null()     end type open_map_entry_list       type open_map_entry_ptr !! Version: Experimental !! !! Wrapper for a pointer to an open hash map entry type object !! ([Specifications](../page/specs/stdlib_hashmaps.html#the-open_map_entry_ptr-derived-type))         type(open_map_entry_type), pointer :: target => null()     end type open_map_entry_ptr       type :: open_map_entry_pool !! Version: Experimental !! !! Type implementing a pool of allocated `open_map_entry_type`         private         integer(int_index)                     :: next = 0 !! Index of next bucket         type(open_map_entry_type), allocatable :: more_map_entries(:)         type(open_map_entry_pool), pointer     :: lastpool => null()     end type open_map_entry_pool       type, extends(hashmap_type) :: open_hashmap_type !! Version: Experimental !! !! Type implementing an "open" hash map         private         integer(int_index) :: index_mask = 2_int_index**default_bits-1 !! Mask used in linear addressing         type(open_map_entry_pool), pointer    :: cache => null() !! Pool of allocated open_map_entry_type objects         type(open_map_entry_list), pointer    :: free_list => null() !! free list of map entries         type(open_map_entry_ptr), allocatable  :: inverse(:) !! Array of bucket lists (inverses) Note max_elts=size(inverse)         integer(int_index), allocatable        :: slots(:) !! Array of indices to the inverse Note # slots=size(slots)     contains         procedure :: get_all_keys => get_all_open_keys         procedure :: get_other_data => get_other_open_data         procedure :: init => init_open_map         procedure :: loading => open_loading         procedure :: map_entry => map_open_entry         procedure :: rehash => rehash_open_map         procedure :: remove => remove_open_entry         procedure :: set_other_data => set_other_open_data         procedure :: total_depth => total_open_depth         procedure :: key_test => open_key_test         final     :: free_open_map     end type open_hashmap_type      interface          module subroutine free_open_map( map ) !! Version: Experimental !! !! Frees internal memory of an open map !! Arguments: !!     map - the open hash map whose memory is to be freed !             type(open_hashmap_type), intent(inout) :: map         end subroutine free_open_map           module subroutine get_all_open_keys(map, all_keys) !! Version: Experimental !! !! Returns all the keys contained in a hashmap !! Arguments: !!     map - an open hash map !!     all_keys - all the keys contained in a hash map !             class(open_hashmap_type), intent(in) :: map             type(key_type), allocatable, intent(out) :: all_keys(:)         end subroutine get_all_open_keys           module subroutine get_other_open_data( map, key, other, exists ) !! Version: Experimental !! !! Returns the other data associated with the inverse table index !! Arguments: !!     map   - an open hash table !!     key   - the key associated with a map entry !!     other - the other data associated with the key !!     exists - a logical flag indicating whether an entry with that key exists !             class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(out)           :: other             logical, intent(out), optional          :: exists         end subroutine get_other_open_data           module subroutine init_open_map( map,         &                                          hasher,      &                                          slots_bits,  &                                          status ) !! Version: Experimental !! !! Routine to allocate an empty map with HASHER as the hash function, !! 2**SLOTS_BITS initial SIZE(map % slots), and SIZE(map % slots) limited to a !! maximum of 2**MAX_BITS. All fields are initialized. !! Arguments: !!     map         - the open hash maap to be initialized !!     hasher      - the hash function to be used to map keys to slots !!     slots_bits  - the number of bits used to map to the slots !!     status      - an integer error status flag with the allowed values: !!         success - no problems were found !!         alloc_fault - map % slots or map % inverse could not be allocated !!         array_size_error - slots_bits is less than default_bitd or !!             greater than max_bits              class(open_hashmap_type), intent(out)      :: map             procedure(hasher_fun)                      :: hasher             integer, intent(in), optional              :: slots_bits             integer(int32), intent(out), optional      :: status         end subroutine init_open_map           module subroutine open_key_test(map, key, present) !! Version: Experimental !! !! Returns a logical flag indicating whether KEY exists in the hash map !! Arguments: !!     map     - the hash map of interest !!     key     - the key of interest !!     present - a logical flag indicating whether KEY exists in the hash map !             class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             logical, intent(out)                    :: present         end subroutine open_key_test           pure module function open_loading( map ) !! Version: Experimental !! !! Returns the number of entries relative to slots in a hash map !! Arguments: !!       map - an open hash map             class(open_hashmap_type), intent(in) :: map             real :: open_loading         end function open_loading           module subroutine map_open_entry(map, key, other, conflict) !! Version: Experimental !! !! Inserts an entry into the hash table !! Arguments: !!     map      - the hash table of interest !!     key      - the key identifying the entry !!     other    - other data associated with the key !!     conflict - logical flag indicating whether the entry key conflicts !!                 with an existing key !             class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(in), optional  :: other             logical, intent(out), optional          :: conflict         end subroutine map_open_entry           module subroutine rehash_open_map( map, hasher ) !! Version: Experimental !! !! Changes the hashing method of the table entries to that of HASHER. !! Arguments: !!     map      the table to be rehashed !!     hasher the hasher function to be used for the table !             class(open_hashmap_type), intent(inout) :: map             procedure(hasher_fun)                   :: hasher         end subroutine rehash_open_map           module subroutine remove_open_entry(map, key, existed) !! Remove the entry, if any, that has the key !! Arguments: !!    map     - the table from which the entry is to be removed !!    key     - the key to an entry !!    existed - a logical flag indicating whether an entry with the key !!              was present in the original map !             class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             logical, intent(out), optional          :: existed         end subroutine remove_open_entry           module subroutine set_other_open_data( map, key, other, exists ) !! Version: Experimental !! !! Change the other data associated with the key !! Arguments: !!     map    - the map with the entry of interest !!     key    - the key to the entry inthe map !!     other  - the new data to be associated with the key !!     exists - a logical flag indicating whether the key is already entered !!              in the map !             class(open_hashmap_type), intent(inout) :: map             type(key_type), intent(in)              :: key             type(other_type), intent(in)            :: other             logical, intent(out), optional          :: exists         end subroutine set_other_open_data           module function total_open_depth( map ) result(total_depth) !! Version: Experimental !! !! Returns the total number of ones based offsets of slot entries from !! their slot index for a hash map !! Arguments: !!     map - an open hash map             class(open_hashmap_type), intent(in) :: map             integer(int64) :: total_depth         end function total_open_depth      end interface  contains      pure function calls( map ) !! Version: Experimental !! !! Returns the number of subroutine calls on an open hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#calls-returns-the-number-of-calls-on-the-hash-map)) !! !! Arguments: !!     map - an open hash map         class(hashmap_type), intent(in) :: map         integer(int_calls)              :: calls          calls = map % call_count      end function calls      pure function entries( map ) !! Version: Experimental !! !! Returns the number of entries in a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#entries-returns-the-number-of-entries-in-the-hash-map)) !! !! Arguments: !!     map - an open hash map         class(hashmap_type), intent(in) :: map         integer(int_index) :: entries          entries = map % num_entries      end function entries       pure function map_probes( map ) !! Version: Experimental !! !! Returns the total number of table probes on a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#map_probes-returns-the-number-of-hash-map-probes)) !! !! Arguments: !!     map - an open hash map         class(hashmap_type), intent(in) :: map         integer(int_calls) :: map_probes          map_probes = map % total_probes + map % probe_count      end function map_probes       pure function num_slots( map ) !! Version: Experimental !! !! Returns the number of allocated slots in a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#num_slots-returns-the-number-of-hash-map-slots)) !! !! Arguments: !!     map - an open hash map         class(hashmap_type), intent(in) :: map         integer(int_index)              :: num_slots          num_slots = 2**map % nbits      end function num_slots       pure function slots_bits( map ) !! Version: Experimental !! !! Returns the number of bits used to specify the number of allocated !! slots in a hash map !! ([Specifications](../page/specs/stdlib_hashmaps.html#slots_bits-returns-the-number-of-bits-used-to-address-the-hash-map-slots)) !! !! Arguments: !!     map - an open hash map         class(hashmap_type), intent(in) :: map         integer                              :: slots_bits          slots_bits = map % nbits      end function slots_bits   end module stdlib_hashmaps 
stdlib_logger.f90_stripped module stdlib_logger                                                use, intrinsic ::           &         iso_fortran_env, only : &         error_unit,             &         input_unit,             &         output_unit      use stdlib_ascii, only : to_lower     use stdlib_optval, only : optval      implicit none      private     public :: global_logger, logger_type           integer, parameter, public :: &         success = 0,              &         close_failure = 1,        &         index_invalid_error = 2,  &         non_sequential_error = 3, &         open_failure = 4,         &         read_only_error = 5,      &         unformatted_in_error = 6, &         unopened_in_error = 7,    &         write_failure = 8      integer, parameter, public ::      &         debug_level = 10,       &         information_level = 20, &         warning_level = 30,     &         error_level = 40,       &         io_error_level = 40,    &         text_error_level = 50,  &         all_level = -10 + min(  &             debug_level,        &             information_level,  &             warning_level,      &             error_level,        &             io_error_level,     &             text_error_level),  &         none_level = 10 + max(  &             debug_level,        &             information_level,  &             warning_level,      &             error_level,        &             io_error_level,     &             text_error_level)      character(*), parameter :: module_name = 'stdlib_logger'      type :: logger_type                                    private          logical                   :: add_blank_line = .false.         logical                   :: indent_lines = .true.         integer                   :: level = information_level         integer, allocatable      :: log_units(:)         integer                   :: max_width = 0         logical                   :: time_stamp = .true.         integer                   :: units = 0      contains          private          procedure, public, pass(self) :: add_log_file         procedure, public, pass(self) :: add_log_unit         procedure, public, pass(self) :: configuration         procedure, public, pass(self) :: configure         procedure, public, pass(self) :: log_debug         procedure, public, pass(self) :: log_error         procedure, public, pass(self) :: log_information         procedure, public, pass(self) :: log_io_error         procedure, public, pass(self) :: log_message         procedure, public, pass(self) :: log_text_error         procedure, public, pass(self) :: log_units_assigned         procedure, public, pass(self) :: log_warning         procedure, public, pass(self) :: remove_log_unit          final :: final_logger      end type logger_type           type(logger_type) :: global_logger      character(*), parameter :: &         invalid_column = 'column is not a valid index to line.'  contains      subroutine add_log_file( self, filename, unit, action, position, status, &                              stat )                     class(logger_type), intent(inout)  :: self          character(*), intent(in)           :: filename          integer, intent(out), optional     :: unit          character(*), intent(in), optional :: action          character(*), intent(in), optional :: position          character(*), intent(in), optional :: status          integer, intent(out), optional     :: stat                               character(16)  :: aaction, aposition, astatus         integer        :: aunit         character(128) :: iomsg         integer        :: iostat         character(*), parameter :: procedure_name = 'add_log_file'         integer, allocatable :: dummy(:)         integer        :: lun         integer        :: i          aaction = optval(action, 'write')         aposition = optval(position, 'rewind')         astatus = optval(status, 'replace')          if ( len_trim(aaction) == 4 ) then              do i=1, 4                 aaction(i:i) = to_lower(aaction(i:i))             end do              if ( aaction == 'read' ) then                 if ( present( stat ) ) then                     stat = read_only_error                     return                 else                     error stop 'In ' // module_name // ' % ' //         &                         procedure_name // ' action is "read" which ' // &                         'does not allow writes to the file.'                 end if             end if          end if          open( newunit=aunit, file=filename, form='formatted', action=aaction, &               position=aposition, status=astatus, iostat=iostat, iomsg=iomsg, &               err=999 )          if ( allocated( self % log_units ) ) then             if ( size(self % log_units) == self % units ) then                 allocate( dummy(2*self % units) )                 do lun=1, self % units                     dummy(lun) = self % log_units(lun)                 end do                 dummy(self % units+1:) = 0                 call move_alloc( dummy, self % log_units )             end if         else             allocate( self % log_units(16) )         end if          self % log_units(self % units + 1 ) = aunit         self % units = self % units + 1         if ( present(unit) ) unit = aunit         if ( present(stat) ) stat = success          return  999     if (present(stat) ) then             stat = open_failure             return         else             call self % log_io_error( 'Unable to open ' // trim(filename), &                                       module = module_name,                &                                       procedure = procedure_name,          &                                       iostat = iostat,                     &                                       iomsg = iomsg )             error stop module_name // ' % ' // procedure_name // &                 ': Unable to open file'         end if      end subroutine add_log_file       subroutine add_log_unit( self, unit, stat )                  class(logger_type), intent(inout) :: self          integer, intent(in)               :: unit          integer, intent(out), optional    :: stat                                        integer, allocatable :: dummy(:)         character(*), parameter :: procedure_name = 'set_log_unit'         integer :: lun         character(12) :: specifier         logical :: question         integer :: istat          call validate_unit()         if ( present(stat) ) then             if ( stat /= success ) return         end if          do lun = 1, self % units              if (self % log_units(lun) == unit ) return         end do          if ( allocated( self % log_units ) ) then             if ( size(self % log_units) == self % units ) then                 allocate( dummy(2*self % units) )                 do lun=1, self % units                     dummy(lun) = self % log_units(lun)                 end do                 call move_alloc( dummy, self % log_units )             end if         else             allocate( self % log_units(16) )         end if          self % log_units(self % units + 1 ) = unit         self % units = self % units + 1      contains          subroutine validate_unit()               if ( unit == input_unit ) then                 if ( present(stat) ) then                     stat = read_only_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' must not be input_unit.'                 end if             end if               inquire( unit, opened=question, iostat=istat )             if(istat /= 0) question = .false.             if ( .not. question ) then                 if ( present(stat) ) then                     stat = unopened_in_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not open.'                 end if             end if               inquire( unit, write=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = read_only_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not writeable.'                 end if             end if              inquire( unit, sequential=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = non_sequential_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not "sequential".'                 end if             end if              inquire( unit, formatted=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = unformatted_in_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not "formatted".'                 end if             end if              if ( present(stat) ) stat = success          end subroutine validate_unit      end subroutine add_log_unit       pure subroutine configuration( self, add_blank_line, indent, level, &         max_width, time_stamp, log_units )                           class(logger_type), intent(in)              :: self          logical, intent(out), optional              :: add_blank_line          logical, intent(out), optional              :: indent          integer, intent(out), optional              :: level          integer, intent(out), optional              :: max_width          logical, intent(out), optional              :: time_stamp          integer, intent(out), allocatable, optional :: log_units(:)                                if ( present(add_blank_line) ) add_blank_line = self % add_blank_line         if ( present(indent) ) indent = self % indent_lines         if ( present(level) ) level = self % level         if ( present(max_width) ) max_width = self % max_width         if ( present(time_stamp) ) time_stamp = self % time_stamp         if ( present(log_units) ) then             if ( self % units .gt. 0 ) then                 log_units = self % log_units(1:self % units)             else                 allocate(log_units(0))             end if         end if      end subroutine configuration       pure subroutine configure( self, add_blank_line, indent, level, max_width, &         time_stamp )                                   class(logger_type), intent(inout) :: self         logical, intent(in), optional     :: add_blank_line         logical, intent(in), optional     :: indent         integer, intent(in), optional     :: level         integer, intent(in), optional     :: max_width         logical, intent(in), optional     :: time_stamp          if ( present(add_blank_line) ) self % add_blank_line = add_blank_line         if ( present(level) ) self % level = level         if ( present(indent) ) self % indent_lines = indent         if ( present(max_width) ) then             if ( max_width <= 4 ) then                 self % max_width = 0             else                 self % max_width = max_width             end if         end if         if ( present(time_stamp) ) self % time_stamp = time_stamp      end subroutine configure       subroutine final_logger( self )            type(logger_type), intent(in) :: self          integer        :: iostat         character(256) :: message         integer        :: unit          do unit=1, self % units             flush( self % log_units(unit), iomsg=message, iostat=iostat )             if ( iostat /= 0 ) then                 write(error_unit, '(a, i0)' ) 'In the logger_type ' // &                     'finalizer an error occurred in flushing unit = ', &                     self % log_units(unit)                 write(error_unit, '(a, i0)') 'With iostat = ', iostat                 write(error_unit, '(a)') 'With iomsg = ' // trim(message)             end if         end do      end subroutine final_logger       subroutine format_output_string( self, string, col_indent, len_buffer, buffer )              class(logger_type), intent(in)             :: self         character(*), intent(in)                   :: string         character(*), intent(in)                   :: col_indent         integer, intent(out)                       :: len_buffer         character(len=:), allocatable, intent(out) :: buffer          integer :: count, indent_len, index_, length, remain         integer, parameter :: new_len = len(new_line('a'))          length = len_trim(string)         allocate( character(2*length) :: buffer )         len_buffer = 0         indent_len = len(col_indent)         call format_first_line()          if ( self % indent_lines ) then             do while( remain > 0 )                 call indent_format_subsequent_line()             end do         else             do while( remain > 0 )                 call format_subsequent_line()             end do         end if      contains          subroutine format_first_line()              if ( self % max_width == 0 .or.                     &                 ( length <= self % max_width .and.              &                 index( string(1:length), new_line('a')) == 0 ) ) then                 buffer(1:length) = string(1:length)                 len_buffer = length                 remain = 0                 return             else                  index_ = index( string(1:min(length, self % max_width)), &                                 new_line('a') )                 if ( index_ == 0 ) then                     do index_=self % max_width, 1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == 0 ) then                     buffer(1:self % max_width) = &                         string(1:self % max_width)                     len_buffer = self % max_width                     count = self % max_width                     remain = length - count                     return                 else                     buffer(1:index_-1) = string(1:index_-1)                     len_buffer = index_-1                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine format_first_line          subroutine format_subsequent_line()             integer :: new_len_buffer             character(:), allocatable :: dummy              if ( remain <= self % max_width ) then                 new_len_buffer = len_buffer + length - count + new_len                 if ( new_len_buffer > len( buffer ) ) then                     allocate( character( 2*len( buffer ) ) :: dummy )                     dummy = buffer                     call move_alloc( dummy, buffer )                 end if                 buffer( len_buffer+1:new_len_buffer ) = &                     new_line('a') // string(count+1:length)                 len_buffer = new_len_buffer                 count = length                 remain = 0                 return             else                  index_ = count + index(string(count+1:count+self % max_width),&                     new_line('a'))                 if(index_ == count) then                     do index_=count+self % max_width, count+1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == count ) then                     new_len_buffer = len_buffer + self % max_width + &                         new_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1:new_len_buffer ) = &                         new_line('a') // string(count+1:count+self % max_width)                     len_buffer = new_len_buffer                     count = count + self % max_width                     remain = length - count                     return                 else                     new_len_buffer = len_buffer + index_ - 1 &                         - count + new_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1:new_len_buffer ) = &                         new_line('a') // string(count+1:index_-1)                     len_buffer = new_len_buffer                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine format_subsequent_line          subroutine indent_format_subsequent_line()             integer :: new_len_buffer             character(:), allocatable :: dummy              if ( index( string(count+1:length), new_line('a')) == 0 .and. &                 remain <= self % max_width - indent_len ) then                 new_len_buffer = len_buffer + length &                     - count + new_len + indent_len                 if ( new_len_buffer > len( buffer ) ) then                     allocate( character( 2*len( buffer ) ) :: dummy )                     dummy = buffer                     call move_alloc( dummy, buffer )                 end if                 buffer( len_buffer+1:new_len_buffer ) = &                     new_line('a') // col_indent // string(count+1:length)                 len_buffer = new_len_buffer                 count = length                 remain = 0                 return             else                  index_ = count + index( string(count+1:                   &                     min ( length, count+self % max_width - indent_len) ), &                     new_line('a'))                 if(index_ == count) then                     do index_=count+self % max_width-indent_len, count+1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == count ) then                     new_len_buffer = len_buffer + self % max_width &                         + new_len                      if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1: new_len_buffer ) = &                         new_line('a') // col_indent // &                         string(count+1:count+self % max_width-indent_len)                     len_buffer = new_len_buffer                     count = count + self % max_width - indent_len                     remain = length - count                     return                 else                     new_len_buffer = len_buffer + index_ - count - 1 &                         + new_len + indent_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1: new_len_buffer ) = &                         new_line('a') // col_indent // string(count+1:index_-1)                     len_buffer = new_len_buffer                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine indent_format_subsequent_line      end subroutine format_output_string       subroutine handle_write_failure( unit, procedure_name, iostat, iomsg )              integer, intent(in)      :: unit         character(*), intent(in) :: procedure_name         integer, intent(in)      :: iostat         character(*), intent(in) :: iomsg          character(256) :: name         logical :: named         character(10) :: action           write( output_unit, '(a)' ) 'write failure in ' // module_name // &              ' % ' // trim(procedure_name) // '.'          if ( unit == -999 ) then              write( output_unit, '(a, i0)' ) 'unit = internal file'          else              write( output_unit, '(a, i0)' ) 'unit = ', unit              inquire( unit, named=named )               if ( named ) then                  inquire( unit, name=name )                  write( output_unit, '(a, a)' ) 'name = ', trim(name)              else                  write( output_unit, '(a)' ) 'unit is unnamed'              end if              inquire( unit, action=action )              write( output_unit, '(a, a)' ) 'action = ', trim(action)          end if           write( output_unit, '(a, i0)' ) 'iostat = ', iostat          write( output_unit, '(a, a )' ) 'iomsg = ', trim(iomsg)          error stop 'write failure in ' // module_name // '.'       end subroutine handle_write_failure       subroutine log_debug( self, message, module, procedure )                                                class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure            if ( self % level > debug_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = '      end subroutine log_debug       subroutine log_error( self, message, module, procedure, stat, errmsg )                                                    class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure          integer, intent(in), optional           :: stat          character(len=*), intent(in), optional  :: errmsg           integer :: iostat         character(28) :: dummy         character(256) :: iomsg         character(*), parameter :: procedure_name = 'log_error'         character(:), allocatable :: suffix          if ( self % level > error_level ) return          if ( present(stat) ) then             write( dummy, '(a, i0)', err=999, iostat=iostat, iomsg=iomsg ) &                 new_line('a') // "With stat = ", stat         else             dummy = ' '         end if          if ( present(errmsg) ) then             if ( len_trim(errmsg) > 0 ) then                 suffix = trim(dummy) // &                     new_line('a') // 'With errmsg = "' // trim(errmsg) // '"'             else                 suffix = dummy             end if         else             suffix = dummy         end if          call self % log_message( trim(message) // suffix, &                                  module = module,         &                                  procedure = procedure,   &                                  prefix = 'ERROR')          return  999     call handle_write_failure( -999, procedure_name, iostat, iomsg )      end subroutine log_error       subroutine log_information( self, message, module, procedure )                                                class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure            if ( self % level > information_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = 'INFO' )      end subroutine log_information       subroutine log_io_error( self, message, module, procedure, iostat, &                              iomsg )                                          class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure          integer, intent(in), optional           :: iostat          character(len=*), intent(in), optional  :: iomsg           character(28) :: dummy         character(256) :: iomsg2         integer :: iostat2         character(*), parameter :: procedure_name = 'log_io_error'         character(:), allocatable :: suffix          if ( self % level > io_error_level ) return          if ( present(iostat) ) then             write( dummy, '(a, i0)', err=999, iostat=iostat2, iomsg=iomsg2 ) &                 new_line('a') // "With iostat = ", iostat         else             dummy = ' '         end if          if ( present(iomsg) ) then             if ( len_trim(iomsg) > 0 ) then                 suffix = trim(dummy) // &                     new_line('a') // 'With iomsg = "' // trim(iomsg) // '"'             else                 suffix = trim(dummy)             end if         else             suffix = trim(dummy)         end if          call self % log_message( trim(message) // suffix, &                                  module = module,         &                                  procedure = procedure,   &                                  prefix = 'I/O ERROR' )          return  999     call handle_write_failure( -999, procedure_name, iostat2, iomsg2 )      end subroutine log_io_error      subroutine log_message( self, message, module, procedure, prefix )                                              class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure          character(len=*), intent(in), optional  :: prefix           integer :: unit         integer :: iostat         integer :: len_buffer         character(*), parameter :: procedure_name = 'log_message'         character(256) :: iomsg         character(:), allocatable :: d_and_t, m_and_p, pref         character(:), allocatable :: buffer          pref = optval(prefix, '')         if ( len(pref) > 0 ) pref = pref // ': '          if ( self % time_stamp ) then             d_and_t = time_stamp() // ': '         else             d_and_t = ''         end if          if ( present(module) ) then             if ( present(procedure) ) then                 m_and_p = trim(module) // ' % ' // trim(procedure) // ': '             else                 m_and_p = trim(module) // ': '             end if         else if ( present(procedure) ) then             m_and_p = trim(procedure) // ': '         else             m_and_p = ''         end if          call format_output_string( self,                         &                                    d_and_t // m_and_p // pref // &                                    trim( message ),              &                                    '    ',                       &                                    len_buffer,                   &                                    buffer)          if ( self % units == 0 ) then             if ( self % add_blank_line ) then                 write( output_unit, '(a)', err=999, iostat=iostat, &                         iomsg=iomsg) &                     new_line('a') // buffer(1:len_buffer)             else                 write( output_unit, '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) &                     buffer(1:len_buffer)             end if         else             if ( self % add_blank_line ) then                 do unit=1, self % units                     write( self % log_units(unit), '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) new_line('a') // &                         buffer(1:len_buffer)                 end do             else                 do unit=1, self % units                     write( self % log_units(unit), '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) &                         buffer(1:len_buffer)                 end do             end if         end if           return  999     call handle_write_failure( unit, procedure_name, iostat, iomsg )      end subroutine log_message      subroutine log_text_error( self, line, column, summary, filename,  &                                line_number, caret, stat )                                                class(logger_type), intent(in)        :: self          character(*), intent(in)              :: line          integer, intent(in)                   :: column          character(*), intent(in)              :: summary          character(*), intent(in), optional    :: filename          integer, intent(in), optional         :: line_number          character(1), intent(in), optional    :: caret          integer, intent(out), optional        :: stat              character(1)                  :: acaret         character(128)                :: iomsg         integer                       :: iostat         integer                       :: lun         character(*), parameter       :: procedure_name = 'LOG_TEXT_ERROR'         character(len=:), allocatable :: buffer          if ( self % level > text_error_level ) return          acaret = optval(caret, '^')          if ( column < 0 .or. column > len( line ) + 1 ) then             if ( present(stat) ) then                 stat = index_invalid_error                 return             else                 call self % log_error( invalid_column,           &                                        module = module_name,     &                                        procedure = procedure_name )                 error stop module_name // ' % ' // procedure_name // ': ' // &                     invalid_column             end if         end if          call write_log_text_error_buffer( )         if ( self % units == 0 ) then             write( output_unit, '(a)' ) buffer         else             do lun=1, self % units                 write( self % log_units(lun), '(a)' ) buffer             end do         end if      contains          subroutine write_log_text_error_buffer( )             integer                   :: i             character(:), allocatable :: location, marker              if ( present(filename) ) then                 if ( present(line_number) ) then                     allocate( character(len_trim(filename)+15) :: location )                     write( location, fmt='(a, ":", i0, ":", i0)', err=999, &                            iomsg=iomsg, iostat=iostat )           &                            trim(filename) , line_number, column                 else                     allocate( character(len_trim(filename)+45) :: location )                     write( location, fmt='(a, i0)', err=999, iomsg=iomsg, &                            iostat=iostat ) &                            "Error found in file: '" // trim(filename) // &                            "', at column: ", column                 end if              else                 if ( present(line_number) ) then                     allocate( character(54) :: location )                     write( location, fmt='(a, i0, a, i0)', err=999, &                            iomsg=iomsg, iostat=iostat ) &                         'Error found at line number: ', line_number, &                         ', and column: ', column                 else                     allocate( character(36) :: location )                     write( location, &                            fmt='("Error found in line at column:", i0)' ) &                         column                 end if             end if              allocate( character(column) :: marker )             do i=1, column-1                 marker(i:i) = ' '             end do             marker(column:column) = acaret             if ( self % add_blank_line ) then                 if ( self % time_stamp ) then                     buffer = new_line('a') // time_stamp() // &                         new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 else                     buffer = new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 end if             else                 if ( self % time_stamp ) then                     buffer = time_stamp() // &                         new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 else                     buffer = trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 end if             end if              if ( present(stat) ) stat = success              return  999         if ( present( stat ) ) then                 stat = write_failure                 return             else                 call handle_write_failure( -999, procedure_name, iostat, &                                            iomsg )             end if          end subroutine write_log_text_error_buffer      end subroutine log_text_error       elemental function log_units_assigned(self)              class(logger_type), intent(in) :: self          integer                        :: log_units_assigned                               log_units_assigned = self % units      end function log_units_assigned       subroutine log_warning( self, message, module, procedure )                                               class(logger_type), intent(in)          :: self          character(len=*), intent(in)            :: message          character(len=*), intent(in), optional  :: module          character(len=*), intent(in), optional  :: procedure           if ( self % level > warning_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = 'WARN' )      end subroutine log_warning       subroutine remove_log_unit( self, unit, close_unit, stat )                   class(logger_type), intent(inout) :: self          integer, intent(in)               :: unit          logical, intent(in), optional     :: close_unit          integer, intent(out), optional    :: stat                              character(128) :: errmsg         integer :: lun, lun_old         character(*), parameter :: procedure_name = 'REMOVE_LOG_UNIT'          if ( present(stat) ) stat = success         do lun=1, self % units             if ( unit == self % log_units(lun) ) exit         end do          if ( lun == self % units + 1 ) return          if ( present(close_unit) ) then             if ( close_unit ) close( unit, err=999, iomsg=errmsg )         end if          do lun_old=lun+1, self % units             self % log_units(lun_old-1) = self % log_units(lun_old)         end do         self % units = self % units - 1          return  999     if ( present(stat) ) then             stat = close_failure             return         else             write(*, '(a, i0)') 'In ' // module_name // ' % ' // &                 procedure_name // ' close_unit failed for unit = ', unit             write(*, '(a)' ) 'With iomsg = ' // trim(errmsg)             error stop 'close_unit failed in ' // module_name // ' % ' // &                 procedure_name // '.'         end if      end subroutine remove_log_unit       function time_stamp()          character(23) :: time_stamp         character(8)  :: date         character(10) :: time          call date_and_time( date, time )          time_stamp(1:4)   = date(1:4)         time_stamp(5:5)   = '-'         time_stamp(6:7)   = date(5:6)         time_stamp(8:8)   = '-'         time_stamp(9:10)  = date(7:8)         time_stamp(11:11) = ' '         time_stamp(12:13) = time(1:2)         time_stamp(14:14) = ':'         time_stamp(15:16) = time(3:4)         time_stamp(17:17) = ':'         time_stamp(18:23) = time(5:10)      end function time_stamp  end module stdlib_logger 
stdlib_logger.f90_comments module stdlib_logger !!### Module stdlib_logger !! !! This module defines a derived type, procedures, a variable, and !! constants to be used for logging information and reporting errors !! in Fortran applications. !!([Specification](../page/specs/stdlib_logger.html))  !! The derived type, `logger_type`, is to be used to define variables to !! serve as both local and global loggers. A logger directs its messages !! to selected I/O units so the user has a record (a log) of major events. !! For each entity of `logger_type` the reports go to a list of I/O units !! represented by the private internal array, `log_units`. If `log_units` is !! empty then output by default goes to `output_unit`. Otherwise reports !! go to `output_unit` only if it has been explicitly added to `log_units`. !! Each entity of type `logger_type` also maintains an internal state !! controlling the formatting of output. !! !! The procedures are as follows. The logical function !! `log_units_assigned` returns the number of I/O units in `log_units`. The !! subroutines `add_log_file` and `add_log_unit` include the specified file !! in `log_units`. `remove_log_units` removes the specified logical unit from !! the `log_units` array and optionally closes the file. `configure` !! configures the details of the logging process. `configuration` !! reports the details of that configuration. The subroutines !! `log_error`, `log_information`, `log_io_error`, `log_message`, !! `log_text_error`, and `log_warning` send messages to the log units. !! !! The variable `global_logger` of type `logger_type` can be used !! as a default global logger anywhere in the source code. !! !! The constants are used to report errors by some of the subroutines !! in their optional `stat` arguments. The constants are as follows. !! `success` indicates that no error has occurred. `close_failure` !! indicates that a `close` statement for an I/O unit failed. !! `index_invalid_error` indicates that `column` was invalid for !! the given `line`. `open_failure` indicates that an `open` statement !! failed. `read_only_error` indicates that an output unit did not have a !! `"write"` or `"readwrite"` action. `non_sequential_error` indicates !! that the unit did not have `sequential` access. `unformatted_in_error` !! indicates that the unit did not have a `form` of `"formatted"`. !! `unopened_in_error` indicates that the unit was not opened. `write_failure` !! indicates that at least one of the writes to `log_units` failed.      use, intrinsic ::           &         iso_fortran_env, only : &         error_unit,             &         input_unit,             &         output_unit      use stdlib_ascii, only : to_lower     use stdlib_optval, only : optval      implicit none      private     public :: global_logger, logger_type      !! public constants used as error flags     integer, parameter, public :: &         success = 0,              &         close_failure = 1,        &         index_invalid_error = 2,  &         non_sequential_error = 3, &         open_failure = 4,         &         read_only_error = 5,      &         unformatted_in_error = 6, &         unopened_in_error = 7,    &         write_failure = 8      integer, parameter, public ::      &         debug_level = 10,       &         information_level = 20, &         warning_level = 30,     &         error_level = 40,       &         io_error_level = 40,    &         text_error_level = 50,  &         all_level = -10 + min(  &             debug_level,        &             information_level,  &             warning_level,      &             error_level,        &             io_error_level,     &             text_error_level),  &         none_level = 10 + max(  &             debug_level,        &             information_level,  &             warning_level,      &             error_level,        &             io_error_level,     &             text_error_level)      character(*), parameter :: module_name = 'stdlib_logger'      type :: logger_type         !! version: experimental                  !! Public derived type ([Specification](../page/specs/stdlib_logger.html#the-derived-type-logger_type))         private          logical                   :: add_blank_line = .false.         logical                   :: indent_lines = .true.         integer                   :: level = information_level         integer, allocatable      :: log_units(:)         integer                   :: max_width = 0         logical                   :: time_stamp = .true.         integer                   :: units = 0      contains          private          procedure, public, pass(self) :: add_log_file         procedure, public, pass(self) :: add_log_unit         procedure, public, pass(self) :: configuration         procedure, public, pass(self) :: configure         procedure, public, pass(self) :: log_debug         procedure, public, pass(self) :: log_error         procedure, public, pass(self) :: log_information         procedure, public, pass(self) :: log_io_error         procedure, public, pass(self) :: log_message         procedure, public, pass(self) :: log_text_error         procedure, public, pass(self) :: log_units_assigned         procedure, public, pass(self) :: log_warning         procedure, public, pass(self) :: remove_log_unit          final :: final_logger      end type logger_type      !! Variable of type `logger_type` to be used as a global logger     type(logger_type) :: global_logger      character(*), parameter :: &         invalid_column = 'column is not a valid index to line.'  contains      subroutine add_log_file( self, filename, unit, action, position, status, &                              stat ) !! version: experimental  !! Opens a formatted sequential access output file, `filename` using !! `newunit` and adds the resulting unit number to `self`'s `log_units` !! array. `action`, if present, is the `action` specifier of the `open` !! statement, and has the default value of `"write"`. `position`, if present, !! is the `position` specifier, and has the default value of `"REWIND"`. !! `status`, if present, is the `status` specifier of the `open` statement, !! and has the default value of `"REPLACE"`. `stat`, if present, has the value !! `success` if `filename` could be opened, `read_only_error` if `action` is !! `"read"`, and `open_failure` otherwise. !!([Specification](../page/specs/stdlib_logger.html#add_log_file-open-a-file-and-add-its-unit-to-self-log_units))         class(logger_type), intent(inout)  :: self !! The logger variable to which the file is to be added         character(*), intent(in)           :: filename !! The name of the file to be  added to the logger         integer, intent(out), optional     :: unit !! The resulting I/O unit number         character(*), intent(in), optional :: action !! The `action` specifier for the `open`` statement         character(*), intent(in), optional :: position !! The `position` specifier for the `open` statement         character(*), intent(in), optional :: status !! The `status` specifier for the  `open`  statement         integer, intent(out), optional     :: stat !! The error status on exit with the possible values !! * `success` - no errors found !! * `read_only_error` - file unopened as `action1 was `"read"` for an output !!   file !! * `open_failure` - the `open` statement failed   !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         integer :: unit, stat !!         ... !!         call global_logger % add_log_file( 'error_log.txt', unit,      & !!                                            position='asis', stat=stat ) !!         if ( stat /= success ) then !!             error stop 'Unable to open "error_log.txt".' !!         end if !!         ... !!     end program main          character(16)  :: aaction, aposition, astatus         integer        :: aunit         character(128) :: iomsg         integer        :: iostat         character(*), parameter :: procedure_name = 'add_log_file'         integer, allocatable :: dummy(:)         integer        :: lun         integer        :: i          aaction = optval(action, 'write')         aposition = optval(position, 'rewind')         astatus = optval(status, 'replace')          if ( len_trim(aaction) == 4 ) then              do i=1, 4                 aaction(i:i) = to_lower(aaction(i:i))             end do              if ( aaction == 'read' ) then                 if ( present( stat ) ) then                     stat = read_only_error                     return                 else                     error stop 'In ' // module_name // ' % ' //         &                         procedure_name // ' action is "read" which ' // &                         'does not allow writes to the file.'                 end if             end if          end if          open( newunit=aunit, file=filename, form='formatted', action=aaction, &               position=aposition, status=astatus, iostat=iostat, iomsg=iomsg, &               err=999 )          if ( allocated( self % log_units ) ) then             if ( size(self % log_units) == self % units ) then                 allocate( dummy(2*self % units) )                 do lun=1, self % units                     dummy(lun) = self % log_units(lun)                 end do                 dummy(self % units+1:) = 0                 call move_alloc( dummy, self % log_units )             end if         else             allocate( self % log_units(16) )         end if          self % log_units(self % units + 1 ) = aunit         self % units = self % units + 1         if ( present(unit) ) unit = aunit         if ( present(stat) ) stat = success          return  999     if (present(stat) ) then             stat = open_failure             return         else             call self % log_io_error( 'Unable to open ' // trim(filename), &                                       module = module_name,                &                                       procedure = procedure_name,          &                                       iostat = iostat,                     &                                       iomsg = iomsg )             error stop module_name // ' % ' // procedure_name // &                 ': Unable to open file'         end if      end subroutine add_log_file       subroutine add_log_unit( self, unit, stat ) !! version: experimental  !! Adds `unit` to the log file units in `log_units`. `unit` must be an `open` !! file, of `form` `"formatted"`, with `"sequential"` `access`, and an `action` !! of `"write"` or `"readwrite"`, otherwise either `stat`, if present, has a !! value other than `success` and `unit` is not entered into `log_units`, !! or, if `stat` is not presecn, processing stops. !!([Specification](../page/specs/stdlib_logger.html#add_log_unit-add-a-unit-to-the-array-self-log_units))          class(logger_type), intent(inout) :: self !! The logger variable to which the I/O unit is to be added         integer, intent(in)               :: unit !! The input logical unit number         integer, intent(out), optional    :: stat !! An error code with the possible values !! * `success` - no problems were found !! * `non_sequential_error` - `unit` did not have sequential access !! * `read_only_error` - `unit` was not writeable !! * `unformatted_in_error` - `unit` was an `'unformatted'` file !! * `unopened_in_error` - `unit` was not opened  !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         character(256) :: iomsg !!         integer :: iostat, unit, stat !!         ... !!         open( newunit=unit, 'error_log.txt', form='formatted', & !!               status='replace', position='rewind', err=999,    & !!               action='read', iostat=iostat, iomsg=iomsg ) !!         ... !!         call global_logger % add_log_unit( unit, stat ) !!         select case ( stat ) !!         ... !!         case ( read_only_error ) !!             error stop 'Unable to write to "error_log.txt".' !!         ... !!         end select !!         ... !!     999 error stop 'Unable to open "error_log.txt". !!         ... !!     end program main          integer, allocatable :: dummy(:)         character(*), parameter :: procedure_name = 'set_log_unit'         integer :: lun         character(12) :: specifier         logical :: question         integer :: istat          call validate_unit()         if ( present(stat) ) then             if ( stat /= success ) return         end if          do lun = 1, self % units ! Check that unit is not already registered             if (self % log_units(lun) == unit ) return         end do          if ( allocated( self % log_units ) ) then             if ( size(self % log_units) == self % units ) then                 allocate( dummy(2*self % units) )                 do lun=1, self % units                     dummy(lun) = self % log_units(lun)                 end do                 call move_alloc( dummy, self % log_units )             end if         else             allocate( self % log_units(16) )         end if          self % log_units(self % units + 1 ) = unit         self % units = self % units + 1      contains          subroutine validate_unit()  ! Check that unit is not input_unit             if ( unit == input_unit ) then                 if ( present(stat) ) then                     stat = read_only_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' must not be input_unit.'                 end if             end if  ! Check that unit is opened             inquire( unit, opened=question, iostat=istat )             if(istat /= 0) question = .false.             if ( .not. question ) then                 if ( present(stat) ) then                     stat = unopened_in_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not open.'                 end if             end if  ! Check that unit is writeable             inquire( unit, write=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = read_only_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not writeable.'                 end if             end if              inquire( unit, sequential=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = non_sequential_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not "sequential".'                 end if             end if              inquire( unit, formatted=specifier )             if ( specifier(1:1) /= 'Y' .and. specifier(1:1) /= 'y' ) then                 if ( present(stat) ) then                     stat = unformatted_in_error                     return                 else                     error stop 'unit in ' // module_name // ' % ' // &                         procedure_name // ' is not "formatted".'                 end if             end if              if ( present(stat) ) stat = success          end subroutine validate_unit      end subroutine add_log_unit       pure subroutine configuration( self, add_blank_line, indent, level, &         max_width, time_stamp, log_units ) !! version: experimental  !! Reports the logging configuration of `self`. The following attributes are !! reported: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !! 2. `indent` is a logical flag with `.true.` implying that subsequent columns !!    will be indented 4 spaces and `.false.` implying no indentation. !! 3. `level` is the lowest level for printing a message !! 4. `max_width` is the maximum number of columns of output text with !!    `max_width` == 0 => no bounds on output width. !! 5. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. !! 6. `log_units` is an array of the I/O unit numbers to which log output !!    will be written. !!([Specification](../page/specs/stdlib_logger.html#configuration-report-a-loggers-configuration))          class(logger_type), intent(in)              :: self !! The logger variable whose configuration is being reported         logical, intent(out), optional              :: add_blank_line !! A logical flag to add a preceding blank line         logical, intent(out), optional              :: indent !! A logical flag to indent subsequent lines         integer, intent(out), optional              :: level !! The minimum level for printing a message         integer, intent(out), optional              :: max_width !! The maximum number of columns for most outputs         logical, intent(out), optional              :: time_stamp !! A logical flag to add a time stamp         integer, intent(out), allocatable, optional :: log_units(:) !! The I/O units used in output  !!##### Example !! !!     module example_mod !!       use stdlib_logger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         call global_logger % configuration( log_units=log_units ) !!         if ( size(log_units) == 0 ) then !!            call add_logger_unit( unit ) !!         end if !!         .. !!       end subroutine example_sub !!       ... !!     end module example_mod          if ( present(add_blank_line) ) add_blank_line = self % add_blank_line         if ( present(indent) ) indent = self % indent_lines         if ( present(level) ) level = self % level         if ( present(max_width) ) max_width = self % max_width         if ( present(time_stamp) ) time_stamp = self % time_stamp         if ( present(log_units) ) then             if ( self % units .gt. 0 ) then                 log_units = self % log_units(1:self % units)             else                 allocate(log_units(0))             end if         end if      end subroutine configuration       pure subroutine configure( self, add_blank_line, indent, level, max_width, &         time_stamp ) !! version: experimental  !! Configures the logging process for SELF. The following attributes are !! configured: !! 1. `add_blank_line` is a logical flag with `.true.` implying that output !!    starts with a blank line, and `.false.` implying no blank line. !!    `add_blank_line` has a startup value of `.false.`. !! 2. `indent` is a logical flag with `.true.` implying that subsequent lines !!    will be indented 4 spaces and `.false.` implying no indentation. `indent` !!    has a startup value of `.true.`. !! 3. `level` is the lowest level for printing a message !! 4. `max_width` is the maximum number of columns of output text with !!    `max_width == 0` => no bounds on output width. `max_width` has a startup !!    value of 0. !! 5. `time_stamp` is a logical flag with `.true.` implying that the output !!    will have a time stamp, and `.false.` implying that there will be no !!    time stamp. `time_stamp` has a startup value of `.true.`. !!([Specification](../page/specs/stdlib_logger.html#configure-configure-the-logging-process)) !!##### Example !! !!     program main !!         use stdlib_logger !!         ... !!         call global_logger % configure( indent=.false., max_width=72 ) !!         ...          class(logger_type), intent(inout) :: self         logical, intent(in), optional     :: add_blank_line         logical, intent(in), optional     :: indent         integer, intent(in), optional     :: level         integer, intent(in), optional     :: max_width         logical, intent(in), optional     :: time_stamp          if ( present(add_blank_line) ) self % add_blank_line = add_blank_line         if ( present(level) ) self % level = level         if ( present(indent) ) self % indent_lines = indent         if ( present(max_width) ) then             if ( max_width <= 4 ) then                 self % max_width = 0             else                 self % max_width = max_width             end if         end if         if ( present(time_stamp) ) self % time_stamp = time_stamp      end subroutine configure       subroutine final_logger( self ) !! version: experimental  !! Finalizes the `logger_type` entity `self` by flushing the units         type(logger_type), intent(in) :: self          integer        :: iostat         character(256) :: message         integer        :: unit          do unit=1, self % units             flush( self % log_units(unit), iomsg=message, iostat=iostat )             if ( iostat /= 0 ) then                 write(error_unit, '(a, i0)' ) 'In the logger_type ' // &                     'finalizer an error occurred in flushing unit = ', &                     self % log_units(unit)                 write(error_unit, '(a, i0)') 'With iostat = ', iostat                 write(error_unit, '(a)') 'With iomsg = ' // trim(message)             end if         end do      end subroutine final_logger       subroutine format_output_string( self, string, col_indent, len_buffer, buffer ) !! version: experimental  !! Writes the STRING to UNIT ensuring that the number of characters !! does not exceed MAX_WIDTH and that the lines after the first !! one are indented four characters.         class(logger_type), intent(in)             :: self         character(*), intent(in)                   :: string         character(*), intent(in)                   :: col_indent         integer, intent(out)                       :: len_buffer         character(len=:), allocatable, intent(out) :: buffer          integer :: count, indent_len, index_, length, remain         integer, parameter :: new_len = len(new_line('a'))          length = len_trim(string)         allocate( character(2*length) :: buffer )         len_buffer = 0         indent_len = len(col_indent)         call format_first_line()          if ( self % indent_lines ) then             do while( remain > 0 )                 call indent_format_subsequent_line()             end do         else             do while( remain > 0 )                 call format_subsequent_line()             end do         end if      contains          subroutine format_first_line()              if ( self % max_width == 0 .or.                     &                 ( length <= self % max_width .and.              &                 index( string(1:length), new_line('a')) == 0 ) ) then                 buffer(1:length) = string(1:length)                 len_buffer = length                 remain = 0                 return             else                  index_ = index( string(1:min(length, self % max_width)), &                                 new_line('a') )                 if ( index_ == 0 ) then                     do index_=self % max_width, 1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == 0 ) then                     buffer(1:self % max_width) = &                         string(1:self % max_width)                     len_buffer = self % max_width                     count = self % max_width                     remain = length - count                     return                 else                     buffer(1:index_-1) = string(1:index_-1)                     len_buffer = index_-1                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine format_first_line          subroutine format_subsequent_line()             integer :: new_len_buffer             character(:), allocatable :: dummy              if ( remain <= self % max_width ) then                 new_len_buffer = len_buffer + length - count + new_len                 if ( new_len_buffer > len( buffer ) ) then                     allocate( character( 2*len( buffer ) ) :: dummy )                     dummy = buffer                     call move_alloc( dummy, buffer )                 end if                 buffer( len_buffer+1:new_len_buffer ) = &                     new_line('a') // string(count+1:length)                 len_buffer = new_len_buffer                 count = length                 remain = 0                 return             else                  index_ = count + index(string(count+1:count+self % max_width),&                     new_line('a'))                 if(index_ == count) then                     do index_=count+self % max_width, count+1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == count ) then                     new_len_buffer = len_buffer + self % max_width + &                         new_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1:new_len_buffer ) = &                         new_line('a') // string(count+1:count+self % max_width)                     len_buffer = new_len_buffer                     count = count + self % max_width                     remain = length - count                     return                 else                     new_len_buffer = len_buffer + index_ - 1 &                         - count + new_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1:new_len_buffer ) = &                         new_line('a') // string(count+1:index_-1)                     len_buffer = new_len_buffer                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine format_subsequent_line          subroutine indent_format_subsequent_line()             integer :: new_len_buffer             character(:), allocatable :: dummy              if ( index( string(count+1:length), new_line('a')) == 0 .and. &                 remain <= self % max_width - indent_len ) then                 new_len_buffer = len_buffer + length &                     - count + new_len + indent_len                 if ( new_len_buffer > len( buffer ) ) then                     allocate( character( 2*len( buffer ) ) :: dummy )                     dummy = buffer                     call move_alloc( dummy, buffer )                 end if                 buffer( len_buffer+1:new_len_buffer ) = &                     new_line('a') // col_indent // string(count+1:length)                 len_buffer = new_len_buffer                 count = length                 remain = 0                 return             else                  index_ = count + index( string(count+1:                   &                     min ( length, count+self % max_width - indent_len) ), &                     new_line('a'))                 if(index_ == count) then                     do index_=count+self % max_width-indent_len, count+1, -1                         if ( string(index_:index_) == ' ' ) exit                     end do                 end if                  if ( index_ == count ) then                     new_len_buffer = len_buffer + self % max_width &                         + new_len                      if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1: new_len_buffer ) = &                         new_line('a') // col_indent // &                         string(count+1:count+self % max_width-indent_len)                     len_buffer = new_len_buffer                     count = count + self % max_width - indent_len                     remain = length - count                     return                 else                     new_len_buffer = len_buffer + index_ - count - 1 &                         + new_len + indent_len                     if ( new_len_buffer > len( buffer ) ) then                         allocate( character( 2*len( buffer ) ) :: dummy )                         dummy = buffer                         call move_alloc( dummy, buffer )                     end if                     buffer( len_buffer+1: new_len_buffer ) = &                         new_line('a') // col_indent // string(count+1:index_-1)                     len_buffer = new_len_buffer                     count = index_                     remain = length - count                     return                 end if              end if          end subroutine indent_format_subsequent_line      end subroutine format_output_string       subroutine handle_write_failure( unit, procedure_name, iostat, iomsg ) !! version: experimental  !! Handles a failure to write to `unit` in `procedure_name` with `iostat` and !! `iomsg` by writing a description of the failure to `output_unit` and !! stopping.         integer, intent(in)      :: unit         character(*), intent(in) :: procedure_name         integer, intent(in)      :: iostat         character(*), intent(in) :: iomsg          character(256) :: name         logical :: named         character(10) :: action           write( output_unit, '(a)' ) 'write failure in ' // module_name // &              ' % ' // trim(procedure_name) // '.'          if ( unit == -999 ) then              write( output_unit, '(a, i0)' ) 'unit = internal file'          else              write( output_unit, '(a, i0)' ) 'unit = ', unit              inquire( unit, named=named )               if ( named ) then                  inquire( unit, name=name )                  write( output_unit, '(a, a)' ) 'name = ', trim(name)              else                  write( output_unit, '(a)' ) 'unit is unnamed'              end if              inquire( unit, action=action )              write( output_unit, '(a, a)' ) 'action = ', trim(action)          end if           write( output_unit, '(a, i0)' ) 'iostat = ', iostat          write( output_unit, '(a, a )' ) 'iomsg = ', trim(iomsg)          error stop 'write failure in ' // module_name // '.'       end subroutine handle_write_failure       subroutine log_debug( self, message, module, procedure ) !! version: experimental  !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_debug-writes-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, and then `message` is !! written with the prefix 'DEBUG: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( selection ) !!         integer, intent(out) :: selection !!         integer        :: stat !!         write(*,'(a)') "Enter an integer to select a widget" !!         read(*,'(i0)') selection !!         write( message, `(a, i0)' )           & !!               "The user selected ", selection !!         call alogger % log_debug( message,                   & !!                                   module = 'EXAMPLE_MOD',    & !!                                   procedure = 'EXAMPLE_SUB' ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod !!          class(logger_type), intent(in)          :: self !! The logger used to send the message         character(len=*), intent(in)            :: message !! A string to be written to log_unit         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of `log_information`         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of !! `log_information`          if ( self % level > debug_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = 'DEBUG' )      end subroutine log_debug       subroutine log_error( self, message, module, procedure, stat, errmsg ) !! version: experimental  !! Writes the string `message` to `self % log_units` with optional additional !! text. !! ([Specification](../specs/stdlib_logger.html#log_error-writes-the-string-message-to-self-log_units))  !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'ERROR: ', and then if `stat` or `errmsg` !! are present they are written. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size ) !!         integer, intent(in) :: size !!         character(128) :: errmsg, message !!         integer        :: stat !!         allocate( a(size), stat=stat, errmsg=errmsg ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               "Allocation of A failed with SIZE = ", size !!           alogger % call log_error( message,                   & !!                                     module = 'EXAMPLE_MOD',    & !!                                     procedure = 'EXAMPLE_SUB', & !!                                     stat = stat,               & !!                                     errmsg = errmsg ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !!          class(logger_type), intent(in)          :: self !! The logger to be used in logging the message         character(len=*), intent(in)            :: message !! A string to be written to log_unit         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of `log_error`         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of `log_error`         integer, intent(in), optional           :: stat !! The value of the `stat` specifier returned by a Fortran statement         character(len=*), intent(in), optional  :: errmsg !! The value of the `errmsg` specifier returned by a Fortran statement          integer :: iostat         character(28) :: dummy         character(256) :: iomsg         character(*), parameter :: procedure_name = 'log_error'         character(:), allocatable :: suffix          if ( self % level > error_level ) return          if ( present(stat) ) then             write( dummy, '(a, i0)', err=999, iostat=iostat, iomsg=iomsg ) &                 new_line('a') // "With stat = ", stat         else             dummy = ' '         end if          if ( present(errmsg) ) then             if ( len_trim(errmsg) > 0 ) then                 suffix = trim(dummy) // &                     new_line('a') // 'With errmsg = "' // trim(errmsg) // '"'             else                 suffix = dummy             end if         else             suffix = dummy         end if          call self % log_message( trim(message) // suffix, &                                  module = module,         &                                  procedure = procedure,   &                                  prefix = 'ERROR')          return  999     call handle_write_failure( -999, procedure_name, iostat, iomsg )      end subroutine log_error       subroutine log_information( self, message, module, procedure ) !! version: experimental  !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_information-writes-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, and then `message` is !! written with the prefix 'INFO: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( selection ) !!         integer, intent(out) :: selection !!         integer        :: stat !!         write(*,'(a)') "Enter an integer to select a widget" !!         read(*,'(i0)') selection !!         write( message, `(a, i0)' )           & !!               "The user selected ", selection !!         call alogger % log_information( message,                   & !!                                         module = 'EXAMPLE_MOD',    & !!                                         procedure = 'EXAMPLE_SUB' ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod !!          class(logger_type), intent(in)          :: self !! The logger used to send the message         character(len=*), intent(in)            :: message !! A string to be written to log_unit         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of `log_information`         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of !! `log_information`          if ( self % level > information_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = 'INFO' )      end subroutine log_information       subroutine log_io_error( self, message, module, procedure, iostat, &                              iomsg ) !! version: experimental  !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_io_error-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with a prefix 'I/O ERROR: ', and then if `iostat` or `iomsg` !! are present they are also written. !! !!##### Example !! !!    program example !!      use stdlib_logger !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: iostat, lun !!      character(128)          :: iomsg !!      character(*), parameter :: message = 'Failure in opening "dummy.txt".' !! !!      open( newunit=lun, file = filename, form='formatted', & !!            status='old', iostat=iostat, iomsg=iomsg ) !!      if ( iostat /= 0 ) then !!        call global_logger % log_io_error( message, procedure = 'EXAMPLE', & !!            iostat=iostat, iomsg = iomsg ) !!        error stop 'Error on opening ' // filename !!      end if !!      ... !!    end program example          class(logger_type), intent(in)          :: self !! The logger variable to receivee the message         character(len=*), intent(in)            :: message !! A string to be written to LOG_UNIT         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of REPORT_ERROR         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of REPORT_ERROR         integer, intent(in), optional           :: iostat !! The value of the IOSTAT specifier returned by a Fortran I/O statement         character(len=*), intent(in), optional  :: iomsg !! The value of the IOMSG specifier returned by a Fortran I/O statement          character(28) :: dummy         character(256) :: iomsg2         integer :: iostat2         character(*), parameter :: procedure_name = 'log_io_error'         character(:), allocatable :: suffix          if ( self % level > io_error_level ) return          if ( present(iostat) ) then             write( dummy, '(a, i0)', err=999, iostat=iostat2, iomsg=iomsg2 ) &                 new_line('a') // "With iostat = ", iostat         else             dummy = ' '         end if          if ( present(iomsg) ) then             if ( len_trim(iomsg) > 0 ) then                 suffix = trim(dummy) // &                     new_line('a') // 'With iomsg = "' // trim(iomsg) // '"'             else                 suffix = trim(dummy)             end if         else             suffix = trim(dummy)         end if          call self % log_message( trim(message) // suffix, &                                  module = module,         &                                  procedure = procedure,   &                                  prefix = 'I/O ERROR' )          return  999     call handle_write_failure( -999, procedure_name, iostat2, iomsg2 )      end subroutine log_io_error      subroutine log_message( self, message, module, procedure, prefix ) !! version: experimental  !! Writes the string `message` to the `self % log_units` with optional !! additional text. !!([Specification](../page/specs/stdlib_logger.html#log_message-write-the-string-message-to-self-log_units)) !! !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by `module` !! and `procedure` if present, followed by `prefix // ': '` if present, !! and then `message`. !! !!##### Example !! !!    module  example_mod !!      use stdlib_logger !!      ... !!      real, allocatable :: a(:) !!      ... !!    contains !!      ... !!      subroutine example_sub( selection ) !!        integer, intent(out) :: selection !!        integer        :: stat !!        write(*,'(a)') "Enter an integer to select a widget" !!        read(*,'(i0)') selection !!        write( message, `(a, i0)' )          & !!              "The user selected ", selection !!        call global_logger % log_message( message,                   & !!                                          module = 'example_mod',    & !!                                          procedure = 'example_sub', & !!                                          prefix = 'info' ) !!      end subroutine example_sub !!      ... !!    end module example_mod !!          class(logger_type), intent(in)          :: self !! The logger variable to receive the message         character(len=*), intent(in)            :: message !! A string to be written to log_unit         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of `log_message`         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of `log_message`         character(len=*), intent(in), optional  :: prefix !! To be prepended to message as `prefix // ': ' // message`.          integer :: unit         integer :: iostat         integer :: len_buffer         character(*), parameter :: procedure_name = 'log_message'         character(256) :: iomsg         character(:), allocatable :: d_and_t, m_and_p, pref         character(:), allocatable :: buffer          pref = optval(prefix, '')         if ( len(pref) > 0 ) pref = pref // ': '          if ( self % time_stamp ) then             d_and_t = time_stamp() // ': '         else             d_and_t = ''         end if          if ( present(module) ) then             if ( present(procedure) ) then                 m_and_p = trim(module) // ' % ' // trim(procedure) // ': '             else                 m_and_p = trim(module) // ': '             end if         else if ( present(procedure) ) then             m_and_p = trim(procedure) // ': '         else             m_and_p = ''         end if          call format_output_string( self,                         &                                    d_and_t // m_and_p // pref // &                                    trim( message ),              &                                    '    ',                       &                                    len_buffer,                   &                                    buffer)          if ( self % units == 0 ) then             if ( self % add_blank_line ) then                 write( output_unit, '(a)', err=999, iostat=iostat, &                         iomsg=iomsg) &                     new_line('a') // buffer(1:len_buffer)             else                 write( output_unit, '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) &                     buffer(1:len_buffer)             end if         else             if ( self % add_blank_line ) then                 do unit=1, self % units                     write( self % log_units(unit), '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) new_line('a') // &                         buffer(1:len_buffer)                 end do             else                 do unit=1, self % units                     write( self % log_units(unit), '(a)', err=999, iostat=iostat, &                         iomsg=iomsg ) &                         buffer(1:len_buffer)                 end do             end if         end if           return  999     call handle_write_failure( unit, procedure_name, iostat, iomsg )      end subroutine log_message      subroutine log_text_error( self, line, column, summary, filename,  &                                line_number, caret, stat ) !! version: experimental  !! Sends a message to `self % log_units` describing an error found !! in a line of text. !!([Specification](../page/specs/stdlib_logger.html#log_text_error-send-a-message-to-self-log_units-describing-an-error))  !!##### Behavior !! !! If time stamps are active first a time stamp is written. Then if !! `filename` or `line_number` or `column` are present they are written. !! Then `line` is written. Then the symbol `caret` is written below `line` !! at the column indicated by `column`. Then `summary` is written. ! !!##### Example !! !!    program example !!      ... !!      character(*), parameter :: filename = 'dummy.txt' !!      integer                 :: col_num, line_num, lun !!      character(128)          :: line !!      character(*), parameter :: message = 'Bad text found.' !! !!      open( newunit=lun, file = filename, statu='old', form='formatted' ) !!      line_num = 0 !!      do !!        read( lun, fmt='(a)', end=900 ) line !!        line_num = line_num + 1 !!        call check_line( line, status, col_num ) !!        if ( status /= 0 ) !!          call global_logger % log_text_error( line, col_num, message, & !!                                               filename, line_num ) !!          error stop 'Error in reading ' // filename !!        end if !!        ... !!      end do !!900   continue !!      ... !!    end program example !!         class(logger_type), intent(in)        :: self !! The logger variable to receive the message         character(*), intent(in)              :: line !! The line of text in which the error was found.         integer, intent(in)                   :: column !! The one's based column in LINE at which the error starts.         character(*), intent(in)              :: summary !! A brief description of the error.         character(*), intent(in), optional    :: filename !! The name of the file, if any, in which the error was found.         integer, intent(in), optional         :: line_number !! The one's based line number in the file where `line` was found.         character(1), intent(in), optional    :: caret !! The symbol used to mark the column wher the error was first detected         integer, intent(out), optional        :: stat !! Integer flag that an error has occurred. Has the value `success` if no !! error hass occurred, `index_invalid_error` if `column` is less than zero or !! greater than `len(line)`, and `write_failure` if any of the `write` !! statements has failed.          character(1)                  :: acaret         character(128)                :: iomsg         integer                       :: iostat         integer                       :: lun         character(*), parameter       :: procedure_name = 'LOG_TEXT_ERROR'         character(len=:), allocatable :: buffer          if ( self % level > text_error_level ) return          acaret = optval(caret, '^')          if ( column < 0 .or. column > len( line ) + 1 ) then             if ( present(stat) ) then                 stat = index_invalid_error                 return             else                 call self % log_error( invalid_column,           &                                        module = module_name,     &                                        procedure = procedure_name )                 error stop module_name // ' % ' // procedure_name // ': ' // &                     invalid_column             end if         end if          call write_log_text_error_buffer( )         if ( self % units == 0 ) then             write( output_unit, '(a)' ) buffer         else             do lun=1, self % units                 write( self % log_units(lun), '(a)' ) buffer             end do         end if      contains          subroutine write_log_text_error_buffer( )             integer                   :: i             character(:), allocatable :: location, marker              if ( present(filename) ) then                 if ( present(line_number) ) then                     allocate( character(len_trim(filename)+15) :: location )                     write( location, fmt='(a, ":", i0, ":", i0)', err=999, &                            iomsg=iomsg, iostat=iostat )           &                            trim(filename) , line_number, column                 else                     allocate( character(len_trim(filename)+45) :: location )                     write( location, fmt='(a, i0)', err=999, iomsg=iomsg, &                            iostat=iostat ) &                            "Error found in file: '" // trim(filename) // &                            "', at column: ", column                 end if              else                 if ( present(line_number) ) then                     allocate( character(54) :: location )                     write( location, fmt='(a, i0, a, i0)', err=999, &                            iomsg=iomsg, iostat=iostat ) &                         'Error found at line number: ', line_number, &                         ', and column: ', column                 else                     allocate( character(36) :: location )                     write( location, &                            fmt='("Error found in line at column:", i0)' ) &                         column                 end if             end if              allocate( character(column) :: marker )             do i=1, column-1                 marker(i:i) = ' '             end do             marker(column:column) = acaret             if ( self % add_blank_line ) then                 if ( self % time_stamp ) then                     buffer = new_line('a') // time_stamp() // &                         new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 else                     buffer = new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 end if             else                 if ( self % time_stamp ) then                     buffer = time_stamp() // &                         new_line('a') // trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 else                     buffer = trim(location) // &                         new_line('a') // new_line('a') // trim(line) // &                         new_line('a') // marker // &                         new_line('a') // 'Error: ' // trim(summary)                 end if             end if              if ( present(stat) ) stat = success              return  999         if ( present( stat ) ) then                 stat = write_failure                 return             else                 call handle_write_failure( -999, procedure_name, iostat, &                                            iomsg )             end if          end subroutine write_log_text_error_buffer      end subroutine log_text_error       elemental function log_units_assigned(self) !! version: experimental  !! Returns the number of units assigned to `self % log_units` !!([Specification](../page/specs/stdlib_logger.html#log_units_assigned-returns-the-number-of-active-io-units))          class(logger_type), intent(in) :: self !! The logger subject to the inquiry         integer                        :: log_units_assigned !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         integer, allocatable :: log_units(:) !!         ... !!         if ( alogger % log_units_assigned() == 0 ) then !!            call alogger % add_log_unit( unit ) !!         end if !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod          log_units_assigned = self % units      end function log_units_assigned       subroutine log_warning( self, message, module, procedure ) !! version: experimental  !! Writes the string `message` to `self % log_units` with optional additional !! text. !!([Specification](../page/specs/stdlib_logger.html#log_warning-write-the-string-message-to-log_units))  !!##### Behavior !! !! If time stamps are active, a time stamp is written, followed by !! `module` and `procedure` if present, then `message` is !! written with the prefix 'WARN: '. !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       real, allocatable :: a(:) !!       ... !!       type(logger_type) :: alogger !!       ... !!     contains !!       ... !!       subroutine example_sub( size, stat ) !!         integer, intent(in)  :: size !!         integer, intent(out) :: stat !!         allocate( a(size) ) !!         if ( stat /= 0 ) then !!           write( message, `(a, i0)' )                    & !!               "Allocation of A failed with SIZE = ", size !!           call alogger % log_warning( message,                   & !!                                       module = 'EXAMPLE_MOD',    & !!                                       procedure = 'EXAMPLE_SUB' ) !!         end if !!       end subroutine example_sub !!       ... !!     end module example_mod !!         class(logger_type), intent(in)          :: self !! The logger to which the message is written         character(len=*), intent(in)            :: message !! A string to be written to LOG_UNIT         character(len=*), intent(in), optional  :: module !! The name of the module containing the current invocation of `log_warning`         character(len=*), intent(in), optional  :: procedure !! The name of the procedure containing the current invocation of `log_warning`          if ( self % level > warning_level ) return          call self % log_message( message,               &                                  module = module,       &                                  procedure = procedure, &                                  prefix = 'WARN' )      end subroutine log_warning       subroutine remove_log_unit( self, unit, close_unit, stat ) !! version: experimental  !! Remove the I/O unit from the self % log_units list. If `close_unit` is !! present and `.true.` then the corresponding file is closed. If `unit` is !! not in `log_units` then nothing is done. If `stat` is present it, by !! default, has the value `success`. If closing the `unit` fails, then if !! `stat` is present it has the value `close_failure`, otherwise processing !! stops with an informative message. !!([Specification](../page/specs/stdlib_logger.html#remove_log_unit-remove-unit-from-self-log_units))          class(logger_type), intent(inout) :: self !! The logger variable whose unit is to be removed         integer, intent(in)               :: unit !! The I/O unit to be removed from self         logical, intent(in), optional     :: close_unit !! A logical flag to close the unit while removing it from the SELF list         integer, intent(out), optional    :: stat !! An error status with the values !! * success - no problems found !! * close_failure - the close statement for unit failed !! !!##### Example !! !!     module  example_mod !!       use stdlib_logger !!       ... !!       type(logger_type) ::  alogger !!     contains !!       ... !!       subroutine example_sub(unit, ...) !!         integer, intent(in) :: unit !!         ... !!         call alogger % remove_log_unit( unit ) !!         ... !!       end subroutine example_sub !!       ... !!     end module example_mod          character(128) :: errmsg         integer :: lun, lun_old         character(*), parameter :: procedure_name = 'REMOVE_LOG_UNIT'          if ( present(stat) ) stat = success         do lun=1, self % units             if ( unit == self % log_units(lun) ) exit         end do          if ( lun == self % units + 1 ) return          if ( present(close_unit) ) then             if ( close_unit ) close( unit, err=999, iomsg=errmsg )         end if          do lun_old=lun+1, self % units             self % log_units(lun_old-1) = self % log_units(lun_old)         end do         self % units = self % units - 1          return  999     if ( present(stat) ) then             stat = close_failure             return         else             write(*, '(a, i0)') 'In ' // module_name // ' % ' // &                 procedure_name // ' close_unit failed for unit = ', unit             write(*, '(a)' ) 'With iomsg = ' // trim(errmsg)             error stop 'close_unit failed in ' // module_name // ' % ' // &                 procedure_name // '.'         end if      end subroutine remove_log_unit       function time_stamp() !! Creates a time stamp in the format 'yyyy-mm-dd hh:mm:ss.sss'         character(23) :: time_stamp         character(8)  :: date         character(10) :: time          call date_and_time( date, time )          time_stamp(1:4)   = date(1:4)         time_stamp(5:5)   = '-'         time_stamp(6:7)   = date(5:6)         time_stamp(8:8)   = '-'         time_stamp(9:10)  = date(7:8)         time_stamp(11:11) = ' '         time_stamp(12:13) = time(1:2)         time_stamp(14:14) = ':'         time_stamp(15:16) = time(3:4)         time_stamp(17:17) = ':'         time_stamp(18:23) = time(5:10)      end function time_stamp  end module stdlib_logger 
stdlib_quadrature_gauss.f90_stripped submodule (stdlib_quadrature) stdlib_quadrature_gauss     use stdlib_specialfunctions, only: legendre, dlegendre     implicit none      real(dp), parameter :: pi = acos(-1._dp)     real(dp), parameter :: tolerance = 4._dp * epsilon(1._dp)     integer, parameter :: newton_iters = 100  contains      pure module subroutine gauss_legendre_fp64 (x, w, interval)         real(dp), intent(out) :: x(:), w(:)         real(dp), intent(in), optional :: interval(2)          associate (n => size(x)-1 )         select case (n)             case (0)                 x = 0                 w = 2             case (1)                 x(1) = -sqrt(1._dp/3._dp)                 x(2) = -x(1)                 w = 1             case default                 block                 integer :: i,j                 real(dp) :: leg, dleg, delta                  do i = 0, (n+1)/2 - 1                                          x(i+1) = -cos((2*i+1)/(2._dp*n+2._dp) * pi)                     do j = 1, newton_iters                         leg  = legendre(n+1,x(i+1))                         dleg = dlegendre(n+1,x(i+1))                         delta = -leg/dleg                         x(i+1) = x(i+1) + delta                         if ( abs(delta) <= tolerance * abs(x(i+1)) )  exit                     end do                     x(n-i+1) = -x(i+1)                      dleg = dlegendre(n+1,x(i+1))                     w(i+1)   = 2._dp/((1-x(i+1)**2)*dleg**2)                      w(n-i+1) = w(i+1)                 end do                  if (mod(n,2) == 0) then                     x(n/2+1) = 0                      dleg = dlegendre(n+1, 0.0_dp)                     w(n/2+1) = 2._dp/(dleg**2)                  end if                 end block         end select         end associate          if (present(interval)) then             associate ( a => interval(1) , b => interval(2) )             x = 0.5_dp*(b-a)*x+0.5_dp*(b+a)             w = 0.5_dp*(b-a)*w             end associate         end if     end subroutine      pure module subroutine gauss_legendre_lobatto_fp64 (x, w, interval)         real(dp), intent(out) :: x(:), w(:)         real(dp), intent(in), optional :: interval(2)          associate (n => size(x)-1)         select case (n)             case (1)                 x(1) = -1                 x(2) =  1                 w = 1             case default                 block                 integer :: i,j                 real(dp) :: leg, dleg, delta                  x(1)   = -1._dp                 x(n+1) =  1._dp                 w(1)   =  2._dp/(n*(n+1._dp))                 w(n+1) =  2._dp/(n*(n+1._dp))                  do i = 1, (n+1)/2 - 1                                          x(i+1) = -cos( (i+0.25_dp)*pi/n  - 3/(8*n*pi*(i+0.25_dp)))                     do j = 1, newton_iters                         leg  = legendre(n+1,x(i+1)) - legendre(n-1,x(i+1))                         dleg = dlegendre(n+1,x(i+1)) - dlegendre(n-1,x(i+1))                         delta = -leg/dleg                         x(i+1) = x(i+1) + delta                         if ( abs(delta) <= tolerance * abs(x(i+1)) )  exit                     end do                     x(n-i+1) = -x(i+1)                      leg = legendre(n, x(i+1))                     w(i+1)   = 2._dp/(n*(n+1._dp)*leg**2)                      w(n-i+1) = w(i+1)                 end do                  if (mod(n,2) == 0) then                     x(n/2+1) = 0                      leg = legendre(n, 0.0_dp)                     w(n/2+1)   = 2._dp/(n*(n+1._dp)*leg**2)                  end if                 end block         end select         end associate                  if (present(interval)) then             associate ( a => interval(1) , b => interval(2) )             x = 0.5_dp*(b-a)*x+0.5_dp*(b+a)             x(1)       = interval(1)             x(size(x)) = interval(2)             w = 0.5_dp*(b-a)*w             end associate         end if     end subroutine end submodule     
stdlib_quadrature_gauss.f90_comments submodule (stdlib_quadrature) stdlib_quadrature_gauss     use stdlib_specialfunctions, only: legendre, dlegendre     implicit none      real(dp), parameter :: pi = acos(-1._dp)     real(dp), parameter :: tolerance = 4._dp * epsilon(1._dp)     integer, parameter :: newton_iters = 100  contains      pure module subroutine gauss_legendre_fp64 (x, w, interval)         real(dp), intent(out) :: x(:), w(:)         real(dp), intent(in), optional :: interval(2)          associate (n => size(x)-1 )         select case (n)             case (0)                 x = 0                 w = 2             case (1)                 x(1) = -sqrt(1._dp/3._dp)                 x(2) = -x(1)                 w = 1             case default                 block                 integer :: i,j                 real(dp) :: leg, dleg, delta                  do i = 0, (n+1)/2 - 1                     ! use Gauss-Chebyshev points as an initial guess                     x(i+1) = -cos((2*i+1)/(2._dp*n+2._dp) * pi)                     do j = 1, newton_iters                         leg  = legendre(n+1,x(i+1))                         dleg = dlegendre(n+1,x(i+1))                         delta = -leg/dleg                         x(i+1) = x(i+1) + delta                         if ( abs(delta) <= tolerance * abs(x(i+1)) )  exit                     end do                     x(n-i+1) = -x(i+1)                      dleg = dlegendre(n+1,x(i+1))                     w(i+1)   = 2._dp/((1-x(i+1)**2)*dleg**2)                      w(n-i+1) = w(i+1)                 end do                  if (mod(n,2) == 0) then                     x(n/2+1) = 0                      dleg = dlegendre(n+1, 0.0_dp)                     w(n/2+1) = 2._dp/(dleg**2)                  end if                 end block         end select         end associate          if (present(interval)) then             associate ( a => interval(1) , b => interval(2) )             x = 0.5_dp*(b-a)*x+0.5_dp*(b+a)             w = 0.5_dp*(b-a)*w             end associate         end if     end subroutine      pure module subroutine gauss_legendre_lobatto_fp64 (x, w, interval)         real(dp), intent(out) :: x(:), w(:)         real(dp), intent(in), optional :: interval(2)          associate (n => size(x)-1)         select case (n)             case (1)                 x(1) = -1                 x(2) =  1                 w = 1             case default                 block                 integer :: i,j                 real(dp) :: leg, dleg, delta                  x(1)   = -1._dp                 x(n+1) =  1._dp                 w(1)   =  2._dp/(n*(n+1._dp))                 w(n+1) =  2._dp/(n*(n+1._dp))                  do i = 1, (n+1)/2 - 1                     ! initial guess from an approximate form given by SV Parter (1999)                     x(i+1) = -cos( (i+0.25_dp)*pi/n  - 3/(8*n*pi*(i+0.25_dp)))                     do j = 1, newton_iters                         leg  = legendre(n+1,x(i+1)) - legendre(n-1,x(i+1))                         dleg = dlegendre(n+1,x(i+1)) - dlegendre(n-1,x(i+1))                         delta = -leg/dleg                         x(i+1) = x(i+1) + delta                         if ( abs(delta) <= tolerance * abs(x(i+1)) )  exit                     end do                     x(n-i+1) = -x(i+1)                      leg = legendre(n, x(i+1))                     w(i+1)   = 2._dp/(n*(n+1._dp)*leg**2)                      w(n-i+1) = w(i+1)                 end do                  if (mod(n,2) == 0) then                     x(n/2+1) = 0                      leg = legendre(n, 0.0_dp)                     w(n/2+1)   = 2._dp/(n*(n+1._dp)*leg**2)                  end if                 end block         end select         end associate                  if (present(interval)) then             associate ( a => interval(1) , b => interval(2) )             x = 0.5_dp*(b-a)*x+0.5_dp*(b+a)             x(1)       = interval(1)             x(size(x)) = interval(2)             w = 0.5_dp*(b-a)*w             end associate         end if     end subroutine end submodule     
stdlib_sorting_radix_sort.f90_stripped submodule(stdlib_sorting) stdlib_sorting_radix_sort     implicit none      integer, parameter :: radix_bits = 8     integer, parameter :: radix_mask = 255     integer(kind=int16), parameter :: radix_bits_i16 = 8_int16     integer(kind=int16), parameter :: radix_mask_i16 = 255_int16     integer(kind=int32), parameter :: radix_bits_i32 = 8_int32     integer(kind=int32), parameter :: radix_mask_i32 = 255_int32     integer(kind=int64), parameter :: radix_bits_i64 = 8_int64     integer(kind=int64), parameter :: radix_mask_i64 = 255_int64  contains      pure subroutine radix_sort_u8_helper(N, arr)         integer(kind=int_size), intent(in) :: N         integer(kind=int8), dimension(N), intent(inout) :: arr         integer(kind=int_size) :: i         integer :: bin_idx         integer(kind=int_size), dimension(-128:127) :: counts         counts(:) = 0         do i = 1, N             bin_idx = arr(i)             counts(bin_idx) = counts(bin_idx) + 1         end do         i = 1         do bin_idx = -128, 127             do while (counts(bin_idx) > 0)                 arr(i) = int(bin_idx, kind=int8)                 i = i + 1                 counts(bin_idx) = counts(bin_idx) - 1             end do         end do     end subroutine      pure subroutine radix_sort_u16_helper(N, arr, buf)         integer(kind=int_size), intent(in) :: N         integer(kind=int16), dimension(N), intent(inout) :: arr         integer(kind=int16), dimension(N), intent(inout) :: buf         integer(kind=int_size) :: i         integer :: b, b0, b1         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1         c0(:) = 0         c1(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i16)             b1 = ishft(arr(i), -radix_bits_i16)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i16)             buf(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = ishft(buf(i), -radix_bits_i16)             arr(c1(b1)) = buf(i)             c1(b1) = c1(b1) - 1         end do     end subroutine      pure subroutine radix_sort_u32_helper(N, arr, buf)         integer(kind=int_size), intent(in) :: N         integer(kind=int32), dimension(N), intent(inout) :: arr         integer(kind=int32), dimension(N), intent(inout) :: buf         integer(kind=int_size) :: i         integer :: b, b0, b1, b2, b3         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1, c2, c3         c0(:) = 0         c1(:) = 0         c2(:) = 0         c3(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i32)             b1 = iand(ishft(arr(i), -radix_bits_i32), radix_mask_i32)             b2 = iand(ishft(arr(i), -2*radix_bits_i32), radix_mask_i32)             b3 = ishft(arr(i), -3*radix_bits_i32)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1             c2(b2) = c2(b2) + 1             c3(b3) = c3(b3) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)             c2(b) = c2(b) + c2(b - 1)             c3(b) = c3(b) + c3(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i32)             buf(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = iand(ishft(buf(i), -radix_bits_i32), radix_mask_i32)             arr(c1(b1)) = buf(i)             c1(b1) = c1(b1) - 1         end do         do i = N, 1, -1             b2 = iand(ishft(arr(i), -2*radix_bits_i32), radix_mask_i32)             buf(c2(b2)) = arr(i)             c2(b2) = c2(b2) - 1         end do         do i = N, 1, -1             b3 = ishft(buf(i), -3*radix_bits_i32)             arr(c3(b3)) = buf(i)             c3(b3) = c3(b3) - 1         end do     end subroutine radix_sort_u32_helper      pure subroutine radix_sort_u64_helper(N, arr, buffer)         integer(kind=int_size), intent(in) :: N         integer(kind=int64), dimension(N), intent(inout) :: arr         integer(kind=int64), dimension(N), intent(inout) :: buffer         integer(kind=int_size) :: i         integer(kind=int64) :: b, b0, b1, b2, b3, b4, b5, b6, b7         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1, c2, c3, c4, c5, c6, c7         c0(:) = 0         c1(:) = 0         c2(:) = 0         c3(:) = 0         c4(:) = 0         c5(:) = 0         c6(:) = 0         c7(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i64)             b1 = iand(ishft(arr(i), -radix_bits_i64), radix_mask_i64)             b2 = iand(ishft(arr(i), -2*radix_bits_i64), radix_mask_i64)             b3 = iand(ishft(arr(i), -3*radix_bits_i64), radix_mask_i64)             b4 = iand(ishft(arr(i), -4*radix_bits_i64), radix_mask_i64)             b5 = iand(ishft(arr(i), -5*radix_bits_i64), radix_mask_i64)             b6 = iand(ishft(arr(i), -6*radix_bits_i64), radix_mask_i64)             b7 = ishft(arr(i), -7*radix_bits_i64)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1             c2(b2) = c2(b2) + 1             c3(b3) = c3(b3) + 1             c4(b4) = c4(b4) + 1             c5(b5) = c5(b5) + 1             c6(b6) = c6(b6) + 1             c7(b7) = c7(b7) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)             c2(b) = c2(b) + c2(b - 1)             c3(b) = c3(b) + c3(b - 1)             c4(b) = c4(b) + c4(b - 1)             c5(b) = c5(b) + c5(b - 1)             c6(b) = c6(b) + c6(b - 1)             c7(b) = c7(b) + c7(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i64)             buffer(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = iand(ishft(buffer(i), -radix_bits_i64), radix_mask_i64)             arr(c1(b1)) = buffer(i)             c1(b1) = c1(b1) - 1         end do         do i = N, 1, -1             b2 = iand(ishft(arr(i), -2*radix_bits_i64), radix_mask_i64)             buffer(c2(b2)) = arr(i)             c2(b2) = c2(b2) - 1         end do         do i = N, 1, -1             b3 = iand(ishft(buffer(i), -3*radix_bits_i64), radix_mask_i64)             arr(c3(b3)) = buffer(i)             c3(b3) = c3(b3) - 1         end do         do i = N, 1, -1             b4 = iand(ishft(arr(i), -4*radix_bits_i64), radix_mask_i64)             buffer(c4(b4)) = arr(i)             c4(b4) = c4(b4) - 1         end do         do i = N, 1, -1             b5 = iand(ishft(buffer(i), -5*radix_bits_i64), radix_mask_i64)             arr(c5(b5)) = buffer(i)             c5(b5) = c5(b5) - 1         end do         do i = N, 1, -1             b6 = iand(ishft(arr(i), -6*radix_bits_i64), radix_mask_i64)             buffer(c6(b6)) = arr(i)             c6(b6) = c6(b6) - 1         end do         do i = N, 1, -1             b7 = ishft(buffer(i), -7*radix_bits_i64)             arr(c7(b7)) = buffer(i)             c7(b7) = c7(b7) - 1         end do     end subroutine radix_sort_u64_helper      pure module subroutine int8_radix_sort(array, reverse)         integer(kind=int8), dimension(:), intent(inout) :: array         logical, intent(in), optional :: reverse         integer(kind=int8) :: item         integer(kind=int_size) :: i, N         N = size(array, kind=int_size)         call radix_sort_u8_helper(N, array)         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if     end subroutine int8_radix_sort      pure module subroutine int16_radix_sort(array, work, reverse)         integer(kind=int16), dimension(:), intent(inout) :: array         integer(kind=int16), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int16), dimension(:), pointer :: buffer         integer(kind=int16) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int16_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u16_helper(N, array, buffer)            if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int16_radix_sort      pure module subroutine int32_radix_sort(array, work, reverse)         integer(kind=int32), dimension(:), intent(inout) :: array         integer(kind=int32), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int32), dimension(:), pointer :: buffer         integer(kind=int32) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int32_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u32_helper(N, array, buffer)         if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int32_radix_sort      module subroutine sp_radix_sort(array, work, reverse)         use iso_c_binding         real(kind=sp), dimension(:), intent(inout), target :: array         real(kind=sp), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, pos, rev_pos         integer(kind=int32), dimension(:), pointer :: arri32         integer(kind=int32), dimension(:), pointer :: buffer         real(kind=sp) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "sp_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             call c_f_pointer(c_loc(work), buffer, [N])         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call c_f_pointer(c_loc(array), arri32, [N])         call radix_sort_u32_helper(N, arri32, buffer)                 if (arri32(1) >= 0 .and. arri32(N) < 0) then             pos = 1             rev_pos = N             do while (arri32(rev_pos) < 0)                 buffer(pos) = arri32(rev_pos)                 pos = pos + 1                 rev_pos = rev_pos - 1             end do             buffer(pos:N) = arri32(1:rev_pos)             arri32(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine sp_radix_sort      pure module subroutine int64_radix_sort(array, work, reverse)         integer(kind=int64), dimension(:), intent(inout) :: array         integer(kind=int64), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int64), dimension(:), pointer :: buffer         integer(kind=int64) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int64_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u64_helper(N, array, buffer)         if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int64_radix_sort      module subroutine dp_radix_sort(array, work, reverse)         use iso_c_binding         real(kind=dp), dimension(:), intent(inout), target :: array         real(kind=dp), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, pos, rev_pos         integer(kind=int64), dimension(:), pointer :: arri64         integer(kind=int64), dimension(:), pointer :: buffer         real(kind=dp) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "sp_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             call c_f_pointer(c_loc(work), buffer, [N])         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call c_f_pointer(c_loc(array), arri64, [N])         call radix_sort_u64_helper(N, arri64, buffer)         if (arri64(1) >= 0 .and. arri64(N) < 0) then             pos = 1             rev_pos = N             do while (arri64(rev_pos) < 0)                 buffer(pos) = arri64(rev_pos)                 pos = pos + 1                 rev_pos = rev_pos - 1             end do             buffer(pos:N) = arri64(1:rev_pos)             arri64(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine dp_radix_sort end submodule stdlib_sorting_radix_sort 
stdlib_sorting_radix_sort.f90_comments submodule(stdlib_sorting) stdlib_sorting_radix_sort     implicit none      integer, parameter :: radix_bits = 8     integer, parameter :: radix_mask = 255     integer(kind=int16), parameter :: radix_bits_i16 = 8_int16     integer(kind=int16), parameter :: radix_mask_i16 = 255_int16     integer(kind=int32), parameter :: radix_bits_i32 = 8_int32     integer(kind=int32), parameter :: radix_mask_i32 = 255_int32     integer(kind=int64), parameter :: radix_bits_i64 = 8_int64     integer(kind=int64), parameter :: radix_mask_i64 = 255_int64  contains ! For int8, radix sort becomes counting sort, so buffer is not needed     pure subroutine radix_sort_u8_helper(N, arr)         integer(kind=int_size), intent(in) :: N         integer(kind=int8), dimension(N), intent(inout) :: arr         integer(kind=int_size) :: i         integer :: bin_idx         integer(kind=int_size), dimension(-128:127) :: counts         counts(:) = 0         do i = 1, N             bin_idx = arr(i)             counts(bin_idx) = counts(bin_idx) + 1         end do         i = 1         do bin_idx = -128, 127             do while (counts(bin_idx) > 0)                 arr(i) = int(bin_idx, kind=int8)                 i = i + 1                 counts(bin_idx) = counts(bin_idx) - 1             end do         end do     end subroutine      pure subroutine radix_sort_u16_helper(N, arr, buf)         integer(kind=int_size), intent(in) :: N         integer(kind=int16), dimension(N), intent(inout) :: arr         integer(kind=int16), dimension(N), intent(inout) :: buf         integer(kind=int_size) :: i         integer :: b, b0, b1         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1         c0(:) = 0         c1(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i16)             b1 = ishft(arr(i), -radix_bits_i16)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i16)             buf(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = ishft(buf(i), -radix_bits_i16)             arr(c1(b1)) = buf(i)             c1(b1) = c1(b1) - 1         end do     end subroutine      pure subroutine radix_sort_u32_helper(N, arr, buf)         integer(kind=int_size), intent(in) :: N         integer(kind=int32), dimension(N), intent(inout) :: arr         integer(kind=int32), dimension(N), intent(inout) :: buf         integer(kind=int_size) :: i         integer :: b, b0, b1, b2, b3         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1, c2, c3         c0(:) = 0         c1(:) = 0         c2(:) = 0         c3(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i32)             b1 = iand(ishft(arr(i), -radix_bits_i32), radix_mask_i32)             b2 = iand(ishft(arr(i), -2*radix_bits_i32), radix_mask_i32)             b3 = ishft(arr(i), -3*radix_bits_i32)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1             c2(b2) = c2(b2) + 1             c3(b3) = c3(b3) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)             c2(b) = c2(b) + c2(b - 1)             c3(b) = c3(b) + c3(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i32)             buf(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = iand(ishft(buf(i), -radix_bits_i32), radix_mask_i32)             arr(c1(b1)) = buf(i)             c1(b1) = c1(b1) - 1         end do         do i = N, 1, -1             b2 = iand(ishft(arr(i), -2*radix_bits_i32), radix_mask_i32)             buf(c2(b2)) = arr(i)             c2(b2) = c2(b2) - 1         end do         do i = N, 1, -1             b3 = ishft(buf(i), -3*radix_bits_i32)             arr(c3(b3)) = buf(i)             c3(b3) = c3(b3) - 1         end do     end subroutine radix_sort_u32_helper      pure subroutine radix_sort_u64_helper(N, arr, buffer)         integer(kind=int_size), intent(in) :: N         integer(kind=int64), dimension(N), intent(inout) :: arr         integer(kind=int64), dimension(N), intent(inout) :: buffer         integer(kind=int_size) :: i         integer(kind=int64) :: b, b0, b1, b2, b3, b4, b5, b6, b7         integer(kind=int_size), dimension(0:radix_mask) :: c0, c1, c2, c3, c4, c5, c6, c7         c0(:) = 0         c1(:) = 0         c2(:) = 0         c3(:) = 0         c4(:) = 0         c5(:) = 0         c6(:) = 0         c7(:) = 0         do i = 1, N             b0 = iand(arr(i), radix_mask_i64)             b1 = iand(ishft(arr(i), -radix_bits_i64), radix_mask_i64)             b2 = iand(ishft(arr(i), -2*radix_bits_i64), radix_mask_i64)             b3 = iand(ishft(arr(i), -3*radix_bits_i64), radix_mask_i64)             b4 = iand(ishft(arr(i), -4*radix_bits_i64), radix_mask_i64)             b5 = iand(ishft(arr(i), -5*radix_bits_i64), radix_mask_i64)             b6 = iand(ishft(arr(i), -6*radix_bits_i64), radix_mask_i64)             b7 = ishft(arr(i), -7*radix_bits_i64)             c0(b0) = c0(b0) + 1             c1(b1) = c1(b1) + 1             c2(b2) = c2(b2) + 1             c3(b3) = c3(b3) + 1             c4(b4) = c4(b4) + 1             c5(b5) = c5(b5) + 1             c6(b6) = c6(b6) + 1             c7(b7) = c7(b7) + 1         end do         do b = 1, radix_mask             c0(b) = c0(b) + c0(b - 1)             c1(b) = c1(b) + c1(b - 1)             c2(b) = c2(b) + c2(b - 1)             c3(b) = c3(b) + c3(b - 1)             c4(b) = c4(b) + c4(b - 1)             c5(b) = c5(b) + c5(b - 1)             c6(b) = c6(b) + c6(b - 1)             c7(b) = c7(b) + c7(b - 1)         end do         do i = N, 1, -1             b0 = iand(arr(i), radix_mask_i64)             buffer(c0(b0)) = arr(i)             c0(b0) = c0(b0) - 1         end do         do i = N, 1, -1             b1 = iand(ishft(buffer(i), -radix_bits_i64), radix_mask_i64)             arr(c1(b1)) = buffer(i)             c1(b1) = c1(b1) - 1         end do         do i = N, 1, -1             b2 = iand(ishft(arr(i), -2*radix_bits_i64), radix_mask_i64)             buffer(c2(b2)) = arr(i)             c2(b2) = c2(b2) - 1         end do         do i = N, 1, -1             b3 = iand(ishft(buffer(i), -3*radix_bits_i64), radix_mask_i64)             arr(c3(b3)) = buffer(i)             c3(b3) = c3(b3) - 1         end do         do i = N, 1, -1             b4 = iand(ishft(arr(i), -4*radix_bits_i64), radix_mask_i64)             buffer(c4(b4)) = arr(i)             c4(b4) = c4(b4) - 1         end do         do i = N, 1, -1             b5 = iand(ishft(buffer(i), -5*radix_bits_i64), radix_mask_i64)             arr(c5(b5)) = buffer(i)             c5(b5) = c5(b5) - 1         end do         do i = N, 1, -1             b6 = iand(ishft(arr(i), -6*radix_bits_i64), radix_mask_i64)             buffer(c6(b6)) = arr(i)             c6(b6) = c6(b6) - 1         end do         do i = N, 1, -1             b7 = ishft(buffer(i), -7*radix_bits_i64)             arr(c7(b7)) = buffer(i)             c7(b7) = c7(b7) - 1         end do     end subroutine radix_sort_u64_helper      pure module subroutine int8_radix_sort(array, reverse)         integer(kind=int8), dimension(:), intent(inout) :: array         logical, intent(in), optional :: reverse         integer(kind=int8) :: item         integer(kind=int_size) :: i, N         N = size(array, kind=int_size)         call radix_sort_u8_helper(N, array)         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if     end subroutine int8_radix_sort      pure module subroutine int16_radix_sort(array, work, reverse)         integer(kind=int16), dimension(:), intent(inout) :: array         integer(kind=int16), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int16), dimension(:), pointer :: buffer         integer(kind=int16) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int16_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u16_helper(N, array, buffer) ! After calling `radix_sort_u<width>_helper. The array is sorted as unsigned integers. ! In the view of signed array, the negative numbers are sorted but in the tail of the array. ! Use binary search to find the boundary, and move them to correct position.         if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int16_radix_sort      pure module subroutine int32_radix_sort(array, work, reverse)         integer(kind=int32), dimension(:), intent(inout) :: array         integer(kind=int32), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int32), dimension(:), pointer :: buffer         integer(kind=int32) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int32_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u32_helper(N, array, buffer)         if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int32_radix_sort      module subroutine sp_radix_sort(array, work, reverse)         use iso_c_binding         real(kind=sp), dimension(:), intent(inout), target :: array         real(kind=sp), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, pos, rev_pos         integer(kind=int32), dimension(:), pointer :: arri32         integer(kind=int32), dimension(:), pointer :: buffer         real(kind=sp) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "sp_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             call c_f_pointer(c_loc(work), buffer, [N])         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call c_f_pointer(c_loc(array), arri32, [N])         call radix_sort_u32_helper(N, arri32, buffer) ! After calling `radix_sort_u<width>_helper. The array is sorted as unsigned integers. ! The positive real number is sorted, guaranteed by IEEE-754 standard. ! But the negative real number is sorted in a reversed order, and also in the tail of array. ! Remark that -0.0 is the minimum nagative integer, so using radix sort, -0.0 is naturally lesser than 0.0. ! In IEEE-754 standard, the bit representation of `Inf` is greater than all positive real numbers, ! and the `-Inf` is lesser than all negative real numbers. So the order of `Inf, -Inf` is ok. ! The bit representation of `NaN` may be positive or negative integers in different machine, ! thus if the array contains `NaN`, the result is undefined.         if (arri32(1) >= 0 .and. arri32(N) < 0) then             pos = 1             rev_pos = N             do while (arri32(rev_pos) < 0)                 buffer(pos) = arri32(rev_pos)                 pos = pos + 1                 rev_pos = rev_pos - 1             end do             buffer(pos:N) = arri32(1:rev_pos)             arri32(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine sp_radix_sort      pure module subroutine int64_radix_sort(array, work, reverse)         integer(kind=int64), dimension(:), intent(inout) :: array         integer(kind=int64), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, start, middle, end         integer(kind=int64), dimension(:), pointer :: buffer         integer(kind=int64) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "int64_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             buffer => work         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call radix_sort_u64_helper(N, array, buffer)         if (array(1) >= 0 .and. array(N) < 0) then             start = 1             end = N             middle = (1 + N)/2             do while (.true.)                 if (array(middle) >= 0) then                     start = middle + 1                 else                     end = middle                 end if                 middle = (start + end)/2                 if (start == end) exit             end do             buffer(1:(N - middle + 1)) = array(middle:N)             buffer(N - middle + 2:N) = array(1:middle - 1)             array(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine int64_radix_sort      module subroutine dp_radix_sort(array, work, reverse)         use iso_c_binding         real(kind=dp), dimension(:), intent(inout), target :: array         real(kind=dp), dimension(:), intent(inout), target, optional :: work         logical, intent(in), optional :: reverse         integer(kind=int_size) :: i, N, pos, rev_pos         integer(kind=int64), dimension(:), pointer :: arri64         integer(kind=int64), dimension(:), pointer :: buffer         real(kind=dp) :: item         logical :: use_internal_buffer         N = size(array, kind=int_size)         if (present(work)) then             if (size(work, kind=int_size) < N) then                 error stop "sp_radix_sort: work array is too small."             end if             use_internal_buffer = .false.             call c_f_pointer(c_loc(work), buffer, [N])         else             use_internal_buffer = .true.             allocate (buffer(N))         end if         call c_f_pointer(c_loc(array), arri64, [N])         call radix_sort_u64_helper(N, arri64, buffer)         if (arri64(1) >= 0 .and. arri64(N) < 0) then             pos = 1             rev_pos = N             do while (arri64(rev_pos) < 0)                 buffer(pos) = arri64(rev_pos)                 pos = pos + 1                 rev_pos = rev_pos - 1             end do             buffer(pos:N) = arri64(1:rev_pos)             arri64(:) = buffer(:)         end if         if (optval(reverse, .false.)) then             do i = 1, N/2                 item = array(i)                 array(i) = array(N - i + 1)                 array(N - i + 1) = item             end do         end if         if (use_internal_buffer) then             deallocate (buffer)         end if     end subroutine dp_radix_sort end submodule stdlib_sorting_radix_sort 
stdlib_specialfunctions.f90_stripped module stdlib_specialfunctions     use stdlib_kinds, only: sp, dp, xdp, qp      implicit none      private      public :: legendre      public :: dlegendre        interface legendre                                    pure elemental module function legendre_fp64(n,x) result(leg)             integer, intent(in) :: n             real(dp), intent(in) :: x             real(dp) :: leg         end function     end interface      interface dlegendre                                    pure elemental module function dlegendre_fp64(n,x) result(dleg)             integer, intent(in) :: n             real(dp), intent(in) :: x             real(dp) :: dleg         end function     end interface  end module stdlib_specialfunctions 
stdlib_specialfunctions.f90_comments module stdlib_specialfunctions     use stdlib_kinds, only: sp, dp, xdp, qp      implicit none      private      public :: legendre      public :: dlegendre        interface legendre         !! version: experimental         !!          !! Legendre polynomial         pure elemental module function legendre_fp64(n,x) result(leg)             integer, intent(in) :: n             real(dp), intent(in) :: x             real(dp) :: leg         end function     end interface      interface dlegendre         !! version: experimental         !!          !! First derivative Legendre polynomial         pure elemental module function dlegendre_fp64(n,x) result(dleg)             integer, intent(in) :: n             real(dp), intent(in) :: x             real(dp) :: dleg         end function     end interface  end module stdlib_specialfunctions 
stdlib_specialfunctions_legendre.f90_stripped submodule (stdlib_specialfunctions) stdlib_specialfunctions_legendre     implicit none  contains                pure elemental module function dlegendre_fp64(n,x) result(dleg)         integer, intent(in) :: n         real(dp), intent(in) :: x         real(dp) :: dleg          select case(n)             case(0)                 dleg = 0             case(1)                 dleg = 1             case default                 block                     real(dp) :: leg_down1, leg_down2, leg                     real(dp) :: dleg_down1, dleg_down2                     integer :: i                       leg_down1  = x                     dleg_down1 = 1                      leg_down2  = 1                     dleg_down2 = 0                      do i = 2, n                         leg = (2*i-1)*x*leg_down1/i - (i-1)*leg_down2/i                         dleg = dleg_down2 + (2*i-1)*leg_down1                         leg_down2 = leg_down1                         leg_down1 = leg                         dleg_down2 = dleg_down1                         dleg_down1 = dleg                     end do                 end block         end select     end function                pure elemental module function legendre_fp64(n,x) result(leg)         integer, intent(in) :: n         real(dp), intent(in) :: x         real(dp) :: leg         select case(n)             case(0)                 leg  = 1             case(1)                 leg  = x             case default                 block                     real(dp) :: leg_down1, leg_down2                     integer :: i                       leg_down1  = x                     leg_down2  = 1                      do i = 2, n                         leg = (2*i-1)*x*leg_down1/i - (i-1)*leg_down2/i                         leg_down2 = leg_down1                         leg_down1 = leg                     end do                 end block         end select     end function  end submodule   
stdlib_specialfunctions_legendre.f90_comments submodule (stdlib_specialfunctions) stdlib_specialfunctions_legendre     implicit none  contains      ! derivatives of legegendre polynomials     ! unspecified behaviour if n is negative     pure elemental module function dlegendre_fp64(n,x) result(dleg)         integer, intent(in) :: n         real(dp), intent(in) :: x         real(dp) :: dleg          select case(n)             case(0)                 dleg = 0             case(1)                 dleg = 1             case default                 block                     real(dp) :: leg_down1, leg_down2, leg                     real(dp) :: dleg_down1, dleg_down2                     integer :: i                       leg_down1  = x                     dleg_down1 = 1                      leg_down2  = 1                     dleg_down2 = 0                      do i = 2, n                         leg = (2*i-1)*x*leg_down1/i - (i-1)*leg_down2/i                         dleg = dleg_down2 + (2*i-1)*leg_down1                         leg_down2 = leg_down1                         leg_down1 = leg                         dleg_down2 = dleg_down1                         dleg_down1 = dleg                     end do                 end block         end select     end function      ! legegendre polynomials     ! unspecified behaviour if n is negative     pure elemental module function legendre_fp64(n,x) result(leg)         integer, intent(in) :: n         real(dp), intent(in) :: x         real(dp) :: leg         select case(n)             case(0)                 leg  = 1             case(1)                 leg  = x             case default                 block                     real(dp) :: leg_down1, leg_down2                     integer :: i                       leg_down1  = x                     leg_down2  = 1                      do i = 2, n                         leg = (2*i-1)*x*leg_down1/i - (i-1)*leg_down2/i                         leg_down2 = leg_down1                         leg_down1 = leg                     end do                 end block         end select     end function  end submodule   
stdlib_stringlist_type.f90_stripped                 module stdlib_stringlist_type     use stdlib_string_type, only: string_type, operator(/=)     use stdlib_math, only: clip     implicit none     private      public :: stringlist_type, operator(//), operator(==), operator(/=)     public :: list_head, list_tail, fidx, bidx, stringlist_index_type      type stringlist_index_type         private         logical :: forward         integer :: offset      end type stringlist_index_type      type(stringlist_index_type), parameter :: list_head     = stringlist_index_type( .true. , 1 )        type(stringlist_index_type), parameter :: list_tail     = stringlist_index_type( .false., 1 )                             interface fidx         module procedure forward_index     end interface                          interface bidx         module procedure backward_index     end interface      type stringlist_type         private         type(string_type), dimension(:), allocatable :: stringarray          contains         private          procedure, public :: clear                          =>  clear_list          procedure, public :: len                            =>  length_list          procedure         :: to_future_at_idxn              =>  convert_to_future_at_idxn          procedure         :: to_current_idxn                =>  convert_to_current_idxn          procedure         :: insert_at_char_idx             =>  insert_at_char_idx_wrap         procedure         :: insert_at_string_idx           =>  insert_at_string_idx_wrap         procedure         :: insert_at_stringlist_idx       =>  insert_at_stringlist_idx_wrap         procedure         :: insert_at_chararray_idx        =>  insert_at_chararray_idx_wrap         procedure         :: insert_at_stringarray_idx      =>  insert_at_stringarray_idx_wrap         generic, public   :: insert_at                      =>  insert_at_char_idx,         &                                                                 insert_at_string_idx,       &                                                                 insert_at_stringlist_idx,   &                                                                 insert_at_chararray_idx,    &                                                                 insert_at_stringarray_idx          procedure         :: insert_before_string_int       =>  insert_before_string_int_impl         procedure         :: insert_before_stringlist_int   =>  insert_before_stringlist_int_impl         procedure         :: insert_before_chararray_int    =>  insert_before_chararray_int_impl         procedure         :: insert_before_stringarray_int  =>  insert_before_stringarray_int_impl         generic           :: insert_before                  =>  insert_before_string_int,       &                                                                 insert_before_stringlist_int,   &                                                                 insert_before_chararray_int,    &                                                                 insert_before_stringarray_int          procedure         :: get_string_idx         => get_string_idx_wrap         generic, public   :: get                    => get_string_idx      end type stringlist_type                               interface stringlist_type         module procedure new_stringlist         module procedure new_stringlist_carray         module procedure new_stringlist_sarray     end interface                               interface operator(//)         module procedure append_char         module procedure append_string         module procedure prepend_char         module procedure prepend_string         module procedure append_stringlist         module procedure append_carray         module procedure append_sarray         module procedure prepend_carray         module procedure prepend_sarray     end interface                               interface operator(==)         module procedure eq_stringlist         module procedure eq_stringlist_carray         module procedure eq_stringlist_sarray         module procedure eq_carray_stringlist         module procedure eq_sarray_stringlist     end interface                               interface operator(/=)         module procedure ineq_stringlist         module procedure ineq_stringlist_carray         module procedure ineq_stringlist_sarray         module procedure ineq_carray_stringlist         module procedure ineq_sarray_stringlist     end interface  contains                    pure function new_stringlist()         type(stringlist_type)                           :: new_stringlist      end function new_stringlist                pure function new_stringlist_carray( array )         character(len=*), dimension(:), intent(in)      :: array         type(stringlist_type)                           :: new_stringlist_carray         type(string_type), dimension( size(array) )     :: sarray         integer                                         :: i          do i = 1, size(array)             sarray(i) = string_type( array(i) )         end do          new_stringlist_carray = stringlist_type( sarray )              end function new_stringlist_carray                pure function new_stringlist_sarray( array )         type(string_type), dimension(:), intent(in)     :: array         type(stringlist_type)                           :: new_stringlist_sarray          new_stringlist_sarray = stringlist_type()         new_stringlist_sarray%stringarray = array      end function new_stringlist_sarray               pure function forward_index( idx )         integer, intent(in) :: idx         type(stringlist_index_type) :: forward_index          forward_index = stringlist_index_type( .true., idx )      end function forward_index           pure function backward_index( idx )         integer, intent(in) :: idx         type(stringlist_index_type) :: backward_index          backward_index = stringlist_index_type( .false., idx )      end function backward_index                    function append_char( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         character(len=*), intent(in)      :: rhs         type(stringlist_type)             :: append_char          append_char = lhs // string_type( rhs )      end function append_char                function append_string( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         type(string_type), intent(in)     :: rhs         type(stringlist_type)             :: append_string          append_string = lhs          call append_string%insert_at( list_tail, rhs )      end function append_string                function prepend_char( lhs, rhs )         character(len=*), intent(in)      :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: prepend_char          prepend_char = string_type( lhs ) // rhs      end function prepend_char                function prepend_string( lhs, rhs )         type(string_type), intent(in)     :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: prepend_string          prepend_string = rhs          call prepend_string%insert_at( list_head, lhs )      end function prepend_string                function append_stringlist( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: append_stringlist          append_stringlist = lhs          call append_stringlist%insert_at( list_tail, rhs )      end function append_stringlist                function append_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs         type(stringlist_type)                       :: append_carray          append_carray = lhs          call append_carray%insert_at( list_tail, rhs )      end function append_carray                function append_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs         type(stringlist_type)                       :: append_sarray          append_sarray = lhs          call append_sarray%insert_at( list_tail, rhs )      end function append_sarray                function prepend_carray( lhs, rhs )         character(len=*), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)          :: rhs         type(stringlist_type)                      :: prepend_carray          prepend_carray = rhs          call prepend_carray%insert_at( list_head, lhs )      end function prepend_carray                function prepend_sarray( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs         type(stringlist_type)                       :: prepend_sarray          prepend_sarray = rhs          call prepend_sarray%insert_at( list_head, lhs )      end function prepend_sarray                    pure logical function eq_stringlist( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(stringlist_type), intent(in)           :: rhs         integer                                     :: i          eq_stringlist = .false.         if ( lhs%len() == rhs%len() ) then             eq_stringlist = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs%stringarray(i) ) then                     eq_stringlist = .false.                     exit                 end if             end do         end if      end function eq_stringlist                pure logical function eq_stringlist_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs         integer                                     :: i          eq_stringlist_carray = .false.         if ( lhs%len() == size( rhs ) ) then             eq_stringlist_carray = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs(i) ) then                     eq_stringlist_carray = .false.                     exit                 end if             end do         end if      end function eq_stringlist_carray                pure logical function eq_stringlist_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs         integer                                     :: i          eq_stringlist_sarray = .false.         if ( lhs%len() == size( rhs ) ) then             eq_stringlist_sarray = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs(i) ) then                     eq_stringlist_sarray = .false.                     exit                 end if             end do         end if      end function eq_stringlist_sarray                pure logical function eq_carray_stringlist( lhs, rhs )         character(len=*), dimension(:), intent(in)  :: lhs         type(stringlist_type), intent(in)           :: rhs          eq_carray_stringlist = ( rhs == lhs )      end function eq_carray_stringlist                pure logical function eq_sarray_stringlist( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs          eq_sarray_stringlist = ( rhs == lhs )      end function eq_sarray_stringlist                    pure logical function ineq_stringlist( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_stringlist = .not.( lhs == rhs )      end function ineq_stringlist                pure logical function ineq_stringlist_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs          ineq_stringlist_carray = .not.( lhs == rhs )       end function ineq_stringlist_carray                pure logical function ineq_stringlist_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs          ineq_stringlist_sarray = .not.( lhs == rhs )       end function ineq_stringlist_sarray                pure logical function ineq_carray_stringlist( lhs, rhs )         character(len=*), dimension(:), intent(in)  :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_carray_stringlist = .not.( lhs == rhs)      end function ineq_carray_stringlist                pure logical function ineq_sarray_stringlist( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_sarray_stringlist = .not.( lhs == rhs )      end function ineq_sarray_stringlist                              subroutine clear_list( list )         class(stringlist_type), intent(inout) :: list          if ( allocated( list%stringarray ) ) then             deallocate( list%stringarray )         end if      end subroutine clear_list                              pure integer function length_list( list )         class(stringlist_type), intent(in) :: list          length_list = 0         if ( allocated( list%stringarray ) ) then             length_list = size( list%stringarray )         end if      end function length_list                                   pure integer function convert_to_future_at_idxn( list, idx )                  class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx                   convert_to_future_at_idxn = merge( idx%offset, list%len() - idx%offset + 2 , idx%forward )      end function convert_to_future_at_idxn                              pure integer function convert_to_current_idxn( list, idx )                  class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx                   convert_to_current_idxn = merge( idx%offset, list%len() - idx%offset + 1, idx%forward )      end function convert_to_current_idxn                              subroutine insert_at_char_idx_wrap( list, idx, string )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         character(len=*), intent(in)                :: string          call list%insert_at( idx, string_type( string ) )      end subroutine insert_at_char_idx_wrap                          subroutine insert_at_string_idx_wrap( list, idx, string )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(string_type), intent(in)               :: string          call list%insert_before( list%to_future_at_idxn( idx ), string )      end subroutine insert_at_string_idx_wrap                          subroutine insert_at_stringlist_idx_wrap( list, idx, slist )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(stringlist_type), intent(in)           :: slist          call list%insert_before( list%to_future_at_idxn( idx ), slist )      end subroutine insert_at_stringlist_idx_wrap                          subroutine insert_at_chararray_idx_wrap( list, idx, carray )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         character(len=*), dimension(:), intent(in)  :: carray          call list%insert_before( list%to_future_at_idxn( idx ), carray )      end subroutine insert_at_chararray_idx_wrap                          subroutine insert_at_stringarray_idx_wrap( list, idx, sarray )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(string_type), dimension(:), intent(in) :: sarray          call list%insert_before( list%to_future_at_idxn( idx ), sarray )      end subroutine insert_at_stringarray_idx_wrap                          subroutine insert_before_empty_positions( list, idxn, positions )                  class(stringlist_type), intent(inout)           :: list         integer, intent(inout)                          :: idxn         integer, intent(in)                             :: positions          integer                                         :: i, inew         integer                                         :: new_len, old_len         type(string_type), dimension(:), allocatable    :: new_stringarray          if (positions > 0) then              idxn    = clip( idxn, 1, list%len() + 1 )             old_len = list%len()             new_len = old_len + positions              allocate( new_stringarray(new_len) )              do i = 1, idxn - 1                                  new_stringarray(i) = list%stringarray(i)             end do             do i = idxn, old_len                 inew = i + positions                                  new_stringarray(inew) = list%stringarray(i)             end do              call move_alloc( new_stringarray, list%stringarray )          end if      end subroutine insert_before_empty_positions                          subroutine insert_before_string_int_impl( list, idxn, string )                  class(stringlist_type), intent(inout)           :: list         integer, intent(in)                             :: idxn         type(string_type), intent(in)                   :: string          integer                                         :: work_idxn          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, 1 )          list%stringarray(work_idxn) = string      end subroutine insert_before_string_int_impl                          subroutine insert_before_stringlist_int_impl( list, idxn, slist )                  class(stringlist_type), intent(inout)           :: list         integer, intent(in)                             :: idxn         type(stringlist_type), intent(in)               :: slist          integer                                         :: i         integer                                         :: work_idxn, idxnew         integer                                         :: pre_length, post_length          work_idxn   = idxn         pre_length  = slist%len()         call insert_before_empty_positions( list, work_idxn, pre_length )         post_length = slist%len()          do i = 1, min( work_idxn - 1, pre_length )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = slist%stringarray(i)         end do          do i = work_idxn + post_length - pre_length, post_length             idxnew = work_idxn + i - post_length + pre_length - 1             list%stringarray(idxnew) = slist%stringarray(i)         end do      end subroutine insert_before_stringlist_int_impl                          subroutine insert_before_chararray_int_impl( list, idxn, carray )                  class(stringlist_type), intent(inout)        :: list         integer, intent(in)                          :: idxn         character(len=*), dimension(:), intent(in)   :: carray          integer                                      :: i         integer                                      :: work_idxn, idxnew          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, size( carray ) )          do i = 1, size( carray )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = string_type( carray(i) )         end do      end subroutine insert_before_chararray_int_impl                          subroutine insert_before_stringarray_int_impl( list, idxn, sarray )                  class(stringlist_type), intent(inout)        :: list         integer, intent(in)                          :: idxn         type(string_type), dimension(:), intent(in)  :: sarray          integer                                      :: i         integer                                      :: work_idxn, idxnew          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, size( sarray ) )          do i = 1, size( sarray )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = sarray(i)         end do      end subroutine insert_before_stringarray_int_impl                              pure function get_string_idx_wrap( list, idx )         class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx         type(string_type)                       :: get_string_idx_wrap          integer                                 :: idxn          idxn = list%to_current_idxn( idx )                   if ( 1 <= idxn .and. idxn <= list%len() ) then             get_string_idx_wrap = list%stringarray(idxn)          end if      end function get_string_idx_wrap   end module stdlib_stringlist_type 
stdlib_stringlist_type.f90_comments ! stdlib_stringlist_type.f90 -- !     Module for storing and manipulating list of strings !     The strings may have arbitrary lengths, not necessarily the same ! !     insert AT:      Inserts an element BEFORE the element present currently at the asked index !                       for forward indexes !                     Inserts an element AFTER the element present currently at the asked index !                       for backward indexes !                     In other words, after insertion the element will be present at the asked index !                       for both forward and backward indexes                     !     insert BEFORE:  Inserts an element BEFORE the element present currently at the asked index !     insert AFTER:   Inserts an element AFTER the element present currently at the asked index ! !     Note the distinction between AT and BEFORE in the module. Care has been taken to keep it consistent !     throughout the PR ! module stdlib_stringlist_type     use stdlib_string_type, only: string_type, operator(/=)     use stdlib_math, only: clip     implicit none     private      public :: stringlist_type, operator(//), operator(==), operator(/=)     public :: list_head, list_tail, fidx, bidx, stringlist_index_type      type stringlist_index_type         private         logical :: forward         integer :: offset      end type stringlist_index_type      type(stringlist_index_type), parameter :: list_head     = stringlist_index_type( .true. , 1 )   ! fidx(1)     type(stringlist_index_type), parameter :: list_tail     = stringlist_index_type( .false., 1 )   ! bidx(1)      !> Version: experimental     !>      !> Returns an instance of type 'stringlist_index_type' representing forward index     !> [Specifications](../page/specs/stdlib_stringlist_type.html#fidx)     interface fidx         module procedure forward_index     end interface      !> Version: experimental     !>      !> Returns an instance of type 'stringlist_index_type' representing backward index     !> [Specifications](../page/specs/stdlib_stringlist_type.html#bidx)     interface bidx         module procedure backward_index     end interface      type stringlist_type         private         type(string_type), dimension(:), allocatable :: stringarray          contains         private          procedure, public :: clear                          =>  clear_list          procedure, public :: len                            =>  length_list          procedure         :: to_future_at_idxn              =>  convert_to_future_at_idxn          procedure         :: to_current_idxn                =>  convert_to_current_idxn          procedure         :: insert_at_char_idx             =>  insert_at_char_idx_wrap         procedure         :: insert_at_string_idx           =>  insert_at_string_idx_wrap         procedure         :: insert_at_stringlist_idx       =>  insert_at_stringlist_idx_wrap         procedure         :: insert_at_chararray_idx        =>  insert_at_chararray_idx_wrap         procedure         :: insert_at_stringarray_idx      =>  insert_at_stringarray_idx_wrap         generic, public   :: insert_at                      =>  insert_at_char_idx,         &                                                                 insert_at_string_idx,       &                                                                 insert_at_stringlist_idx,   &                                                                 insert_at_chararray_idx,    &                                                                 insert_at_stringarray_idx          procedure         :: insert_before_string_int       =>  insert_before_string_int_impl         procedure         :: insert_before_stringlist_int   =>  insert_before_stringlist_int_impl         procedure         :: insert_before_chararray_int    =>  insert_before_chararray_int_impl         procedure         :: insert_before_stringarray_int  =>  insert_before_stringarray_int_impl         generic           :: insert_before                  =>  insert_before_string_int,       &                                                                 insert_before_stringlist_int,   &                                                                 insert_before_chararray_int,    &                                                                 insert_before_stringarray_int          procedure         :: get_string_idx         => get_string_idx_wrap         generic, public   :: get                    => get_string_idx      end type stringlist_type      !> Version: experimental     !>     !> Constructor for stringlist     !> Returns an instance of type stringlist_type     !> [Specifications](../page/specs/stdlib_stringlist_type.html#stringlist_type)     interface stringlist_type         module procedure new_stringlist         module procedure new_stringlist_carray         module procedure new_stringlist_sarray     end interface      !> Version: experimental     !>      !> Concatenates stringlist with the input entity     !> Returns a new stringlist     !> [Specifications](../page/specs/stdlib_stringlist_type.html#append-operator)     interface operator(//)         module procedure append_char         module procedure append_string         module procedure prepend_char         module procedure prepend_string         module procedure append_stringlist         module procedure append_carray         module procedure append_sarray         module procedure prepend_carray         module procedure prepend_sarray     end interface      !> Version: experimental     !>      !> Compares stringlist for equality with the input entity     !> Returns a logical     !> [Specifications](../page/specs/stdlib_stringlist_type.html#equality-operator)     interface operator(==)         module procedure eq_stringlist         module procedure eq_stringlist_carray         module procedure eq_stringlist_sarray         module procedure eq_carray_stringlist         module procedure eq_sarray_stringlist     end interface      !> Version: experimental     !>      !> Compares stringlist for inequality with the input entity     !> Returns a logical     !> [Specifications](../page/specs/stdlib_stringlist_type.html#inequality-operator)     interface operator(/=)         module procedure ineq_stringlist         module procedure ineq_stringlist_carray         module procedure ineq_stringlist_sarray         module procedure ineq_carray_stringlist         module procedure ineq_sarray_stringlist     end interface  contains    ! constructor for stringlist_type:      !> Constructor with no argument     !> Returns a new instance of type stringlist      pure function new_stringlist()         type(stringlist_type)                           :: new_stringlist      end function new_stringlist      !> Constructor to convert chararray to stringlist     !> Returns a new instance of type stringlist     pure function new_stringlist_carray( array )         character(len=*), dimension(:), intent(in)      :: array         type(stringlist_type)                           :: new_stringlist_carray         type(string_type), dimension( size(array) )     :: sarray         integer                                         :: i          do i = 1, size(array)             sarray(i) = string_type( array(i) )         end do          new_stringlist_carray = stringlist_type( sarray )              end function new_stringlist_carray      !> Constructor to convert stringarray to stringlist     !> Returns a new instance of type stringlist     pure function new_stringlist_sarray( array )         type(string_type), dimension(:), intent(in)     :: array         type(stringlist_type)                           :: new_stringlist_sarray          new_stringlist_sarray = stringlist_type()         new_stringlist_sarray%stringarray = array      end function new_stringlist_sarray    ! constructor for stringlist_index_type:      !> Returns an instance of type 'stringlist_index_type' representing forward index 'idx'     pure function forward_index( idx )         integer, intent(in) :: idx         type(stringlist_index_type) :: forward_index          forward_index = stringlist_index_type( .true., idx )      end function forward_index      !> Returns an instance of type 'stringlist_index_type' representing backward index 'idx'     pure function backward_index( idx )         integer, intent(in) :: idx         type(stringlist_index_type) :: backward_index          backward_index = stringlist_index_type( .false., idx )      end function backward_index    ! concatenation operator:      !> Appends character scalar 'rhs' to the stringlist 'list'     !> Returns a new stringlist     function append_char( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         character(len=*), intent(in)      :: rhs         type(stringlist_type)             :: append_char          append_char = lhs // string_type( rhs )      end function append_char      !> Appends string 'rhs' to the stringlist 'list'     !> Returns a new stringlist     function append_string( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         type(string_type), intent(in)     :: rhs         type(stringlist_type)             :: append_string          append_string = lhs ! Intent: creating a full, deep copy         call append_string%insert_at( list_tail, rhs )      end function append_string      !> Prepends character scalar 'lhs' to the stringlist 'rhs'     !> Returns a new stringlist     function prepend_char( lhs, rhs )         character(len=*), intent(in)      :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: prepend_char          prepend_char = string_type( lhs ) // rhs      end function prepend_char      !> Prepends string 'lhs' to the stringlist 'rhs'     !> Returns a new stringlist     function prepend_string( lhs, rhs )         type(string_type), intent(in)     :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: prepend_string          prepend_string = rhs ! Intent: creating a full, deep copy         call prepend_string%insert_at( list_head, lhs )      end function prepend_string      !> Appends stringlist 'rhs' to the stringlist 'lhs'     !> Returns a new stringlist     function append_stringlist( lhs, rhs )         type(stringlist_type), intent(in) :: lhs         type(stringlist_type), intent(in) :: rhs         type(stringlist_type)             :: append_stringlist          append_stringlist = lhs ! Intent: creating a full, deep copy         call append_stringlist%insert_at( list_tail, rhs )      end function append_stringlist      !> Appends chararray 'rhs' to the stringlist 'lhs'     !> Returns a new stringlist     function append_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs         type(stringlist_type)                       :: append_carray          append_carray = lhs ! Intent: creating a full, deep copy         call append_carray%insert_at( list_tail, rhs )      end function append_carray      !> Appends stringarray 'rhs' to the stringlist 'lhs'     !> Returns a new stringlist     function append_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs         type(stringlist_type)                       :: append_sarray          append_sarray = lhs ! Intent: creating a full, deep copy         call append_sarray%insert_at( list_tail, rhs )      end function append_sarray      !> Prepends chararray 'lhs' to the stringlist 'rhs'     !> Returns a new stringlist     function prepend_carray( lhs, rhs )         character(len=*), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)          :: rhs         type(stringlist_type)                      :: prepend_carray          prepend_carray = rhs ! Intent: creating a full, deep copy         call prepend_carray%insert_at( list_head, lhs )      end function prepend_carray      !> Prepends stringarray 'lhs' to the stringlist 'rhs'     !> Returns a new stringlist     function prepend_sarray( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs         type(stringlist_type)                       :: prepend_sarray          prepend_sarray = rhs ! Intent: creating a full, deep copy         call prepend_sarray%insert_at( list_head, lhs )      end function prepend_sarray    ! equality operator:      !> Compares stringlist 'lhs' for equality with stringlist 'rhs'     !> Returns a logical     pure logical function eq_stringlist( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(stringlist_type), intent(in)           :: rhs         integer                                     :: i          eq_stringlist = .false.         if ( lhs%len() == rhs%len() ) then             eq_stringlist = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs%stringarray(i) ) then                     eq_stringlist = .false.                     exit                 end if             end do         end if      end function eq_stringlist      !> Compares stringlist 'lhs' for equality with chararray 'rhs'     !> Returns a logical     pure logical function eq_stringlist_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs         integer                                     :: i          eq_stringlist_carray = .false.         if ( lhs%len() == size( rhs ) ) then             eq_stringlist_carray = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs(i) ) then                     eq_stringlist_carray = .false.                     exit                 end if             end do         end if      end function eq_stringlist_carray      !> Compares stringlist 'lhs' for equality with stringarray 'rhs'     !> Returns a logical     pure logical function eq_stringlist_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs         integer                                     :: i          eq_stringlist_sarray = .false.         if ( lhs%len() == size( rhs ) ) then             eq_stringlist_sarray = .true.             do i = 1, lhs%len()                 if ( lhs%stringarray(i) /= rhs(i) ) then                     eq_stringlist_sarray = .false.                     exit                 end if             end do         end if      end function eq_stringlist_sarray      !> Compares chararray 'lhs' for equality with stringlist 'rhs'     !> Returns a logical     pure logical function eq_carray_stringlist( lhs, rhs )         character(len=*), dimension(:), intent(in)  :: lhs         type(stringlist_type), intent(in)           :: rhs          eq_carray_stringlist = ( rhs == lhs )      end function eq_carray_stringlist      !> Compares stringarray 'lhs' for equality with stringlist 'rhs'     !> Returns a logical     pure logical function eq_sarray_stringlist( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs          eq_sarray_stringlist = ( rhs == lhs )      end function eq_sarray_stringlist    ! inequality operator:      !> Compares stringlist 'lhs' for inequality with stringlist 'rhs'     !> Returns a logical     pure logical function ineq_stringlist( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_stringlist = .not.( lhs == rhs )      end function ineq_stringlist      !> Compares stringlist 'lhs' for inequality with chararray 'rhs'     !> Returns a logical     pure logical function ineq_stringlist_carray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         character(len=*), dimension(:), intent(in)  :: rhs          ineq_stringlist_carray = .not.( lhs == rhs )       end function ineq_stringlist_carray      !> Compares stringlist 'lhs' for inequality with stringarray 'rhs'     !> Returns a logical     pure logical function ineq_stringlist_sarray( lhs, rhs )         type(stringlist_type), intent(in)           :: lhs         type(string_type), dimension(:), intent(in) :: rhs          ineq_stringlist_sarray = .not.( lhs == rhs )       end function ineq_stringlist_sarray      !> Compares chararray 'lhs' for inequality with stringlist 'rhs'     !> Returns a logical     pure logical function ineq_carray_stringlist( lhs, rhs )         character(len=*), dimension(:), intent(in)  :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_carray_stringlist = .not.( lhs == rhs)      end function ineq_carray_stringlist      !> Compares stringarray 'lhs' for inequality with stringlist 'rhs'     !> Returns a logical     pure logical function ineq_sarray_stringlist( lhs, rhs )         type(string_type), dimension(:), intent(in) :: lhs         type(stringlist_type), intent(in)           :: rhs          ineq_sarray_stringlist = .not.( lhs == rhs )      end function ineq_sarray_stringlist    ! clear:      !> Version: experimental     !>     !> Resets stringlist 'list' to an empy stringlist of len 0     !> Modifies the input stringlist 'list'     subroutine clear_list( list )         class(stringlist_type), intent(inout) :: list          if ( allocated( list%stringarray ) ) then             deallocate( list%stringarray )         end if      end subroutine clear_list    ! len:      !> Version: experimental     !>     !> Returns the len (length) of the list     !> Returns an integer     pure integer function length_list( list )         class(stringlist_type), intent(in) :: list          length_list = 0         if ( allocated( list%stringarray ) ) then             length_list = size( list%stringarray )         end if      end function length_list    ! to_future_at_idxn:      !> Version: experimental     !>     !> Converts a forward index OR a backward index to an integer index at     !> which the new element will be present post insertion (i.e. in future)     !> Returns an integer     pure integer function convert_to_future_at_idxn( list, idx )         !> Not a part of public API         class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx          ! Formula: merge( fidx( x ) - ( list_head - 1 ), len - bidx( x ) + ( list_tail - 1 ) + 2, ... )         convert_to_future_at_idxn = merge( idx%offset, list%len() - idx%offset + 2 , idx%forward )      end function convert_to_future_at_idxn    ! to_current_idxn:      !> Version: experimental     !>     !> Converts a forward index OR backward index to its equivalent integer index idxn     !> Returns an integer     pure integer function convert_to_current_idxn( list, idx )         !> Not a part of public API         class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx          ! Formula: merge( fidx( x ) - ( list_head - 1 ), len + 1 - bidx( x ) + ( list_tail - 1 ), ... )         convert_to_current_idxn = merge( idx%offset, list%len() - idx%offset + 1, idx%forward )      end function convert_to_current_idxn    ! insert_at:      !> Version: experimental     !>     !> Inserts character scalar 'string' AT stringlist_index 'idx' in stringlist 'list'     !> Modifies the input stringlist 'list'     subroutine insert_at_char_idx_wrap( list, idx, string )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         character(len=*), intent(in)                :: string          call list%insert_at( idx, string_type( string ) )      end subroutine insert_at_char_idx_wrap      !> Version: experimental     !>     !> Inserts string 'string' AT stringlist_index 'idx' in stringlist 'list'     !> Modifies the input stringlist 'list'     subroutine insert_at_string_idx_wrap( list, idx, string )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(string_type), intent(in)               :: string          call list%insert_before( list%to_future_at_idxn( idx ), string )      end subroutine insert_at_string_idx_wrap      !> Version: experimental     !>     !> Inserts stringlist 'slist' AT stringlist_index 'idx' in stringlist 'list'     !> Modifies the input stringlist 'list'     subroutine insert_at_stringlist_idx_wrap( list, idx, slist )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(stringlist_type), intent(in)           :: slist          call list%insert_before( list%to_future_at_idxn( idx ), slist )      end subroutine insert_at_stringlist_idx_wrap      !> Version: experimental     !>     !> Inserts chararray 'carray' AT stringlist_index 'idx' in stringlist 'list'     !> Modifies the input stringlist 'list'     subroutine insert_at_chararray_idx_wrap( list, idx, carray )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         character(len=*), dimension(:), intent(in)  :: carray          call list%insert_before( list%to_future_at_idxn( idx ), carray )      end subroutine insert_at_chararray_idx_wrap      !> Version: experimental     !>     !> Inserts stringarray 'sarray' AT stringlist_index 'idx' in stringlist 'list'     !> Modifies the input stringlist 'list'     subroutine insert_at_stringarray_idx_wrap( list, idx, sarray )         class(stringlist_type), intent(inout)       :: list         type(stringlist_index_type), intent(in)     :: idx         type(string_type), dimension(:), intent(in) :: sarray          call list%insert_before( list%to_future_at_idxn( idx ), sarray )      end subroutine insert_at_stringarray_idx_wrap      !> Version: experimental     !>     !> Inserts 'positions' number of empty positions BEFORE integer index 'idxn'     !> Modifies the input stringlist 'list'     subroutine insert_before_empty_positions( list, idxn, positions )         !> Not a part of public API         class(stringlist_type), intent(inout)           :: list         integer, intent(inout)                          :: idxn         integer, intent(in)                             :: positions          integer                                         :: i, inew         integer                                         :: new_len, old_len         type(string_type), dimension(:), allocatable    :: new_stringarray          if (positions > 0) then              idxn    = clip( idxn, 1, list%len() + 1 )             old_len = list%len()             new_len = old_len + positions              allocate( new_stringarray(new_len) )              do i = 1, idxn - 1                 ! TODO: can be improved by move                 new_stringarray(i) = list%stringarray(i)             end do             do i = idxn, old_len                 inew = i + positions                 ! TODO: can be improved by move                 new_stringarray(inew) = list%stringarray(i)             end do              call move_alloc( new_stringarray, list%stringarray )          end if      end subroutine insert_before_empty_positions      !> Version: experimental     !>     !> Inserts string 'string' BEFORE integer index 'idxn' in the underlying stringarray     !> Modifies the input stringlist 'list'     subroutine insert_before_string_int_impl( list, idxn, string )         !> Not a part of public API         class(stringlist_type), intent(inout)           :: list         integer, intent(in)                             :: idxn         type(string_type), intent(in)                   :: string          integer                                         :: work_idxn          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, 1 )          list%stringarray(work_idxn) = string      end subroutine insert_before_string_int_impl      !> Version: experimental     !>     !> Inserts stringlist 'slist' BEFORE integer index 'idxn' in the underlying stringarray     !> Modifies the input stringlist 'list'     subroutine insert_before_stringlist_int_impl( list, idxn, slist )         !> Not a part of public API         class(stringlist_type), intent(inout)           :: list         integer, intent(in)                             :: idxn         type(stringlist_type), intent(in)               :: slist          integer                                         :: i         integer                                         :: work_idxn, idxnew         integer                                         :: pre_length, post_length          work_idxn   = idxn         pre_length  = slist%len()         call insert_before_empty_positions( list, work_idxn, pre_length )         post_length = slist%len()          do i = 1, min( work_idxn - 1, pre_length )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = slist%stringarray(i)         end do          do i = work_idxn + post_length - pre_length, post_length             idxnew = work_idxn + i - post_length + pre_length - 1             list%stringarray(idxnew) = slist%stringarray(i)         end do      end subroutine insert_before_stringlist_int_impl      !> Version: experimental     !>     !> Inserts chararray 'carray' BEFORE integer index 'idxn' in the underlying stringarray     !> Modifies the input stringlist 'list'     subroutine insert_before_chararray_int_impl( list, idxn, carray )         !> Not a part of public API         class(stringlist_type), intent(inout)        :: list         integer, intent(in)                          :: idxn         character(len=*), dimension(:), intent(in)   :: carray          integer                                      :: i         integer                                      :: work_idxn, idxnew          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, size( carray ) )          do i = 1, size( carray )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = string_type( carray(i) )         end do      end subroutine insert_before_chararray_int_impl      !> Version: experimental     !>     !> Inserts stringarray 'sarray' BEFORE integer index 'idxn' in the underlying stringarray     !> Modifies the input stringlist 'list'     subroutine insert_before_stringarray_int_impl( list, idxn, sarray )         !> Not a part of public API         class(stringlist_type), intent(inout)        :: list         integer, intent(in)                          :: idxn         type(string_type), dimension(:), intent(in)  :: sarray          integer                                      :: i         integer                                      :: work_idxn, idxnew          work_idxn = idxn         call insert_before_empty_positions( list, work_idxn, size( sarray ) )          do i = 1, size( sarray )             idxnew = work_idxn + i - 1             list%stringarray(idxnew) = sarray(i)         end do      end subroutine insert_before_stringarray_int_impl    ! get:      !> Version: experimental     !>     !> Returns the string present at stringlist_index 'idx' in stringlist 'list'     !> Returns string_type instance     pure function get_string_idx_wrap( list, idx )         class(stringlist_type), intent(in)      :: list         type(stringlist_index_type), intent(in) :: idx         type(string_type)                       :: get_string_idx_wrap          integer                                 :: idxn          idxn = list%to_current_idxn( idx )          ! if the index is out of bounds, return a string_type equivalent to empty string         if ( 1 <= idxn .and. idxn <= list%len() ) then             get_string_idx_wrap = list%stringarray(idxn)          end if      end function get_string_idx_wrap   end module stdlib_stringlist_type 
